<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift-UIKit-UIWebView-简介]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UIWebView-简介/</url>
    <content type="text"><![CDATA[UIWebView的常用属性 1.设置 UIWebView 的代理对象 var delegate: UIWebViewDelegate? 2.获取 UIWebView 的 UIScrollView 属性 var scrollView: UIScrollView &#123; get &#125; 3.获取 UIWebView 的网络请求 var request: NSURLRequest? &#123; get &#125; 4.获取 UIWebView 是否在接收数据的时候可以退后一步 var canGoBack: Bool &#123; get &#125; 5.获取 UIWebView 是否在接收数据的时候可以前进一步 var canGoForward: Bool &#123; get &#125;``` &gt; 6.获取 UIWebView 是否接受完数据```swift var loading: Bool &#123; get &#125; 7.设置 UIWebView 接收的数据是否可以通过手势来调整页面内容大小 var scalesPageToFit: Bool 8.设置 UIWebView 接收的数据是什么类型 var dataDetectorTypes: UIDataDetectorTypes 9.设置 UIWebView 内是否可以回放媒体 var allowsInlineMediaPlayback: Bool 10.设置 UIWebView 中的 HTML5 视频是否自动播放(默认是True) var mediaPlaybackRequiresUserAction: Bool 11.设置 UIWebView 是否可以使用 Air 播放(默认是True) var mediaPlaybackAllowsAirPlay: Bool 12.设置 UIWebView 是否使用同步加载(默认是False) var suppressesIncrementalRendering: Bool 13.设置 UIWebView 在点击视图或者元素时是否显示键盘(默认是True) var keyboardDisplayRequiresUserAction: Bool 14.设置 UIWebView 的分页模式 var paginationMode: UIWebPaginationMode 15.设置 UIWebView 的分页打破模式 var paginationBreakingMode: UIWebPaginationBreakingMode 16.设置 UIWebView 的分页长度 var pageLength: CGFloat 17.设置 UIWebView 之间的页面宽度 var gapBetweenPages: CGFloat 18.获取 UIWebView 的页面数量 var pageCount: Int &#123; get &#125; 常用类型 1.获取 UIWebView 的数据类型 struct UIDataDetectorTypes : RawOptionSetType &#123; init(_ rawValue: UInt) init(rawValue: UInt) static var PhoneNumber: UIDataDetectorTypes &#123; get &#125; static var Link: UIDataDetectorTypes &#123; get &#125; static var Address: UIDataDetectorTypes &#123; get &#125; static var CalendarEvent: UIDataDetectorTypes &#123; get &#125; static var None: UIDataDetectorTypes &#123; get &#125; static var All: UIDataDetectorTypes &#123; get &#125;&#125; 2.设置 UIWebView 的 Navigation 类型 enum UIWebViewNavigationType : Int &#123; case LinkClicked case FormSubmitted case BackForward case Reload case FormResubmitted case Other&#125; 3.设置 UIWebView 的分页样式 enum UIWebPaginationMode : Int &#123; case Unpaginated case LeftToRight case TopToBottom case BottomToTop case RightToLeft&#125; 4.设置 UIWebView 打破分页样式的样式 enum UIWebPaginationBreakingMode : Int &#123; case Page case Column&#125; UIWebView的代理方法 1.该方法是用来设置是否在 UIWebView 加载之前发送一个请求 optional func webView(webView: UIWebView, shouldStartLoadWithRequest request: NSURLRequest, navigationType: UIWebViewNavigationType) -&gt; Bool 2.该方法是在 UIWebView 在开发加载时调用 optional func webViewDidStartLoad(webView: UIWebView) 3.该方法是在 UIWebView 加载完之后才调用 optional func webViewDidFinishLoad(webView: UIWebView) 4.该方法是在 UIWebView 请求失败的时候调用 optional func webView(webView: UIWebView, didFailLoadWithError error: NSError)]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UIWebView</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UIWebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UIWebView-简单使用]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UIWebView-简单使用/</url>
    <content type="text"><![CDATA[UIWebView UIWebView 继承与 UIView, 并且遵守了 UIScrollViewDelegate 协议, 所以它可以使用里面的方法和属性 遵守代理协议 class ViewController: UIViewController, UIWebViewDelegate &#123;&#125; 自定义UIWebVIewfunc myWebView() &#123; // 1.获取 UIWebView 的 UIScrollView 属性 let webScroll = webView.scrollView println("webScroll = \(webScroll)") // 2.获取 UIWebView 的 request 属性 let webRequest = webView.request println("webRequest = \(webRequest)") // 3.获取 UIWebView 是否在接收数据的时候可以退后一步 let webCanBack = webView.canGoBack println("webCanBack = \(webCanBack)") // 4.获取 UIWebView 是否在接收数据的时候可以前进一步 let webCanGo = webView.canGoForward println("webCanGo = \(webCanGo)") // 5.获取 UIWebVIew 是否接受完数据 let webLoading = webView.loading println("webLoading = \(webLoading)") // 6.设置 UIWebView 接收的数据是否可以通过手势来调整页面内容大小 webView.scalesPageToFit = true // 7.设置 UIWebView 接收到得数据是什么类型的 webView.dataDetectorTypes = UIDataDetectorTypes.All // 8.设置 UIWebView 内是否可以回放媒体 webView.allowsInlineMediaPlayback = true // 9.设置 UIWebView 中的 HTML5 视频是否自动播放 webView.mediaPlaybackRequiresUserAction = true // 10.设置 UIWebView 是否可以使用 Air 播放 webView.mediaPlaybackAllowsAirPlay = true // 11.设置 UIWebView 是否使用同步加载(默认是False) webView.suppressesIncrementalRendering = false // 12.设置 UIWebView 在点击视图或者元素时是否显示键盘(默认是True) webView.keyboardDisplayRequiresUserAction = true // 13.设置 UIWebView 的分页模式 webView.paginationMode = UIWebPaginationMode.RightToLeft // 14.设置 UIWebView 的分页打破模式 webView.paginationBreakingMode = UIWebPaginationBreakingMode.Column // 15.设置 UIWebView 的分页长度 webView.pageLength = 400 // 16.设置 UIWebView 每个分页之间的宽度 webView.gapBetweenPages = 100 // 17.获取 UIWebView 的分页数量 let webViewPageCount = webView.pageCount println(webViewPageCount) // 18.设置 UIWebView 的代理对象 webView.delegate = self // 19.发送网络请求 var url:NSURL = NSURL(string:"http://www.baidu.com")! var request:NSURLRequest = NSURLRequest(URL:url) webView.loadRequest(request) &#125; 实现代理方法// 1.该方法是用来设置是否在 UIWebView 加载之前发送一个请求 func webView(webView: UIWebView, shouldStartLoadWithRequest request: NSURLRequest, navigationType: UIWebViewNavigationType) -&gt; Bool &#123; return true &#125; // 2.该方法是在 UIWebView 在开发加载时调用 func webViewDidStartLoad(webView: UIWebView) &#123; println("开始加载") &#125; // 3.该方法是在 UIWebView 加载完之后才调用 func webViewDidFinishLoad(webView: UIWebView) &#123; println("加载完成") &#125; // 4.该方法是在 UIWebView 请求失败的时候调用 func webView(webView: UIWebView, didFailLoadWithError error: NSError) &#123; println("加载失败") &#125; 在 ViewDidLoad 方法中实现override func viewDidLoad() &#123; super.viewDidLoad() self.myWebView() &#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UIWebView</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UIWebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UINavigationController-简单使用]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UINavigationController-简单使用/</url>
    <content type="text"><![CDATA[UINavigationController UINavigationController 是继承与 UIViewController 的, 所以里面的方法以及属性都是可以使用的. 首先我们要再AppDelegate.swift文件中实现func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool &#123; // Override point for customization after application launch. self.window = UIWindow(frame: UIScreen.mainScreen().bounds) self.window!.backgroundColor = UIColor.grayColor() self.window!.makeKeyAndVisible() let viewController = ViewController() let navigationController = UINavigationController(rootViewController: viewController) self.window!.rootViewController = navigationController return true &#125; 遵守代理协议class ViewController: UIViewController, UINavigationControllerDelegate &#123; &#125; 自定义UINavigationControllerfunc myNavigationContronller() &#123; // 1.设置 UINavigationController 的 Title self.title = "UINavigationContronller" // 2.设置 UIVavigationController 的按钮 Title, Style, Target, Action 等方法属性 let backBarButtonItem = UIBarButtonItem(title: "返回", style: UIBarButtonItemStyle.Plain, target: self, action: "backAction") let nextBarButtonItem = UIBarButtonItem(title: "下一页", style: UIBarButtonItemStyle.Plain, target: self, action: "nextAction") // 3.设置 UINavigationItem self.navigationItem.leftBarButtonItem = backBarButtonItem self.navigationItem.rightBarButtonItem = nextBarButtonItem // 4.获取 UINavigationController 的顶部的视图控制器 let topView = self.navigationController?.topViewController println(topView) // 5.获取 UINavigationController 可见的视图控制器 let visibleView = self.navigationController?.visibleViewController println(visibleView) // 6.设置 UINavigationController 的导航栏控制器 self.navigationController?.viewControllers // 7.设置 UINavigationController 的导航栏控制器是否隐藏(默认是 false) self.navigationController?.navigationBarHidden = false // 8.获取 UINavigationController 的导航栏控制器 let navigationBar = self.navigationController?.navigationBar println(navigationBar) // 9.设置 UINavigationController 的内置工具栏是否可见(默认是 ture) self.navigationController?.toolbarHidden = false // 10.获取 UINavigationController 的 toolbar let toolbar = self.navigationController?.toolbar println(toolbar) // 11.设置 UINavigationController 的代理对象 self.navigationController?.delegate = self // 12.获取 UINavigationController 的手势识别顶部视图控制器 let pop = self.navigationController?.interactivePopGestureRecognizer println(pop) // 13.设置 UINavigationController 当键盘出现时是否隐藏导航栏和工具栏 self.navigationController!.hidesBarsWhenKeyboardAppears = true // 14.设置 UINavigationController 是否使用向上滑动的手势隐藏导航栏和工具栏 self.navigationController?.hidesBarsOnSwipe = true // 15.获取 UINavigationController 用手势识别隐藏导航栏和工具栏 let barHide = self.navigationController!.barHideOnSwipeGestureRecognizer println(barHide) // 16.设置 UINavigationController 是否在垂直显示时隐藏 self.navigationController!.hidesBarsWhenVerticallyCompact = true // 17.设置 UINavigationController 是否使用点击手势来隐藏 self.navigationController?.hidesBarsOnTap = true // 18.获取 UINavigationController 隐藏时所使用的手势 let barHideOnTap = self.navigationController!.barHideOnTapGestureRecognizer println(barHideOnTap) // 19.设置 UINavigationController 的导航栏是否隐藏, 是否使用动画 self.navigationController?.setNavigationBarHidden(true, animated: true) // 20.设置 UINavigationController 的工具栏是否隐藏, 是否使用动画 self.navigationController?.setToolbarHidden(true, animated: true) &#125; 自定义代理方法以及监听方法// 1.该方法使用来设置 UINavigationController 将要显示时所调用的方法 func navigationController(navigationController: UINavigationController, willShowViewController viewController: UIViewController, animated: Bool) &#123; println("UINavigationController 将要显示") &#125; // 2.该方法使用来设置 UINavigationController 完全显示时所调用的方法 func navigationController(navigationController: UINavigationController, didShowViewController viewController: UIViewController, animated: Bool) &#123; println("UINavigationController 完全显示") &#125; // 3.返回按钮的监听方法 func backAction() &#123; println("点击了返回") &#125; // 4.下一页按钮的监听方法 func nextAction() &#123; println("点击了下一页") &#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UINavigationController</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UINavigationController</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UINavigationController-简介]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UINavigationController-简介/</url>
    <content type="text"><![CDATA[UINavigationController常用属性 1.获取 UINavigationController 的顶部的视图控制器 var topViewController: UIViewController! &#123; get &#125; 2.获取 UINavigationController 可见的视图控制器 var visibleViewController: UIViewController! &#123; get &#125; 3.设置 UINavigationController 的 viewControllers 对象 var viewControllers: [AnyObject]! 4.设置 UINavigationController 的导航栏控制器是否隐藏, 默认是 false var navigationBarHidden: Bool 5.获取 UINavigationController 的导航栏控制器 var navigationBar: UINavigationBar &#123; get &#125; 6.设置 UINavigationController 的内置工具栏是否可见(默认是 ture) var toolbarHidden: Bool 7.获取 UINavigationController 的 toolbar var toolbar: UIToolbar! &#123; get &#125; 8.设置 UINavigationController 的代理对象 var delegate: UINavigationControllerDelegate? 9.获取 UINavigationController 的手势识别顶部视图控制器 var interactivePopGestureRecognizer: UIGestureRecognizer! &#123; get &#125; 10.设置 UINavigationController 当键盘出现时是否隐藏导航栏和工具栏 var hidesBarsWhenKeyboardAppears: Bool 11.设置 UINavigationController 是否使用向上滑动的手势隐藏导航栏和工具栏 var hidesBarsOnSwipe: Bool 12.获取 UINavigationController 用手势识别隐藏导航栏和工具栏 var barHideOnSwipeGestureRecognizer: UIPanGestureRecognizer &#123; get &#125; 13.设置 UINavigationController 是否在垂直显示时隐藏 var hidesBarsWhenVerticallyCompact: Bool 14.设置 UINavigationController 是否使用点击手势来隐藏 var hidesBarsOnTap: Bool 15.获取 UINavigationController 隐藏时所使用的手势 var barHideOnTapGestureRecognizer: UITapGestureRecognizer &#123; get &#125; UINavigationController常用的方法 1.该方法是用来设置 UINavigationController 跳转到指定的视图控制器, 是否使用动画 func pushViewController(viewController: UIViewController, animated: Bool) 2.该方法是用来设置 UINavigationController Pop到其他视图控制器时是否使用动画, 并且返回的类型必须是 UIViewController func popViewControllerAnimated(animated: Bool) -&gt; UIViewController? 3.该方法是用来设置 UINavigationController Pop到指定的视图控制器, 是否使用动画, 返回的类型是任意类型 func popToViewController(viewController: UIViewController, animated: Bool) -&gt; [AnyObject]? 4.该方法是用来设置 UINavigationController Pop到根视图时是否使用动画, 并且返回的类型必须是任意类型 func popToRootViewControllerAnimated(animated: Bool) -&gt; [AnyObject]? 5.该方法是用来替换之前于 UINavigationController 绑定的视图控制器, 并且是否使用动画 func setViewControllers(viewControllers: [AnyObject]!, animated: Bool) 6.该方法是用来设置 UINavigationController 的导航栏是否隐藏, 是否使用动画 func setNavigationBarHidden(hidden: Bool, animated: Bool) 7.该方法是用来设置 UINavigationController 的工具栏是否隐藏, 是否使用动画 func setToolbarHidden(hidden: Bool, animated: Bool) 8.该方法是用来设置 UINavigationController 显示指定的 ViewController func showViewController(vc: UIViewController, sender: AnyObject!) UINavigationController代理方法 1.该方法使用来设置 UINavigationController 将要显示时所调用的方法 optional func navigationController(navigationController: UINavigationController, willShowViewController viewController: UIViewController, animated: Bool) 2.该方法使用来设置 UINavigationController 完全显示时所调用的方法 optional func navigationController(navigationController: UINavigationController, didShowViewController viewController: UIViewController, animated: Bool)]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UINavigationController</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UINavigationController</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UISegmentedControl-简单使用]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UISegmentedControl-简单使用/</url>
    <content type="text"><![CDATA[自定义UISegmentedControfunc mySegmentedControl() &#123; // 1.自定义 UISegemtedControl 并且设置它的 Item 数组对象 var segmented = UISegmentedControl(items: ["分段一", "分段二"]) // 2.设置 UISegemtedControl 的中心点 segmented.center = CGPointMake(self.view.frame.width / 2, self.view.frame.height / 2) // 3.设置 UISegemtedControl 的尺寸 segmented.bounds = CGRectMake(0, 0, 300, 30) // 4.设置 UISegemtedControl 点击之后是否瞬间弹起, (默认是 false) segmented.momentary = true // 5.获取 UISegemtedControl 的分段按钮个数 var number: Int = segmented.numberOfSegments // 6.设置 UISegemtedControl 是否基于内容自动调整尺寸, 默认是 false, 前提是要不设置 UISegemtedControl 的尺寸 segmented.apportionsSegmentWidthsByContent = false // 7.插入一个 UISegemtedControl 的分段按钮, 并且设置标题和索引, 以及是否使用动画 segmented.insertSegmentWithTitle("分段三", atIndex: 2, animated: true) // 8.插入一个 UISegemtedControl 作为分段按钮, 并且设置索引, 以及是否使用动画 segmented.insertSegmentWithImage(UIImage(named: "image_black.jpg")!, atIndex: 3, animated: true) // 9.删除指定索引的 UISegemtedControl 分段按钮, 以及是否使用动画 segmented.removeSegmentAtIndex(1, animated: true) // 10.删除所有 UISegemtedControl 的分段按钮 //segmented.removeAllSegments() // 11.修改 UISegemtedControl 指定的 Item 分段按钮标题 segmented.setTitle("分段四", forSegmentAtIndex: 0) // 12.获取指定的 UISegemtedControl 分段按钮的标题 var title: String = segmented.titleForSegmentAtIndex(0)! println(title) // 13.修改 UISegemtedControl 指定的 Item 分段按钮图片 segmented.setImage(UIImage(named: "image_black.jpg")!, forSegmentAtIndex: 2) // 14.获取指定的 UISegemtedControl 分段按钮的图片 var image: UIImage = segmented.imageForSegmentAtIndex(2)! println(image) // 15.设置 UISegemtedControl 指定的 Item 宽度 segmented.setWidth(70, forSegmentAtIndex: 0) // 16.获取指定 UISegemtedControl 分段按钮的宽度 var width: CGFloat = segmented.widthForSegmentAtIndex(0) println(width) // 17.设置 UISegemtedControl 指定的 Item 内容偏移量 segmented.setContentOffset(CGSizeMake(5, 5), forSegmentAtIndex: 0) // 18.获取指定 UISegemtedControl 指定的 Item 内容偏移量 var size: CGSize = segmented.contentOffsetForSegmentAtIndex(0) println(size) // 19.设置 UISegemtedControl 指定的 Item 是否可以点击 segmented.setEnabled(true, forSegmentAtIndex: 0) // 20.获取指定 UISegemtedControl 指定的 Item 是否可以点击 var bool: Bool = segmented.isEnabledForSegmentAtIndex(0) println(bool) // 21.获取 UISegemtedControl 可点击的 Item 数量 var selected: Int = segmented.selectedSegmentIndex println(selected) // 22.设置 UISegemtedControl 的样式颜色 segmented.tintColor = UIColor.redColor() // 23.设置 UISegemtedControl 的背景图片, 并且在 UISegemtedControl 指定的样式下才会显示, 以及图片显示的样式 segmented.setBackgroundImage(UIImage(named: "image_black.jpg"), forState: UIControlState.Normal, barMetrics: UIBarMetrics.Default) // 24.获取 UISegemtedControl 在指定的状态, 图片显示下的图片 var backgroundImage: UIImage = segmented.backgroundImageForState(UIControlState.Normal, barMetrics: UIBarMetrics.Default)! println(backgroundImage) // 25.设置 UISegemtedControl 的左右的分隔符图片, 并且在 UISegemtedControl 指定的样式下才会显示, 以及图片显示的样式 segmented.setDividerImage(UIImage(named: "image_divider"), forLeftSegmentState: UIControlState.Normal, rightSegmentState: UIControlState.Normal, barMetrics: UIBarMetrics.Default) // 26.获取 UISegemtedControl 的左右的分隔符图片, 并且在 UISegemtedControl 指定的样式下才会显示, 以及图片显示的样式 var divider: UIImage = segmented.dividerImageForLeftSegmentState(UIControlState.Normal, rightSegmentState: UIControlState.Normal, barMetrics: UIBarMetrics.Default)! println(divider) // 27.添加 UISegemtedControl 的监听方法 segmented.addTarget(self, action: "didClicksegmentedControlAction:", forControlEvents: UIControlEvents.ValueChanged) // 添加到 self.view self.view.addSubview(segmented) &#125; UISegemtedControl的监听方法func didClicksegmentedControlAction(segmented: UISegmentedControl!) &#123; var index = segmented.selectedSegmentIndex if index == 0 &#123; println("分段按钮一") &#125; else if index == 1 &#123; println("分段按钮二") &#125; else if index == 2 &#123; println("分段按钮三") &#125; &#125; 在 viewDidLoad 中实现 override func viewDidLoad() &#123; super.viewDidLoad() self.mySegmentedControl()&#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UISegmentedControl</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UISegmentedControl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UISegmentedControl-简介]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UISegmentedControl-简介/</url>
    <content type="text"><![CDATA[UISegemtedControl的常用属性 1.初始化时设置 UISegemtedControl 的 Item 数组 init(items: [AnyObject]) 2.设置 UISegemtedControl 点击之后是否瞬间弹起, (默认是 false) var momentary: Bool 3.获取 UISegemtedControl 里有的分段按钮个数 var numberOfSegments: Int &#123; get &#125; 4.设置 UISegemtedControl 是否基于内容自动调整尺寸, 默认是 false, 前提是要不设置 UISegemtedControl 的尺寸 var apportionsSegmentWidthsByContent: Bool 5.获取 UISegemtedControl 可点击的 Item 数量 var selectedSegmentIndex: Int 6.设置 UISegemtedControl 的样式颜色 var tintColor: UIColor! UISegemtedControl的常用方法 1.插入一个 UISegemtedControl 的分段按钮, 并且设置标题和索引, 以及是否使用动画 func insertSegmentWithTitle(title: String!, atIndex segment: Int, animated: Bool) 2.插入一个 UISegemtedControl 作为分段按钮, 并且设置索引, 以及是否使用动画 func insertSegmentWithImage(image: UIImage, atIndex segment: Int, animated: Bool) 3.删除指定索引的 UISegemtedControl 分段按钮, 以及是否使用动画 func removeSegmentAtIndex(segment: Int, animated: Bool) 4.删除所有 UISegemtedControl 的分段按钮 func removeAllSegments() 3.修改 UISegemtedControl 指定的 Item 分段按钮标题 func setTitle(title: String?, forSegmentAtIndex segment: Int) 4.获取指定的 UISegemtedControl 分段按钮的标题 func titleForSegmentAtIndex(segment: Int) -&gt; String? 5.修改 UISegemtedControl 指定的 Item 分段按钮图片 func setImage(image: UIImage?, forSegmentAtIndex segment: Int) 6.获取指定的 UISegemtedControl 分段按钮的图片 func imageForSegmentAtIndex(segment: Int) -&gt; UIImage? 7.设置 UISegemtedControl 指定的 Item 宽度 func setWidth(width: CGFloat, forSegmentAtIndex segment: Int) 8.获取指定 UISegemtedControl 分段按钮的宽度 func widthForSegmentAtIndex(segment: Int) -&gt; CGFloat 9.设置 UISegemtedControl 指定的 Item 内容偏移量 func setContentOffset(offset: CGSize, forSegmentAtIndex segment: Int) 10.获取指定 UISegemtedControl 指定的 Item 内容偏移量 func contentOffsetForSegmentAtIndex(segment: Int) -&gt; CGSize 11.设置 UISegemtedControl 指定的 Item 是否可以点击 func setEnabled(enabled: Bool, forSegmentAtIndex segment: Int) 12.获取指定 UISegemtedControl 指定的 Item 是否可以点击 func isEnabledForSegmentAtIndex(segment: Int) -&gt; Bool 13.设置 UISegemtedControl 的背景图片, 并且在 UISegemtedControl 指定的样式下才会显示, 以及图片显示的样式 func setBackgroundImage(backgroundImage: UIImage?, forState state: UIControlState, barMetrics: UIBarMetrics) 14.获取 UISegemtedControl 在指定的状态, 图片显示下的图片 func backgroundImageForState(state: UIControlState, barMetrics: UIBarMetrics) -&gt; UIImage? 15.设置 UISegemtedControl 的左右的分隔符图片, 并且在 UISegemtedControl 指定的样式下才会显示, 以及图片显示的样式 func setDividerImage(dividerImage: UIImage?, forLeftSegmentState leftState: UIControlState, rightSegmentState rightState: UIControlState, barMetrics: UIBarMetrics) 16.获取 UISegemtedControl 的左右的分隔符图片, 并且在 UISegemtedControl 指定的样式下才会显示, 以及图片显示的样式 func dividerImageForLeftSegmentState(leftState: UIControlState, rightSegmentState rightState: UIControlState, barMetrics: UIBarMetrics) -&gt; UIImage?]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UISegmentedControl</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UISegmentedControl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UISwitch-简单使用]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UISwitch-简单使用/</url>
    <content type="text"><![CDATA[自定义UISwitch UISwitch 是继承于 UIControl, 所以 UIControl 里面的属性和方法 UISwitch 都是可以用的 func mySwitch() &#123; // 1.自定义 UISwitch var switchButton = UISwitch() // 2.设置 UISwitch 的位置 switchButton.center = CGPointMake(self.view.frame.width / 2, self.view.frame.height / 2) // 3.设置 UISwitch 打开时底图渐变颜色, 默认是从白变绿 switchButton.onTintColor = UIColor.redColor() // 4.设置 UISwitch 关闭时底图渐变颜色, 默认是从绿变白 switchButton.tintColor = UIColor.blackColor() // 5.设置 UISwitch 的小圆点颜色, 默认是白色 switchButton.thumbTintColor = UIColor.blueColor() // 6.设置 UISwitch 是否打开 switchButton.on = true // 7.设置 UISwitch 是否打开, 并且是否打开动画效果 switchButton.setOn(true, animated: true) // 8.添加到 UISwitch 到 self.view self.view.addSubview(switchButton) &#125; 在 viewDidLoad中实现 override func viewDidLoad() &#123; super.viewDidLoad() self.mySwitch()&#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UISwitch</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UISwitch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UISwitch-简介]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UISwitch-简介/</url>
    <content type="text"><![CDATA[UISwitch的常用属性 1.设置 UISwitch 打开时底图渐变颜色, 默认是从白变绿 var onTintColor: UIColor! 2.设置 UISwitch 关闭时底图渐变颜色, 默认是从白变绿 var tintColor: UIColor? 3.设置 UISwitch 的小圆点颜色, 默认是白色 var thumbTintColor: UIColor? 4.设置 UISwitch 是否打开 var on: Bool 5.设置 UISwitch 的位置 init(frame: CGRect) 6.设置 UISwitch 是否打开, 并且是否打开动画效果 func setOn(on: Bool, animated: Bool)]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UISwitch</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UISwitch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UITextField-简单使用]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UITextField-简单使用/</url>
    <content type="text"><![CDATA[遵守代理协议class ViewController: UIViewController, UITextFieldDelegate &#123;&#125; 添加UITextFieldfunc myTextField() &#123; // 1.创建UITextField, 并且设置它的Frame textField.frame = CGRectMake(100, 200, 200, 100) // 2.设置UITextField的背景颜色 textField.backgroundColor = UIColor.greenColor() // 3.设置UITextField的显示样式 textField.borderStyle = UITextBorderStyle.RoundedRect // 4.设置UITextField的编辑状态, 默认是永远不打开, 这里设置的是在编辑时才打开 textField.clearButtonMode = UITextFieldViewMode.WhileEditing // 5.设置UITextField的键盘样式 textField.keyboardType = UIKeyboardType.ASCIICapable // 6.设置UITextField的首字母是否大写 textField.autocapitalizationType = UITextAutocapitalizationType.Sentences // 7.设置UITextField的键盘外观颜色 textField.keyboardAppearance = UIKeyboardAppearance.Dark // 8.设置UITextField的return样式 textField.returnKeyType = UIReturnKeyType.Default // 9.设置UITextField预输入的文字 textField.attributedText = NSAttributedString(string: "ABCDEFG") // 10.设置UITextField的提示文字 textField.placeholder = "请输入您的名字" // 11.设置UITextField的代理对象 textField.delegate = self // 12.设置UITextField内容的垂直对齐方式, 默认是center textField.contentVerticalAlignment = UIControlContentVerticalAlignment.Top // 13.再次编辑时对旧内容进行自动清除, 默认是false textField.clearsOnBeginEditing = true // 14.根据TextField的大小自动缩放字体大小, 默认是false textField.adjustsFontSizeToFitWidth = true // 15.添加到父视图 self.view.addSubview(textField) &#125; 实现代理方法func textFieldShouldReturn(textField: UITextField) -&gt; Bool &#123; // 取消第一响应者 textField.resignFirstResponder() // 返回true return true &#125; 在ViewDidload实现 UITExtField不会自动换行的, 所以我们只可能限制用户所输入多少个字符, 如果需要自动换行, 那就需要去了解UITextVIew override func viewDidLoad() &#123; super.viewDidLoad() self.myTextField() &#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UITextField</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UITextField</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UITxtxField-简介]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UITxtxField-简介/</url>
    <content type="text"><![CDATA[UITxtxField的常用状态TextField边框的样式 enum UITextBorderStyle : Int &#123; case None // TextField边框什么都没有, 默认是方角 case Line // TextField边框有一条黑色的实现围着, 默认也是方角的 case Bezel // TextField边框有两条线围着, 形成一定的层次感, 默认也是方角的 case RoundedRect // TextField边框什么都没有, 默认是圆角&#125; TextField的快速删除状态 enum UITextFieldViewMode : Int &#123; case Never // 永远都不打开 case WhileEditing // 在编辑的状态才打开 case UnlessEditing // 在非编辑的状态才打开 case Always // 一直打开&#125; TextField的键盘样式 enum UIKeyboardType : Int &#123; case Default // 显示默认的键盘 case ASCIICapable // 显示所有ASCII表的所有字符 case NumbersAndPunctuation // 数字和标点符号的键盘 case URL // 输入网站所使用的键盘 case NumberPad // 纯数字键盘 case PhonePad // 为了方便输入手机号码所使用的键盘 case NamePhonePad // 为了方便输入名字和电话号码所使用的键盘 case EmailAddress // 面向邮箱所使用的键盘 case DecimalPad // 面向带小数点的数字键盘 case Twitter // 面向Twitter等社交所使用的键盘, 为了方便@和# case WebSearch // 面向网站所使用的键盘&#125; TextField的大写样式 enum UITextAutocapitalizationType : Int &#123; case None // 不自动大写 case Words // 单个单词首字母大写 case Sentences // 句子首字母大写 case AllCharacters // 全部大写&#125; TextField的键盘外观颜色 enum UIKeyboardAppearance : Int &#123; case Default // 默认是光亮的 case Dark // 设置为黑暗颜色 case Light // 设置为光亮的颜色&#125; TextField的Return样式 enum UIReturnKeyType : Int &#123; case Default // 模样的样式 case Go // 标着有Go的蓝色样式 case Google // 标着Google的蓝色样式, 用于语音搜索, 显示的样式是Search case Join // 标有Join的蓝色按钮 case Next // 标着有Next的蓝色按钮 case Route // 标着有Route的蓝色按钮 case Search // 标着有Search的蓝色按钮 case Send // 标着有Send的蓝色按钮 case Yahoo // 标着有Yahoo的蓝色按钮, 显示的样式是Search case Done // 标着有Done的蓝色按钮 case EmergencyCall // 标着有EmergencyCall的蓝色按钮, 紧急呼救的按钮&#125; TextField的右边显示图样式 enum UITextFieldViewMode : Int &#123; case Never // 永远不显示 case WhileEditing // 在编辑的情况下显示 case UnlessEditing // 在非编辑的情况下显示 case Always // 永远显示&#125; UITextField的垂直排列方式 enum UIControlContentVerticalAlignment : Int &#123; case Center // 居中对齐, 默认 case Top // 顶部对齐 case Bottom // 底部对齐 case Fill // 平铺整个TextField的高度&#125; UITextField的水平排列方式 enum UIControlContentHorizontalAlignment : Int &#123; case Center // 居中对齐 case Left // 左对齐, 默认 case Right // 右对齐 case Fill // 平铺整个TextField的宽度&#125; UITextField的常用属性 字体颜色, 默认的字体颜色是黑色 var textColor: UIColor! 字体大小, 默认的字体大小是12 var font: UIFont!``` &gt;字体对齐方式, 默认是向左对齐```swift var textAlignment: NSTextAlignment 边框的样式, 默认是None. var borderStyle: UITextBorderStyle 快捷清楚的按钮, 默认是不打开的 var clearButtonMode: UITextFieldViewMode 提示文本, 默认是nil, 字体颜色是70%的灰 var placeholder: String? 再次编辑时对旧内容进行自动清除, 默认是false var clearsOnBeginEditing: Bool 根据TextField的大小自动缩放字体大小, 默认是false var adjustsFontSizeToFitWidth: Bool 常用代理方法 点击return会结束编辑, 也可以在这里设置取消TextField的第一响应者, 使键盘隐藏 optional func textFieldShouldReturn(textField: UITextField) -&gt; Bool 可限制文字输入的长度以及特定的字符, 如果返回true, 那么就是可以修改, 如果返回false就不可修改 optional func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -&gt; Bool]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UITxtxField</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UITxtxField</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UIImage-简单使用]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UIImage-简单使用/</url>
    <content type="text"><![CDATA[创建func myImage() &#123; // 1.创建一个UIImageView, 并且设置它的frame var myImageView = UIImageView(frame: CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)) // 2.设置UIImage的图片名, 以及展示的样式 var myImage = UIImage(named: "image_bate.jpg")?.imageWithRenderingMode(UIImageRenderingMode.Automatic) // 3.把UIImage添加到ImageView里面去 myImageView.image = myImage self.view.addSubview(myImageView) &#125; 在viewDidload中实现: override func viewDidLoad() &#123; super.viewDidLoad() self.myImage() &#125; 注意 由于UIImage不能单独的拿出来展示, 它必须依赖于某个一个继承于UIView的一个View, 比如UIImageView或者UIButton, 这些都是可以的]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UIImage</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UIImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UIImage-简介]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UIImage-简介/</url>
    <content type="text"><![CDATA[UIImage的状态 UIImageOrientation enum UIImageOrientation : Int &#123; case Up //默认方向 case Down //180°旋转 case Left //逆时针旋转90° case Right //顺时针旋转90° case UpMirrored //水平向上翻转 case DownMirrored //水平向下翻转 case LeftMirrored //逆时针旋转90°后再垂直翻转 case RightMirrored //顺时针旋转90°后再垂直翻转&#125; UIImageResizingMode enum UIImageResizingMode : Int &#123; case Tile //平铺到调整完位置的图像 case Stretch //拉伸到调整完位置的图像&#125; UIImageRenderingMode enum UIImageRenderingMode : Int &#123; case Automatic //默认上下文显示的图像位置 case AlwaysOriginal //总是以图片为模板 case AlwaysTemplate //会把图像作为绘画的模板, 忽略其他颜色&#125; 常用的属性 UIImage里面虽然有很多属性, 但唯一常用的属性就只有设置获取image名字的属性. init?(named name: String) -&gt; UIImage]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UIImage</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UIImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UITableViewCell-简单使用]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UITableViewCell-简单使用/</url>
    <content type="text"><![CDATA[UITableViewCell-简单使用 由于 TableViewCell 是不可以单独存在的, 所以必须得依赖于 UITableView 遵守 TableView 代理协议以及数据源协议 class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate &#123;&#125; 自定义 TableVIewfunc myTableView() &#123; var tableView = UITableView(frame: self.view.frame, style: UITableViewStyle.Plain) tableView.dataSource = self tableView.delegate = self self.view.addSubview(tableView) &#125; 实现数据源方法func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123; return 1 &#125; func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 5 &#125; 自定义 UITableViewCellfunc tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; // 1.自定义 UITableViewCell 的样式以及标签, reuseIdentifier 是 Cell 得标签, 作用和 Tag 类似 var cell = UITableViewCell(style: UITableViewCellStyle.Value1, reuseIdentifier: "cell") // 2.设置 UITableViewCell 的标题Label cell.textLabel!.text = "我是 Cell" // 3.设置 UITableViewCell 的简介Label cell.detailTextLabel?.text = "Cell" // 4.设置 UITableViewCell 的 imageView 图片 cell.imageView?.image = UIImage(named: "image_black.jpg") // 5.设置 UITableViewCell 的编辑模式是否开启, 以及是否执行动画效果 cell.setEditing(true, animated: true) // 6.设置 UITableViewCell 的背景色 cell.backgroundColor = UIColor.greenColor() // 7.设置 UITableViewCell 的编辑模式辅助按钮 cell.editingAccessoryType = UITableViewCellAccessoryType.DisclosureIndicator // 8.设置 UITableViewCell 被选中的样式 cell.selectionStyle = UITableViewCellSelectionStyle.Default // 9.设置 UITableViewCell 分割线的位置 cell.separatorInset = UIEdgeInsetsMake(0, 0, 0, 20) // 10.设置 UITableViewCell 被选中时的背景View cell.selectedBackgroundView = nil // 11.设置 UITableViewCell 的辅助按钮样式 cell.accessoryType = UITableViewCellAccessoryType.DisclosureIndicator // 返回自定的 Cell return cell &#125; 开启 TableViewCell 的编辑模式 func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) &#123; &#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UITableViewCell</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UITableViewCell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UITableViewCell]]></title>
<url>../../../../../../../../2017/12/14/Swift-UIKit/Swift-UIKit-UITableViewCell-简介/</url>
    <content type="text"><![CDATA[常用属性UITableViewCell 显示的样式 enum UITableViewCellStyle : Int &#123; case Default // 默认显示样式 case Value1 // 样式一 case Value2 // 样式二 case Subtitle // 副标题样式&#125; UITableViewCell 选中的样式 enum UITableViewCellEditingStyle : Int &#123; case None // 没有 case Delete // 删除 case Insert // 添加&#125; UITableViewCell 辅助按钮的样式 enum UITableViewCellAccessoryType : Int &#123; case None // 没有按钮 case DisclosureIndicator // 蓝色向右的箭头 case DetailDisclosureButton // 蓝色向右的箭头以及信息按钮 case Checkmark // 复选框 @availability(iOS, introduced=7.0) case DetailButton // 信息按钮&#125; UITableViewCell 常用属性 1.初始化 Cell 的 Style 以及标签名 init(style: UITableViewCellStyle, reuseIdentifier: String?) 2.设置 Cell 的 ImageView 内容 var imageView: UIImageView? &#123; get &#125; 3.设置 Cell 的 textLabel 的内容 var textLabel: UILabel? &#123; get &#125; 4.设置 Cell 的 副标题内容 var detailTextLabel: UILabel? &#123; get &#125; 5.设置 Cell 的内容 View var contentView: UIView &#123; get &#125; 6.设置 Cell 的背景 View var backgroundView: UIView? 7.设置 Cell 被选中时的背景 View var selectedBackgroundView: UIView! 8.设置 Cell 多选中得背景 View var multipleSelectionBackgroundView: UIView? 9.设置 Cell 被选中时的 Style var selectionStyle: UITableViewCellSelectionStyle 10.设置 Cell 编辑的 Style var editingStyle: UITableViewCellEditingStyle &#123; get &#125; 11.设置 Cell 是否开启编辑状态 var editing: Bool 12.设置 Cell 的辅助按钮样式 var accessoryType: UITableViewCellAccessoryType]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UITableViewCell</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UITableViewCell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UITableView-简单使用]]></title>
<url>../../../../../../../../2017/12/13/Swift-UIKit/Swift-UIKit-UITableView-简单使用/</url>
    <content type="text"><![CDATA[遵守代理协议和数据源协议class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource &#123;&#125; 自定义 UITableViewfunc myTableView() &#123; // 1.设置 TableView 的 frame 和 style var tableView: UITableView = UITableView(frame: self.view.frame, style: UITableViewStyle.Plain) // 2.设置 TableView 的背景色 tableView.backgroundColor = UIColor(red: 0.0, green: 127.0, blue: 127.0, alpha: 1.0) // 3.设置 TableView 的代理对象 tableView.delegate = self // 4.设置 TableView 的数据源对象 tableView.dataSource = self // 5.设置 TableView 每一行 Cell 的高度 tableView.rowHeight = 44 // 6.设置 TableView 每一行 Cell 页头的行高 tableView.sectionHeaderHeight = 50 // 7.设置 TableView 每一行 Cell 页尾的行高 tableView.sectionFooterHeight = 50 // 8.设置 TableView 每一行 Cell 的估计行高 tableView.estimatedRowHeight = 100 // 9.设置 TableView 每一行 Cell 的页头估计行高 tableView.estimatedSectionHeaderHeight = 50 // 10.设置 TableView 每一行 Cell 的页尾估计行高 tableView.estimatedSectionFooterHeight = 50 // 11.设置 TableView 每一行 Cell 之间分割线位置(分别是: 上, 左, 下, 右) tableView.separatorInset = UIEdgeInsetsMake(0, 50, 0, 50) // 12.设置 TableView 每一行 Cell 之间分割线的颜色 tableView.separatorColor = UIColor.redColor() // 13.设置 TableView 每一行 Cell 之间的分割效果(暂无方法, 目前只是用来实例化) tableView.separatorEffect = UIVisualEffect() // 14.设置 TableView 每一行 Cell 之间的分割线样式(默认是 SingleLine 样式) tableView.separatorStyle = UITableViewCellSeparatorStyle.SingleLine // 15.设置 TableView 的背景 View 对象 tableView.backgroundView = UIView() // 16.设置 TableView 的编辑模式是否开启, 并且是否使用动画效果 tableView.setEditing(true, animated: true) // 17.添加到 self.view 上 self.view.addSubview(tableView) &#125; 实现代理方法和数据源方法// 1.该方法是用来设置 TableView 有多少组 Cell func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123; return 2 &#125; // 2.该方法是用来设置 TableView 有多少行 Cell func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 2 &#125; // 3.该方法是用来设置 TableView 每一行 Cell 的详细内容 func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cell = UITableViewCell() cell.backgroundColor = UIColor.blueColor() return cell &#125; // 4.该方法是用来设置 TableView 每一行 Cell 的标题内容 func tableView(tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? &#123; return "我是页头" &#125; // 5.该方法是用来设置 TableView 每一行 Cell 的页尾内容 func tableView(tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? &#123; return "我是页尾" &#125; // 6.该方法是用来设置 TableView 每一行 Cell 的高度, 一旦这里设置了, 那么在自定义里的 rowHeight 属性就会被覆盖 func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat &#123; return 100 &#125; // 7.该方法是用来响应 TableVIewCell 被点击的事件 func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) &#123; println("我被点击了") &#125; // 8.该方法是用来设置 TableView 每一行 Cell 的编辑模式, 如果不设置, 默认都是删除 func tableView(tableView: UITableView, editingStyleForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCellEditingStyle &#123; return UITableViewCellEditingStyle.Insert &#125; // 9.该方法是用来设置 Tabelview 的左滑快捷按钮, 只要写了该方法, 默认打开 func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) &#123; &#125; // 10.该方法是用来设置 TabelView 左滑快捷按钮的详细内容以及操作 func tableView(tableView: UITableView, titleForDeleteConfirmationButtonForRowAtIndexPath indexPath: NSIndexPath) -&gt; String! &#123; return "删除" &#125; // 11.该方法是用来设置 TableView 是否可以拖拽到其他行数, 只要写了该方法, 默认打开 func tableView(tableView: UITableView, moveRowAtIndexPath sourceIndexPath: NSIndexPath, toIndexPath destinationIndexPath: NSIndexPath) &#123; &#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UITableView</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UITableView-简介]]></title>
<url>../../../../../../../../2017/12/13/Swift-UIKit/Swift-UIKit-UITableView-简介/</url>
    <content type="text"><![CDATA[UITableview常用属性UITableView 的样式 enum UITableViewStyle : Int &#123; case Plain // 平铺样式 case Grouped // 分组样式&#125; UITableView 添加或者删除 Cell 时的动画 enum UITableViewRowAnimation : Int &#123; case Fade // 淡入淡出 case Right // 从右添加 case Left // 从左添加 case Top // 从上添加 case Bottom // 从底部添加 case None // 没有动画 case Middle // 从中间添加 case Automatic // 随机添加&#125; UITableView 滚动时指定的位置 enum UITableViewScrollPosition : Int &#123; case None // 不指定 case Top // 指定上面 case Middle // 指定中间 case Bottom // 指定底部&#125; UITableView 分割线的样式 enum UITableViewCellSeparatorStyle : Int &#123; case None // 没有分割线 case SingleLine // 单行分割线 case SingleLineEtched // 多行分割线融合&#125; UITableView 属性 1.设置 UITableView 的位置以及Style init(frame: CGRect, style: UITableViewStyle) var style: UITableViewStyle &#123; get &#125; 2.设置数据源对象 unowned(unsafe) var dataSource: UITableViewDataSource? 3.设置代理对象 unowned(unsafe) var delegate: UITableViewDelegate? 4.设置 Cell 的行高 var rowHeight: CGFloat 5.设置 Cell 的标题高度 var sectionHeaderHeight: CGFloat``` &gt; 6.设置 Cell 的页尾高度```swiftvar sectionFooterHeight: CGFloat 7.设置估计的 Cell 的行高 var estimatedRowHeight: CGFloat 8.设置估计的 Cell 的标题行高 var estimatedSectionHeaderHeight: CGFloat 9.设置估计的 Cell 的页尾行高 var estimatedSectionFooterHeight: CGFloat 10.设置 Cell 与 Cell 之间的分割线位置 var separatorInset: UIEdgeInsets 11.设置 UITableView 的背景 View 对象 var backgroundView: UIView? 常用数据源方法 要使用数据源方法(DataSoucre方法), 首先我们需要遵守 UITableView 的数据源方法(UITableViewDataSoucre)协议 1.该方法是用来设置 TableView 有多少行 Cell func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int 2.该方法是用来设置 TableView 每一行 Cell 的详细内容 func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell 3.该方法是用来设置 TableView 有多少组 Cell optional func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int 4.该方法是用来设置每一组 Cell 的标题内容 optional func tableView(tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? 5.该方法是用来设置每一组 Cell 的页尾内容 optional func tableView(tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? 6.该方法使用来设置 TableView 左滑快捷 optional func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) 7.该方法是用来设置 TableView 是否可以拖拽到其他行数, 只要写了该方法, 默认打开 optional func tableView(tableView: UITableView, moveRowAtIndexPath sourceIndexPath: NSIndexPath, toIndexPath destinationIndexPath: NSIndexPath) 常用代理方法 1.该方法是用来设置每一行 Cell 的高度 optional func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat 2.该方法是用来设置 Cell 标题内容的高度(如果该方法使用了, 那么在自定义 TableView 的sectionHeaderHeight属性就会被覆盖) optional func tableView(tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat 3.该方法是用来设置 Cell 页尾内容的高度(如果该方法使用了, 那么在自定义 TableView 的sectionFooterHeight属性就会被覆盖) optional func tableView(tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat 4.该方法是用来设置 TableView 左滑快捷按钮的内容以及详细操作 optional func tableView(tableView: UITableView, titleForDeleteConfirmationButtonForRowAtIndexPath indexPath: NSIndexPath) -&gt; String! 5.该方法是用来设置 TableView 每一行 Cell 的编辑模式, 如果不设置, 默认都是删除 optional func tableView(tableView: UITableView, editingStyleForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCellEditingStyle]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UITableView</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UIScrollView-简单使用]]></title>
<url>../../../../../../../../2017/12/13/Swift-UIKit/Swift-UIKit-UIScrollView-简单使用/</url>
    <content type="text"><![CDATA[实例化UIScrollView, UIImageView, UIImage class ViewController: UIViewController, UIScrollViewDelegate &#123; var scrollView = UIScrollView() var imageView = UIImageView() var imageURL = UIImage()&#125; 设置UIScrollViewfunc myScrollView() &#123; // 1.1设置ScrollView的Frame scrollView.frame = CGRectMake(0, 0, self.view.frame.width, self.view.frame.height) // 1.2设置ScrollView的边距 scrollView.contentInset = UIEdgeInsetsMake(10, 10, 10, 10) // 1.3设置ScrollView的代理 scrollView.delegate = self // 1.4设置ScrollView的最小缩放比例 scrollView.minimumZoomScale = 0.1 // 1.5设置ScrollView的最大缩放比例 scrollView.maximumZoomScale = 1.5 // 1.6添加到父视图 self.view.addSubview(scrollView) &#125; 设置UIImageViewfunc myImageView() &#123; // 2.1设置ImageView的图片 imageURL = UIImage(named: "image_landscape3.jpg")! // 2.2设置添加图片的方法以及对象 self.setImage(imageURL) // 2.3添加到ScrollView上 scrollView.addSubview(imageView) &#125; 设置UIImagefunc setImage (image: UIImage) &#123; // 3.1设置image对象 imageURL = image // 3.2设置imageView的image内容 imageView.image = image // 3.3设置imageView根据image自动调整大小 imageView.sizeToFit() // 3.4设置ScrollView的内容大小为image的大小 scrollView.contentSize = image.size &#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UIScrollView</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UIScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UIScrollView-简介]]></title>
<url>../../../../../../../../2017/12/13/Swift-UIKit/Swift-UIKit-UIScrollView-简介/</url>
    <content type="text"><![CDATA[UIScrollView的常用属性 设置内容的中心点, 默认是0 var contentOffset: CGPoint 设置内容的宽高, 默认是0 var contentSize: CGSize 设置UIScrollView的边距, 默认是0 var contentInset: UIEdgeInsets 设置UIScrollView是否可以翻页, 默认是false var pagingEnabled: Bool 设置UIScrollView是否可用, 默认是true var scrollEnabled: Bool 设置UIScrollView的水平滚动, 默认是true var showsHorizontalScrollIndicator: Bool 设置UIScrollView的垂直滚动, 默认是true var showsVerticalScrollIndicator: Bool 设置UIScrollView滚动条显示的位置, 默认是0 var scrollIndicatorInsets: UIEdgeInsets 设置最小的缩放比例, 默认是1.0 var minimumZoomScale: CGFloat 设置最大的缩放比例, 默认是1.0 var maximumZoomScale: CGFloat 设置点击状态栏就回到ScrollView的最顶部, 默认是true var scrollsToTop: Bool 设置缩放视图时是否有弹簧效果, 默认是true var bouncesZoom: Bool 设置ScrollView是否滚动时是否有弹簧效果, 默认是true var bounces: Bool UIScrollView的常用方法 拖拽视图时调用 optional func scrollViewDidScroll(scrollView: UIScrollView) 刚开始拖拽视图的时候调用 optional func scrollViewWillBeginDragging(scrollView: UIScrollView) 拖拽停止的时候调用 optional func scrollViewDidEndDragging(scrollView: UIScrollView, willDecelerate decelerate: Bool) 当视图滚动速度开始减慢的时候调用 optional func scrollViewWillBeginDecelerating(scrollView: UIScrollView) 当拖拽的视图完全停下来后才调用 optional func scrollViewDidEndDecelerating(scrollView: UIScrollView) 当ScrollView的动画执行完之后才调用 optional func scrollViewDidEndScrollingAnimation(scrollView: UIScrollView) 设置视图的比例放大或者缩小 optional func viewForZoomingInScrollView(scrollView: UIScrollView) -&gt; UIView? 当完成比例放大或者缩小的时候调用 optional func scrollViewDidEndZooming(scrollView: UIScrollView, withView view: UIView!, atScale scale: CGFloat) 是否可以点击状态栏回到最顶部, 默认是true optional func scrollViewShouldScrollToTop(scrollView: UIScrollView) -&gt; Bool 当点击状态栏回到顶部的时候才调用 optional func scrollViewDidScrollToTop(scrollView: UIScrollView)]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UIScrollView</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UIScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UITextView-简单使用]]></title>
<url>../../../../../../../../2017/12/13/Swift-UIKit/Swift-UIKit-UITextView-简单使用/</url>
    <content type="text"><![CDATA[遵守代理协议 class ViewController: UIViewController, UITextViewDelegate &#123;&#125; 自定义UITextViewfunc myTextView() &#123; // 1.自定义 UITextView 以及文本容器的大小 var textView = UITextView(frame: CGRectMake(0, 200, self.view.frame.width, 200)) // 2.设置 UITextView 的文本内容 textView.text = "http://www.baidu.com\nabcdefghijk" // 3.设置 UITextView 的文本颜色 textView.textColor = UIColor.redColor() // 4.设置 UITextView 的文字大小 textView.font = UIFont.systemFontOfSize(30) // 5.设置 UITextView 的文字对齐方式 textView.textAlignment = NSTextAlignment.Center // 6.设置 UITextView 是否可编辑 textView.editable = true // 7.设置 UITextView 是否可以选中 textView.selectable = true // 8.设置 UITextView 的背景颜色 textView.backgroundColor = UIColor.greenColor() // 9.设置 UITextView 的超文本样式 textView.dataDetectorTypes = UIDataDetectorTypes.All // 10.设置 UITextView 的文本长按时是否可以更改为粗体, 斜体或者斜体下划线样式 textView.allowsEditingTextAttributes = true // 11.设置 UITextView 的文本容器边界 textView.textContainerInset = UIEdgeInsetsMake(10, 10, 10, 10) // 12.设置 UITextView 是否点击编辑时把旧内容全选 textView.clearsOnInsertion = true // 13.设置 UITextView 的代理对象 textView.delegate = self // 14.添加到 self.view self.view.addSubview(textView) &#125; 实现代理方法// 1.该方法是用来设置 UITextView 是否可以编辑 func textViewShouldBeginEditing(textView: UITextView) -&gt; Bool &#123; println("正在开始编辑") return true &#125; // 2.该方法是用来设置 UITextView 是否可以结束编辑 func textViewShouldEndEditing(textView: UITextView) -&gt; Bool &#123; println("正在结束编辑") return true &#125; // 3.该方法是用来设置 UITextView 在开始编辑时调用 func textViewDidBeginEditing(textView: UITextView) &#123; println("开始编辑") &#125; // 4.该方法是用来设置 UITextView 在结束编辑时调用 func textViewDidEndEditing(textView: UITextView) &#123; println("结束编辑") &#125; // 5.该方法是用来设置 UITextView 内容是否可更改 func textView(textView: UITextView, shouldChangeTextInRange range: NSRange, replacementText text: String) -&gt; Bool &#123; println("正在更改内容") return true &#125; // 6.该方法是用来设置 UITextView 内容更改后时调用 func textViewDidChange(textView: UITextView) &#123; println("内容已经改变") &#125; // 7.该方法是用来选择需要更改内容的 UITextView func textViewDidChangeSelection(textView: UITextView) &#123; println("已经选择要更改内容的文本框") &#125; 在 viewDidLoad 调用override func viewDidLoad() &#123; super.viewDidLoad() self.myTextView() &#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UITextView</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UITextView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UITextView-简介]]></title>
<url>../../../../../../../../2017/12/13/Swift-UIKit/Swift-UIKit-UITextView-简介/</url>
    <content type="text"><![CDATA[UITextView常用属性 1.设置 UITextView 的文字 var text: String! 2.设置 UITextView 的字体大小 var font: UIFont! 3.设置 UITextView 的字体颜色 var textColor: UIColor! 4.设置 UITextView 的字体排序, 默认是从左往右 var textAlignment: NSTextAlignment 5.设置 UITextView 是否可编辑 var editable: Bool 6.设置 UITextView 是否可以点击 var selectable: Bool 7.设置 UITextView 的超文本样式 var dataDetectorTypes: UIDataDetectorTypes 8.设置 UITextView 在长按下是否可以选择不同的文字样式 var allowsEditingTextAttributes: Bool``` &gt; 9.设置 UITextView 的文本容器边界```swiftvar textContainerInset: UIEdgeInsets 10.设置 UITextView 是否点击编辑时把旧内容全选 var clearsOnInsertion: Bool UITextView 的代理方法 1.该方法是用来设置 UITextView 是否可以编辑 optional func textViewShouldBeginEditing(textView: UITextView) -&gt; Bool 2.该方法是用来设置 UITextView 是否可以结束编辑 optional func textViewShouldEndEditing(textView: UITextView) -&gt; Bool 3.该方法是用来设置 UITextView 在开始编辑时调用 optional func textViewDidBeginEditing(textView: UITextView) 4.该方法是用来设置 UITextView 在结束编辑时调用 optional func textViewDidEndEditing(textView: UITextView) 5.该方法是用来设置 UITextView 内容是否可更改 optional func textView(textView: UITextView, shouldChangeTextInRange range: NSRange, replacementText text: String) -&gt; Bool 6.该方法是用来设置 UITextView 内容更改后时调用 optional func textViewDidChange(textView: UITextView) 7.该方法是用来选择需要更改内容的 UITextView optional func textViewDidChangeSelection(textView: UITextView)]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UITextView</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UITextView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UIActionSheet-简单使用]]></title>
<url>../../../../../../../../2017/12/13/Swift-UIKit/Swift-UIKit-UIActionSheet-简单使用/</url>
    <content type="text"><![CDATA[遵守代理协议class ViewController: UIViewController, UIActionSheetDelegate &#123;&#125; 自定义UIButton并且监听 ActionSheet 方法func myButton() &#123; var button: UIButton = UIButton.buttonWithType(UIButtonType.System) as! UIButton button.frame = CGRectMake(100, 200, 50, 20) button.setTitle("弹窗", forState: UIControlState.Normal) button.backgroundColor = UIColor.redColor() button.addTarget(self, action: "myActionSheet", forControlEvents: UIControlEvents.TouchUpInside) self.view.addSubview(button) &#125; 自定义UIActionSheetfunc myActionSheet() &#123; // 1.自定义 UIActionSheet, 并且设置标题, 代理对象, 以及按钮的标题 var actionSheet = UIActionSheet(title: "UIActionSheet", delegate: self, cancelButtonTitle: "取消", destructiveButtonTitle: "按钮一") // 2.设置 UIActionSheet 的样式 actionSheet.actionSheetStyle = UIActionSheetStyle.Default // 3.设置取消按钮的索引 actionSheet.cancelButtonIndex = 1 // 4.设置destructive的索引值 actionSheet.destructiveButtonIndex = 0 // 5.添加其他按钮的标题 actionSheet.addButtonWithTitle("按钮二") // 6.设置按钮标题的索引 actionSheet.buttonTitleAtIndex(1) // 7.显示到 self.view 上 actionSheet.showInView(self.view) &#125; 实现UIActionSheet代理方法// 1.该方法是在 UIActionSheet 上的按钮被点击时调用的 func actionSheet(actionSheet: UIActionSheet, clickedButtonAtIndex buttonIndex: Int) &#123; println("被点击了") &#125; // 2.该方法是在 UIActionSheet 上的点击了取消按钮时调用的 func actionSheetCancel(actionSheet: UIActionSheet) &#123; println("点击了取消按钮") &#125; // 3.该方法是在 UIActionSheet 完全即将显示的时候调用的 func willPresentActionSheet(actionSheet: UIActionSheet) &#123; println("UIActionSheet即将显示") &#125; // 4.该方法是在 UIActionSheet 完全显示的时候调用的 func didPresentActionSheet(actionSheet: UIActionSheet) &#123; println("UIActionSheet完全显示") &#125; // 5.该方法是在 UIActionSheet 完全即将消失的时候调用的 func actionSheet(actionSheet: UIActionSheet, willDismissWithButtonIndex buttonIndex: Int) &#123; println("UIActionSheet即将消失") &#125; // 6.该方法是在 UIActionSheet 完全消失的时候调用的 func actionSheet(actionSheet: UIActionSheet, didDismissWithButtonIndex buttonIndex: Int) &#123; println("UIActionSheet完全消失") &#125; 在viewDidLoad实现override func viewDidLoad() &#123; super.viewDidLoad() self.myButton() &#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UIActionSheet</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UIActionSheet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UIActionSheet-简介]]></title>
<url>../../../../../../../../2017/12/13/Swift-UIKit/Swift-UIKit-UIActionSheet-简介/</url>
    <content type="text"><![CDATA[UIActionSheet常用属性 1.设置 UIActionSheet 的代理对象 var delegate: UIActionSheetDelegate? 2.设置 UIActionSheet 的标题 var title: String 3.设置 UIActionSheet 的样式 var actionSheetStyle: UIActionSheetStyle 4.读取 UIActionSheet 里有多少个按钮 var numberOfButtons: Int &#123; get &#125; 5.设置 UIActionSheet 取消按钮的索引 var cancelButtonIndex: Int 6.设置其他按钮的索引 var destructiveButtonIndex: Int 7.读取 UIActionSheet 其他按钮的索引值 var firstOtherButtonIndex: Int &#123; get &#125; 8.读取 UIActionSheet 是否可见 var visible: Bool &#123; get &#125; UIActionSheet的常用方法 1.该方法是用来添加 UIActionSheet 的按钮标题 func addButtonWithTitle(title: String) -&gt; Int 2.该方法是用来设置 UIActionSheet 的按钮索引 func buttonTitleAtIndex(buttonIndex: Int) -&gt; String 3.该方法是来用设置 UIActionSheet 显示到 ToolBar func showFromToolbar(view: UIToolbar!) 4.该方法是用来设置 UIActionSheet 显示到 TabBar func showFromTabBar(view: UITabBar!) 5.该方法是用来设置来自 UIBarButtonItem 的 UIActionSheet, 并且是否开启动画效果 func showFromBarButtonItem(item: UIBarButtonItem!, animated: Bool) 6.该方法是用来设置 UIActionSheet 的显示的视图大小, 以及指定视图和是否开启动画效果 func showFromRect(rect: CGRect, inView view: UIView!, animated: Bool) 7.该方法是用来设置 UIActionSheet 显示到哪一个视图 func showInView(view: UIView!) 8.该方法是用来设置 UIActionSheet 消失的按钮索引, 以及是否使用动画 func dismissWithClickedButtonIndex(buttonIndex: Int, animated: Bool) UIActionSheet的代理方法 1.该方法是在 UIActionSheet 上的按钮被点击时调用的 optional func actionSheet(actionSheet: UIActionSheet, clickedButtonAtIndex buttonIndex: Int) 2.该方法是在 UIActionSheet 上的点击了取消按钮时调用的 optional func actionSheetCancel(actionSheet: UIActionSheet) 3.该方法是在 UIActionSheet 完全即将显示的时候调用的 optional func willPresentActionSheet(actionSheet: UIActionSheet) 4.该方法是在 UIActionSheet 完全显示的时候调用的 optional func didPresentActionSheet(actionSheet: UIActionSheet) 5.该方法是在 UIActionSheet 完全即将消失的时候调用的 optional func actionSheet(actionSheet: UIActionSheet, willDismissWithButtonIndex buttonIndex: Int) 6.该方法是在 UIActionSheet 完全消失的时候调用的 optional func actionSheet(actionSheet: UIActionSheet, didDismissWithButtonIndex buttonIndex: Int)]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UIActionSheet</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UIActionSheet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Func-字典模型互转]]></title>
<url>../../../../../../../../2017/12/13/Swift-Func/Swift-Func-字典模型互转/</url>
    <content type="text"><![CDATA[字典–&gt;模型 class User: NSObject &#123; //模型类 var name:String? var icon:String? // print时会调用。相当于java中的 toString()。为了代码整洁下面的模型去了这个计算属性。测试时请下载demo override internal var description: String &#123; return "name: \(name) \n icon:\(icon) \n" &#125;&#125; func func1()&#123; let dict = ["name":"Jack","icon":"lufy.png"] if let user = User.objectWithKeyValues(dict) as? User&#123; print("\(user)") &#125; &#125; 输出： name: Optional("Jack") icon: Optional("lufy.png") 字典–&gt;模型 ：模型中包裹模型 //模型类class Status :NSObject &#123; var text:String? var user:User? //与 1 中的模型相同 var retweetedStatus:Status?&#125; func func2()&#123; let dict = ["text":"Agree!Nice weather!", "user":["name":"Jack","icon":"lufy.png"], "retweetedStatus":["text":"Nice weather!", "user":["name":"Rose","icon":"nami.png"]] ] if let status = Status.objectWithKeyValues(dict) as? Status&#123; print("\(status)") &#125; &#125;输出： text:Optional("Agree!Nice weather!") user:Optional(name: Optional("Jack") icon:Optional("lufy.png")) retweetedStatus:Optional(text:Optional("Nice weather!") user:Optional(name: Optional("Rose")icon:Optional("nami.png")) retweetedStatus:nil) 字典–&gt;模型： 字典中包裹数组， 数组中的元素是 一个模型对应的字典 //模型类， 必须遵守DictModelProtocol协议， 并实现customClassMapping方法。class UserGroup: NSObject,DictModelProtocol &#123; var groupName:String?; //团队名称 var numbers:NSArray? //成员，保存User实例 static func customClassMapping() -&gt; [String: String]?&#123; return ["numbers":"User"]; //指定numbers数组中的元素类型是User &#125;&#125;func func3()&#123; let dict = ["groupName":"Dream Team", "numbers":[["name":"Jack","icon":"lufy.png"], ["name":"Rose","icon":"nami.png"]] ] if let group = UserGroup.objectWithKeyValues(dict)&#123; print("\(group)") &#125;&#125;输出： groupName:Optional("Dream Team") numbers:Optional(( "name: Optional(\"Jack\") \n icon:Optional(\"lufy.png\") \n", "name: Optional(\"Rose\") \n icon:Optional(\"nami.png\") \n" )) 字典–&gt;模型： 将一个字典数组转成模型数组 func func4()&#123; let arrayOfStatus = [["text":"Agree!Nice weather!", "user":["name":"Jack", "icon":"lufy.png" ], "retweetedStatus":["text":"Nice weather!", "user":["name":"Rose", "icon":"nami.png" ] ] ], ["text":"2___Agree!Nice weather!", "user":["name":"2___Jack", "icon":"2___lufy.png" ], "retweetedStatus":["text":"2___Nice weather!", "user":["name":"2___Rose", "icon":"2___nami.png" ] ] ]] if let status = Status.objectArrayWithKeyValuesArray(arrayOfStatus)&#123; for item in status&#123; //打印出数组的元素 print(item) &#125; &#125; &#125;输出： text:Optional("Agree!Nice weather!") user:Optional(name: Optional("Jack")icon:Optional("lufy.png")) retweetedStatus:Optional(text:Optional("Nice weather!") user:Optional(name: Optional("Rose") icon:Optional("nami.png")) retweetedStatus:nil ) text:Optional("2___Agree!Nice weather!") user:Optional(name: Optional("2___Jack")icon:Optional("2___lufy.png")) retweetedStatus:Optional(text:Optional("2___Nice weather!") user:Optional(name: Optional("2___Rose")icon:Optional("2___nami.png")) retweetedStatus:nil ) 模型–&gt;字典 func func5()&#123; let user = User() user.name = "hejunm" user.icon = "my.png" if let dict = user.keyValues&#123; do&#123; //转化为JSON 字符串，打印出来更直观 let data = try NSJSONSerialization.dataWithJSONObject(dict, options: .PrettyPrinted) print(NSString(data: data, encoding: NSUTF8StringEncoding)) &#125;catch&#123;&#125; &#125; &#125;输出： Optional(&#123; "icon" : "my.png", "name" : "hejunm"&#125;) 模型–&gt;字典： 模型中还有模型 func func6()&#123; let user = User() user.name = "retweeted user hejunm" user.icon = "my.png" let retweetedStatus = Status(); //转发微博 retweetedStatus.text = "this is retweeted status"; retweetedStatus.user = user let oriUser = User() oriUser.name = "original user" oriUser.icon = "my.png" let oriStatus = Status(); //原微博 oriStatus.text = "this is original status" oriStatus.user = oriUser oriStatus.retweetedStatus = retweetedStatus let dict = oriStatus.keyValues do&#123; //转化为JSON 字符串 var data = try NSJSONSerialization.dataWithJSONObject(dict!, options: .PrettyPrinted) print(NSString(data: data, encoding: NSUTF8StringEncoding)) &#125;catch&#123; &#125;&#125;输出： Optional(&#123; "text" : "this is original status", "user" : &#123; "icon" : "my.png", "name" : "original user" &#125;, "retweetedStatus" : &#123; "text" : "this is retweeted status", "user" : &#123; "icon" : "my.png", "name" : "retweeted user hejunm" &#125; &#125;&#125;) 模型–&gt;字典 ： 模型数组转字典数组 func func7()&#123; let user1 = User() user1.name = "hejunm_1" user1.icon = "my.png_1" let user2 = User() user2.name = "hejunm_2" user2.icon = "my.png_2" let userArray = [user1,user2] as NSArray if let dicts = userArray.keyValuesArray&#123; do&#123; let data = try NSJSONSerialization.dataWithJSONObject(dicts, options: .PrettyPrinted) //转成json字符串 print(NSString(data: data, encoding: NSUTF8StringEncoding)) &#125;catch&#123; &#125; &#125; &#125;输出： Optional([ &#123; "icon" : "my.png_1", "name" : "hejunm_1" &#125;, &#123; "icon" : "my.png_2", "name" : "hejunm_2" &#125;]) 源码 - 字典–&gt;模型 import Foundation/** 当字典中存在数组， 并且数组中保存的值得类型是字典， 那么就需要指定数组中的字典对应的类类型。 这里以键值对的形式保存 eg 字典如下： key: [[key1:value1, key2:value2],[key1:value3, key2:value4],[key1:value5, key2:value6]] key： key值 value: 字典[key1:value1, key2:value2] 对应的模型*/@objc public protocol DictModelProtocol&#123; static func customClassMapping() -&gt; [String: String]?&#125;extension NSObject&#123; //dict: 要进行转换的字典 class func objectWithKeyValues(dict: NSDictionary)-&gt;AnyObject?&#123; if HEFoundation.isClassFromFoundation(self) &#123; print("只有自定义模型类才可以字典转模型") assert(true) return nil &#125; let obj:AnyObject = self.init() var cls:AnyClass = self.classForCoder() //当前类的类型 while("NSObject" != "\(cls)")&#123; var count:UInt32 = 0 let properties = class_copyPropertyList(cls, &amp;count) //获取属性列表 for i in 0..&lt;count&#123; let property = properties[Int(i)] //获取模型中的某一个属性 let propertyType = String.fromCString(property_getAttributes(property))! //属性类型 let propertyKey = String.fromCString(property_getName(property))! //属性名称 if propertyKey == "description"&#123; continue &#125; //description是Foundation中的计算型属性，是实例的描述信息 var value:AnyObject! = dict[propertyKey] //取得字典中的值 if value == nil &#123;continue&#125; let valueType = "\(value.classForCoder)" //字典中保存的值得类型 if valueType == "NSDictionary"&#123; //1，值是字典。 这个字典要对应一个自定义的模型类并且这个类不是Foundation中定义的类型。 let subModelStr:String! = HEFoundation.getType(propertyType) if subModelStr == nil&#123; print("你定义的模型与字典不匹配。 字典中的键\(propertyKey) 对应一个自定义的 模型") assert(true) &#125; if let subModelClass = NSClassFromString(subModelStr)&#123; value = subModelClass.objectWithKeyValues(value as! NSDictionary) //递归 &#125; &#125;else if valueType == "NSArray"&#123; //值是数组。 数组中存放字典。 将字典转换成模型。 如果协议中没有定义映射关系，就不做处理 if self.respondsToSelector("customClassMapping") &#123; if var subModelClassName = cls.customClassMapping()?[propertyKey]&#123; //子模型的类名称 subModelClassName = HEFoundation.bundlePath+"."+subModelClassName if let subModelClass = NSClassFromString(subModelClassName)&#123; value = subModelClass.objectArrayWithKeyValuesArray(value as! NSArray); &#125; &#125; &#125; &#125; obj.setValue(value, forKey: propertyKey) &#125; free(properties) //释放内存 cls = cls.superclass()! //处理父类 &#125; return obj &#125; /** 将字典数组转换成模型数组 array: 要转换的数组, 数组中包含的字典所对应的模型类就是 调用这个类方法的类 当数组中嵌套数组， 内部的数组包含字典，cls就是内部数组中的字典对应的模型 */ class func objectArrayWithKeyValuesArray(array: NSArray)-&gt;NSArray?&#123; if array.count == 0&#123; return nil &#125; var result = [AnyObject]() for item in array&#123; let type = "\(item.classForCoder)" if type == "NSDictionary"&#123; if let model = objectWithKeyValues(item as! NSDictionary)&#123; result.append(model) &#125; &#125;else if type == "NSArray"&#123; if let model = objectArrayWithKeyValuesArray(item as! NSArray)&#123; result.append(model) &#125; &#125;else&#123; result.append(item) &#125; &#125; if result.count==0&#123; return nil &#125;else&#123; return result &#125; &#125;&#125; 源码 - 模型–&gt;字典 import Foundationextension NSObject&#123; var keyValues:[String:AnyObject]?&#123; //获取一个模型对应的字典 get&#123; var result = [String: AnyObject]() //保存结果 var classType:AnyClass = self.classForCoder while("NSObject" != "\(classType)" )&#123; var count:UInt32 = 0 let properties = class_copyPropertyList(classType, &amp;count) for i in 0..&lt;count&#123; let property = properties[Int(i)] let propertyKey = String.fromCString(property_getName(property))! //模型中属性名称 let propertyType = String.fromCString(property_getAttributes(property))! //模型中属性类型 if "description" == propertyKey&#123; continue &#125; //描述，不是属性 let tempValue:AnyObject! = self.valueForKey(propertyKey) if tempValue == nil &#123; continue &#125; if let _ = HEFoundation.getType(propertyType) &#123; //1,自定义的类 result[propertyKey] = tempValue.keyValues &#125;else if (propertyType.containsString("NSArray"))&#123; //2, 数组, 将数组中的模型转成字典 result[propertyKey] = tempValue.keyValuesArray //3， 基本数据 &#125;else&#123; result[propertyKey] = tempValue &#125; &#125; free(properties) classType = classType.superclass()! &#125; if result.count == 0&#123; return nil &#125;else&#123; return result &#125; &#125; &#125;&#125;extension NSArray&#123; //数组的拓展 var keyValuesArray:[AnyObject]?&#123; get&#123; var result = [AnyObject]() for item in self&#123; if !HEFoundation.isClassFromFoundation(item.classForCoder)&#123; //1,自定义的类 let subKeyValues:[String:AnyObject]! = item.keyValues if subKeyValues == nil &#123;continue&#125; result.append(subKeyValues) &#125;else if item.classForCoder == NSArray.classForCoder()&#123; //2, 如果item 是数组 let subKeyValues:[AnyObject]! = item.keyValuesArray if subKeyValues == nil &#123;continue&#125; result.append(subKeyValues) &#125;else&#123; //3, 基本数据类型 result.append(item) &#125; &#125; if result.count == 0&#123; return nil &#125;else&#123; return result &#125; &#125; &#125;&#125; 辅助类 import Foundationclass HEFoundation &#123; static let set = NSSet(array: [ NSURL.classForCoder(), NSDate.classForCoder(), NSValue.classForCoder(), NSData.classForCoder(), NSError.classForCoder(), NSArray.classForCoder(), NSDictionary.classForCoder(), NSString.classForCoder(), NSAttributedString.classForCoder() ]) static let bundlePath = NSBundle.mainBundle().infoDictionary!["CFBundleExecutable"] as! String /*** 判断某个类是否是 Foundation中自带的类 */ class func isClassFromFoundation(c:AnyClass)-&gt;Bool &#123; var result = false if c == NSObject.classForCoder()&#123; result = true &#125;else&#123; set.enumerateObjectsUsingBlock(&#123; (foundation, stop) -&gt; Void in if c.isSubclassOfClass(foundation as! AnyClass) &#123; result = true stop.initialize(true) &#125; &#125;) &#125; return result &#125; /** 很据属性信息， 获得自定义类的 类名*/ /** let propertyType = String.fromCString(property_getAttributes(property))! 获取属性类型 到这个属性的类型是自定义的类时， 会得到下面的格式： T+@+"+..+工程的名字+数字+类名+"+,+其他, 而我们想要的只是类名，所以要修改这个字符串 */ class func getType(var code:String)-&gt;String?&#123; if !code.containsString(bundlePath)&#123; //不是自定义类 return nil &#125; code = code.componentsSeparatedByString("\"")[1] if let range = code.rangeOfString(bundlePath)&#123; code = code.substringFromIndex(range.endIndex) var numStr = "" //类名前面的数字 for c:Character in code.characters&#123; if c &lt;= "9" &amp;&amp; c &gt;= "0"&#123; numStr+=String(c) &#125; &#125; if let numRange = code.rangeOfString(numStr)&#123; code = code.substringFromIndex(numRange.endIndex) &#125; return bundlePath+"."+code &#125; return nil &#125;&#125; 原文]]></content>
      <categories>
        <category>Swift</category>
        <category>Func</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Func</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-AppKit-NSTimer-定时器]]></title>
<url>../../../../../../../../2017/12/13/Swift-UIKit/Swift-UIKit-NSTimer-定时器/</url>
    <content type="text"><![CDATA[NSTimerpublic class NSTimer : NSObject 定时器的作用 在指定的时间执行指定的任务 间隔一段时间执行指定任务 定时器的创建scheduled方式 创建并启动定时器 默认将时钟以NSDefaultRunLoopMode模式添加到运行循环 用户发生交互的时候时钟将暂停 /* public class func scheduledTimerWithTimeInterval(ti: NSTimeInterval, target aTarget: AnyObject, selector aSelector: Selector, userInfo: AnyObject?, repeats yesOrNo: Bool) -&gt; NSTimer 参数： TimeInterval：触发时间，单位秒 target：定时起触发对象 selector：定时器响应方法 userInfo：用户信息 repeats：是否重复执行，YES 每个指定的时间重复执行，NO 只执行一次 */ // 创建并启动定时器 let timer:NSTimer = NSTimer.scheduledTimerWithTimeInterval(2.0, target: self, selector: #selector(YPScrollView.timerChange),2 userInfo: nil, repeats: true) timer方式 创建定时器添加到运行循环 将时钟以指定模式添加到运行循环 /* mode： NSDefaultRunLoopMode: 时钟，网络。 发生用户交互的时候，时钟会被暂停 NSRunLoopCommonModes: 用户交互，响应级别高。 发生用户交互的时候，时钟仍然会触发，如果时钟触发方法非常 耗时，使用此方式时用户操作会造成非常严重的卡顿。 */ // 创建定时器 let timer:NSTimer = NSTimer(timeInterval: 2.0, target: self, selector: #selector(ViewController.updateTimer(_:)), userInfo: nil, repeats: true) // 将定时器添加到运行循环 NSRunLoop.currentRunLoop().addTimer(timer, forMode: NSRunLoopCommonModes) 定时器的启动与关闭 // 启动定时器 timer.fireDate = NSDate.distantFuture() // 暂停定时器 timer.fireDate = NSDate.distantPast() // 关闭定时器，永久关闭定时器 timer.invalidate() 子线程定时器的创建 在子线程创建定时器时，需要手动开启子线程的运行循环 dispatch_async(dispatch_get_global_queue(0, 0)) &#123; // 在子线程创建定时器 /* scheduled 或 timer 方式创建 */ let timer:NSTimer = NSTimer(timeInterval: 2.0, target: self, selector: #selector(ViewController.updateTimer(_:)), userInfo: nil, repeats: true) NSRunLoop.currentRunLoop().addTimer(timer, forMode: NSRunLoopCommonModes) // 启动子线程的运行循环 /* 这句代码就是一个死循环！如果不停止运行循环，不会执行添加到此句之后的任何代码 */ CFRunLoopRun() // 停止子线程运行循环之前，不会执行添加到此处的任何代码 &#125; var num:Int = 0 func updateTimer(timer:NSTimer) &#123; num = num + 1 // 满足条件后，停止当前的运行循环 if (num == 8) &#123; // 停止当前的运行循环 /* 一旦停止了运行循环，后续代码能够执行，执行完毕后，线程被自动销毁 */ CFRunLoopStop(CFRunLoopGetCurrent()) &#125; &#125; 定时任务/ 延时调用 /* 1.5 秒后自动调用 self 的 hideHUD 方法 */ self.performSelector(#selector(NsTimer.hideHUD), withObject: nil, afterDelay: 1.5) // 取消延时调用 NSObject.cancelPreviousPerformRequestsWithTarget(self, selector: #selector(NsTimer.hideHUD), object: nil) / 延时调用 /* 1.5 秒后自动调用 self 的 hideHUD 方法 */ self.performSelector(#selector(NsTimer.hideHUD), withObject: nil, afterDelay: 1.5) // 取消延时调用 NSObject.cancelPreviousPerformRequestsWithTarget(self, selector: #selector(NsTimer.hideHUD), object: nil) / 延时调用 /* 1.5 秒后自动调用 self 的 hideHUD 方法 */ self.performSelector(#selector(NsTimer.hideHUD), withObject: nil, afterDelay: 1.5) // 取消延时调用 NSObject.cancelPreviousPerformRequestsWithTarget(self, selector: #selector(NsTimer.hideHUD), object: nil)]]></content>
      <categories>
        <category>Swift</category>
        <category>AppKit</category>
        <category>NSTimer</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>NSTimer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UICollectionView-简单使用]]></title>
<url>../../../../../../../../2017/12/13/Swift-UIKit/Swift-UIKit-UICollectionView-简单使用/</url>
    <content type="text"><![CDATA[遵守协议 class ViewController: UIViewController, UICollectionViewDataSource, UICollectionViewDelegate, UICollectionViewDelegateFlowLayout &#123; &#125; 自定义UICollectionView func myCollectionView() &#123; // 1.自定义 Item 的FlowLayout let flowLayout = UICollectionViewFlowLayout() // 2.设置 Item 的 Size flowLayout.itemSize = CGSizeMake(90, 120) // 3.设置 Item 的排列方式 flowLayout.scrollDirection = UICollectionViewScrollDirection.Vertical // 4.设置 Item 的四周边距 flowLayout.sectionInset = UIEdgeInsetsMake(20, 20, 20, 20) // 5.设置同一竖中上下相邻的两个 Item 之间的间距 flowLayout.minimumLineSpacing = 20 // 6.设置同一行中相邻的两个 Item 之间的间距 flowLayout.minimumInteritemSpacing = 20 // 7.设置UICollectionView 的页头尺寸 flowLayout.headerReferenceSize = CGSizeMake(100, 50) // 8.设置 UICollectionView 的页尾尺寸 flowLayout.footerReferenceSize = CGSizeMake(100, 50) // 1.自定义 UICollectionView 的位置大小, 以及 Item 的显示样式为 flowLayout var collection = UICollectionView(frame: CGRectMake(0, 64, self.view.frame.width, self.view.frame.height - 64), collectionViewLayout: flowLayout) // 2.设置 UICollectionView 的背景颜色 collection.backgroundColor = UIColor.whiteColor() // 3.设置 UICollectionView 垂直滚动是否滚到 Item 的最底部内容 collection.alwaysBounceVertical = true // 4.设置 UICollectionView 垂直滚动是否滚到 Item 的最右边内容 collection.alwaysBounceHorizontal = true // 5.设置 UICollectionView 的数据源对象 collection.dataSource = self // 6.设置 UICollectionView 的代理对象 collection.delegate = self // 7.设置 UICollectionView 的单元格点击(默认是 true) collection.allowsSelection = true // 8.设置 UICollectionView 的单元格多选(默认是 false) collection.allowsMultipleSelection = false // 9.开启 UICollectionView 的分页显示效果 collection.pagingEnabled = true // 10.注册 UICollectionViewCell collection.registerClass(UICollectionViewCell.self, forCellWithReuseIdentifier: "cell") // 11.添加到 self.view 上 self.view.addSubview(collection) &#125; 自定义UINavigationBar func myNavigationBar() &#123; // 1.自定义 NavigationBar, 设置它的位置大小 var navigationBar = UINavigationBar(frame: CGRectMake(0, 0, self.view.frame.width, 64)) // 2.设置 NavigationBar 的背景色 navigationBar.backgroundColor = UIColor.redColor() // 3.自定义 NavigationItem 设定它的 Title let navigationItem = UINavigationItem(title: "UICollectionView演示") // 4.自定义 UIBarButtonItem 的Title, Style, Target 的对象, 已经监听的方法 let leftButton = UIBarButtonItem(title: "返回", style: UIBarButtonItemStyle.Plain, target: self, action: "back") // 5.设置 Navigation 左边的按钮为 leftButton navigationItem.leftBarButtonItem = leftButton // 6.把 NavigationItem 添加到 NavigationBar navigationBar.pushNavigationItem(navigationItem, animated: true) // 7.添加到到 self.view 上 self.view.addSubview(navigationBar) &#125; // 8.NavigationBar监听方法 func back() &#123; println("点击了返回") &#125; UICollectionView的代理方法, 数据源方法, FlowLayout 方法 // 1.该方法是用来设置返回 CollectionViewCell 的组数 func numberOfSectionsInCollectionView(collectionView: UICollectionView) -&gt; Int &#123; return 1 &#125; // 2.该方法是用来设置返回 CollectionViewCell 的个数 func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return 15 &#125; // 3.该方法是用来设置 CollectionViewCell 的内容 func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell &#123; var collectionCell = collectionView.dequeueReusableCellWithReuseIdentifier("cell", forIndexPath: indexPath) as! UICollectionViewCell collectionCell.backgroundColor = UIColor.redColor() return collectionCell &#125; // 4.该方法是点击了 CollectionViewCell 时调用的监听方法 func collectionView(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath) &#123; println("aaa") &#125; // 5.该方法是用来设置 CollectionViewCell 的大小 func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAtIndexPath indexPath: NSIndexPath) -&gt; CGSize &#123; return CGSizeMake(90, 120) &#125; // 6.该方法是用来设置 CollectionViewCell 四周的边距 func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAtIndex section: Int) -&gt; UIEdgeInsets &#123; return UIEdgeInsetsMake(20, 20, 20, 20) &#125; // 7.该方法是用来设置同一行 CollectionViewCell 之间的间距 func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAtIndex section: Int) -&gt; CGFloat &#123; return 20 &#125; // 8.该方法是用来设置同一列 CollectionViewCell 之间的间距 func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAtIndex section: Int) -&gt; CGFloat &#123; return 20 &#125; // 9.该方法是用来设置 CollectionView 的页头尺寸 func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, referenceSizeForHeaderInSection section: Int) -&gt; CGSize &#123; return CGSizeMake(100, 50) &#125; // 10.该方法是用来设置 CollectionView 的页尾尺寸 func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, referenceSizeForFooterInSection section: Int) -&gt; CGSize &#123; return CGSizeMake(100, 50) &#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UICollectionView</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UICollectionView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UICollectionView-简介]]></title>
<url>../../../../../../../../2017/12/13/Swift-UIKit/Swift-UIKit-UICollectionView-简介/</url>
    <content type="text"><![CDATA[UICollectionView的常用属性 1.设置位置和大小 init(frame: CGRect, collectionViewLayout layout: UICollectionViewLayout) 2.设置子视图的布局方式 var collectionViewLayout: UICollectionViewLayout 3.设置UICollectionView的代理对象 unowned(unsafe) var delegate: UICollectionViewDelegate? 4.设置UICollectionView的数据源对象 unowned(unsafe) var dataSource: UICollectionViewDataSource? 5.设置UICollectionView的背景视图 var backgroundView: UIView? 6.设置 UICollectionView 的 Cell 是否可以点击 var allowsSelection: Bool 7.设置 UICollectionView 的 Cell 是否可以多选 var allowsMultipleSelection: Bool UICollectionViewCell显示的样式 struct UICollectionViewScrollPosition : RawOptionSetType &#123; init(_ rawValue: UInt) init(rawValue: UInt) // 1.没有样式 static var None: UICollectionViewScrollPosition &#123; get &#125; // 2.垂直居中显示 static var CenteredVertically: UICollectionViewScrollPosition &#123; get &#125; // 3.向下显示 static var Bottom: UICollectionViewScrollPosition &#123; get &#125; // 4.向左显示 static var Left: UICollectionViewScrollPosition &#123; get &#125; // 5.水平居中显示 static var CenteredHorizontally: UICollectionViewScrollPosition &#123; get &#125; // 6.向右显示 static var Right: UICollectionViewScrollPosition &#123; get &#125; &#125; UICollectionView常用的方法 1.设置UICollectionView的注册类, 以及标示符 func registerClass(cellClass: AnyClass?, forCellWithReuseIdentifier identifier: String) 2.设置 UICollectionView的注册Nib, 以及标示符 func registerNib(nib: UINib?, forCellWithReuseIdentifier identifier: String) 3.设置 UICollectionView 的注册类, 以及辅助视图名称, 标示符 func registerClass(viewClass: AnyClass?, forSupplementaryViewOfKind elementKind: String, withReuseIdentifier identifier: String) 4.设置 UICollectionView的注册Nib, 以及辅助视图名称, 标示符 func registerNib(nib: UINib?, forSupplementaryViewOfKind kind: String, withReuseIdentifier identifier: String) 5.设置 UICollectionView 可重用的 Cell 以及所以路径 func dequeueReusableCellWithReuseIdentifier(identifier: String, forIndexPath indexPath: NSIndexPath!) -&gt; AnyObject 6.设置 UICollectionView 可重用的的辅视图, 标示符, 以及索引路径 func dequeueReusableSupplementaryViewOfKind(elementKind: String, withReuseIdentifier identifier: String, forIndexPath indexPath: NSIndexPath!) -&gt; AnyObject 7.选择 Item 的索引路径 func indexPathsForSelectedItems() -&gt; [AnyObject] 8.选择 Item 的索引路径, 以及是否使用动画, 显示样式 func selectItemAtIndexPath(indexPath: NSIndexPath?, animated: Bool, scrollPosition: UICollectionViewScrollPosition) 9.取消选择 Item 的索引路径, 以及是否使用动画 func deselectItemAtIndexPath(indexPath: NSIndexPath?, animated: Bool) 10.刷新数据 func reloadData() 11.设置 UICollectionView 的集合视图布局, 及是否使用动画 func setCollectionViewLayout(layout: UICollectionViewLayout, animated: Bool) 12.设置 UICollectionView 的集合视图布局, 及是否使用动画, 以及完成之后的闭包方法 func setCollectionViewLayout(layout: UICollectionViewLayout, animated: Bool, completion: ((Bool) -&gt; Void)!) 13.设置 UICollectionView 显示多少个 Item func numberOfSections() -&gt; Int 14.设置 UICollectionView 显示多少组 Item func numberOfItemsInSection(section: Int) -&gt; Int 15.设置 UICollectionView 滚动到第几个 Item 的索引路径, 以及显示样式和是否启用动画 func scrollToItemAtIndexPath(indexPath: NSIndexPath, atScrollPosition scrollPosition: UICollectionViewScrollPosition, animated: Bool) 16.在 UICollectionView 中插入某个 Item func insertSections(sections: NSIndexSet) 17.在 UICollectionView 中删除某个 Item func deleteSections(sections: NSIndexSet) 18.在 UICollectionView 中刷新某个 Item func reloadSections(sections: NSIndexSet) 19.移动 UICollectionView 中某个 Item 到某个位置 func moveSection(section: Int, toSection newSection: Int) UICollectionView代理方法 1.点击 Item 时调用的方法 optional func collectionView(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath) 2.取消选中 Item 时调用的方法 optional func collectionView(collectionView: UICollectionView, didDeselectItemAtIndexPath indexPath: NSIndexPath) UICollectionView数据源方法 1.设置UICollectionView有多少个Item func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int 2.设置 UICollectionViewCell 所显示的内容, 以及索引路径 func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell 3.设置 UICollectionView 有多少组 Cell optional func numberOfSectionsInCollectionView(collectionView: UICollectionView) -&gt; Int UICollectionView的集视图布局方法 1.该方法是用来设置 UICollectionView 的 Item 尺寸大小 optional func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAtIndexPath indexPath: NSIndexPath) -&gt; CGSize 2.该方法是用来设置 UICollectionView 的 Item 四周的边界 optional func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAtIndex section: Int) -&gt; UIEdgeInsets 3.该方法是用来设置 UICollectionView 的 Item 上下之间的最小间距如果在自定义UICollectionView中实现了该属性, 那么该方法就会覆盖掉原来的属性 optional func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAtIndex section: Int) -&gt; CGFloat 4.该方法是用来设置 UICollectionView 的 Item 左右之间的最小间距(如果在自定义UICollectionView中实现了该属性, 那么该方法就会覆盖掉原来的属性) optional func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAtIndex section: Int) -&gt; CGFloat 5.该方法是用来设置 UICollectionView 的页头尺寸如果在自定义UICollectionView中实现了该属性, 那么该方法就会覆盖掉原来的属性) optional func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, referenceSizeForHeaderInSection section: Int) -&gt; CGSize 6.该方法是用来设置 UIcollectionView 的页尾尺寸(如果在自定义UICollectionView中实现了该属性, 那么该方法就会覆盖掉原来的属性) optional func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, referenceSizeForFooterInSection section: Int) -&gt; CGSize]]></content>
      <categories>
        <category>Swift</category>
        <category>UI</category>
        <category>UICollectionView</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UICollectionView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Network-AFNetworking-网络请求]]></title>
<url>../../../../../../../../2017/12/13/Swift-Network/Swift-Network-AFNetworking-网络请求/</url>
    <content type="text"><![CDATA[创建数据请求类 import UIKit import AFNetworking //请求方法 /// - GET: get /// - POST: post enum RequsetMethod:String &#123; case GET = "GET" case POST = "POST" &#125; class SPFNetWorkManager: AFHTTPSessionManager &#123; //单例 static let sharedTools:SPFNetWorkManager = &#123; let instance = SPFNetWorkManager() instance.responseSerializer.acceptableContentTypes?.insert("text/html") instance.responseSerializer.acceptableContentTypes?.insert("text/plain") return instance &#125;() // 定义请求完成的回调的别名 typealias httptoolBack = (response:AnyObject?,error:NSError?)-&gt;() /// 请求数据 /// /// - parameter urlString: 请求地址 /// - parameter parameters: 请求参数 /// - parameter finished: 请求成功或者失败的回调 func request(method: RequsetMethod = .GET, urlString: String, parameters: AnyObject?, finished:httptoolBack)&#123; // 定义请求成功的闭包 let success = &#123; (dataTask: NSURLSessionDataTask, responseObject: AnyObject?) -&gt; Void in finished(response: responseObject, error: nil) &#125; // 定义请求失败的闭包 let failure = &#123; (dataTask: NSURLSessionDataTask?, error: NSError) -&gt; Void in finished(response: nil, error: error) &#125; if method == .GET &#123; GET(urlString, parameters: parameters, progress: nil, success: success, failure: failure) &#125;else&#123; POST(urlString, parameters: parameters, progress: nil, success: success, failure: failure) &#125; &#125; /// 发送请求(上传文件) func requestWithData(data: NSData, name: String, urlString: String, parameters: AnyObject?, finished:httptoolBack) &#123; // 定义请求成功的闭包 let success = &#123; (dataTask: NSURLSessionDataTask, responseObject: AnyObject?) -&gt; Void in finished(response: responseObject, error: nil) &#125; // 定义请求失败的闭包 let failure = &#123; (dataTask: NSURLSessionDataTask?, error: NSError) -&gt; Void in finished(response: nil, error: error) &#125; POST(urlString, parameters: parameters, constructingBodyWithBlock: &#123; (formData) -&gt; Void in formData.appendPartWithFileData(data, name: name, fileName: "aa", mimeType: "application/octet-stream") &#125;, progress: nil, success: success, failure: failure) &#125; &#125; 调用方法let urlString = "http://192.168.3.7:8080/FreshFun/homepage.do" //创建httpTool 实例 let HttpRequest = SPFNetWorkManager.sharedTools //发送GET请求 HttpRequest.request(RequsetMethod.GET, urlString: urlString, parameters:nil ) &#123; (response, error) in print(response) &#125; 数据Optional(&#123; goodsMoney = "22.00"; "goods_des" = "\U9999\U8549\U8089333"; "goods_img" = "/image/2016/9/8/1473340021432.png"; "goods_name" = BananaMeat; id = 4; marketMoney = "31.43"; &#125;）]]></content>
      <categories>
        <category>Swift</category>
        <category>Network</category>
        <category>AFNetworking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Lib-Kingfisher-图片加载库]]></title>
<url>../../../../../../../../2017/12/13/Swift-Lib/Swift-Lib-Kingfisher-图片加载库/</url>
    <content type="text"><![CDATA[http://blog.csdn.net/djh996064549/article/details/71085679]]></content>
      <categories>
        <category>Swift</category>
        <category>Lib</category>
        <category>Kingfisher</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Lib-SSKeychain-数据本地化方式之一]]></title>
<url>../../../../../../../../2017/12/13/iOS-Lib/iOS-Lib-SSKeychain-数据本地化方式之一/</url>
    <content type="text"><![CDATA[keychain与userdefaults keychain 将数据加密后存储在本地,更安全.路径:Library/Application Support/iPhone Simulator/模拟器版本/Library/Keychains/ 当你删除APP后,keychain存储的数据不会删除 userdefaults 数据以明文的形式保存在.plist文件中.路径:Library/Application Support/iPhone Simulator/模拟器版本/Applications/应用对应的数字/Library/Preference/.plist文件 当你删除APP后,user defaults存储的数据会随着APP而删掉 流程 导入 pod &apos;SSKeychain&apos; 实现 #import &quot;ViewController.h&quot;#import &lt;SSKeychain.h&gt;#import &lt;SSKeychainQuery.h&gt;//应用名称(保证唯一性)#define ServiceName @&quot;com.zx.tec.SSKeychainTest&quot;//账号#define Account @&quot;test2&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [superviewDidLoad]; /** * SSKeychain 是一种本地存储方式不会因为程序卸载而清除 用于存储私密 及唯一 的标示 * * 五个方法:(用到两个) * + (NSArray *)allAccounts; * + (NSArray *)accountsForService:(NSString *)serviceName; * + (NSString *)passwordForService:(NSString *)serviceName account:(NSString *)account; * + (BOOL)deletePasswordForService:(NSString *)serviceName account:(NSString *)account; * + (BOOL)setPassword:(NSString *)password forService:(NSString *)serviceName account:(NSString *)account; */ #pragma mark - 开始使用 SSKeychain //获取uuid(如果想获取唯一标示,存储以 uuid为密码存储 下次登陆直接读取检测是否安装) //CFUUIDRef uuid = CFUUIDCreate(NULL); //assert(uuid != NULL); //CFStringRef uuidStr = CFUUIDCreateString(NULL, uuid); // NSLog(@&quot;%@~~%@&quot;, uuidStr, [NSString stringWithFormat:@&quot;%@&quot;, uuidStr]); /** * + (NSString *)passwordForService:(NSString *)serviceName account:(NSString *)account;//获取指定 serviceName和 account 的密码 * * + (BOOL)setPassword:(NSString *)password forService:(NSString *)serviceName account:(NSString *)account;//存储指定 serviceName和 account 的密码 * */ NSString *passWord = @&quot;123456&quot;; if (![SSKeychainpasswordForService:ServiceNameaccount:Account]) &#123;//查看本地是否存储指定 serviceName和 account 的密码 //如果没设置密码则设定密码 并存储 [SSKeychainsetPassword:passWord forService:ServiceNameaccount:Account]; //打印密码信息 NSString *retrieveuuid = [SSKeychainpasswordForService:ServiceNameaccount:Account]; NSLog(@&quot;SSKeychain存储显示:未安装过:%@&quot;, retrieveuuid); &#125;else&#123; //曾经安装过则直接能打印出密码信息(即使删除了程序再次安装也会打印密码信息) 区别于 NSUSerDefault NSString *retrieveuuid = [SSKeychainpasswordForService:ServiceNameaccount:Account]; NSLog(@&quot;SSKeychain存储显示 :已安装过:%@&quot;, retrieveuuid); &#125;#warning 区别于 NSUSerDefault (删除应用程序后存储的数据就会消失) if (![[NSUserDefaultsstandardUserDefaults]boolForKey:@&quot;TestOne&quot;]) &#123; [[NSUserDefaultsstandardUserDefaults]setBool:YESforKey:@&quot;TestOne&quot;]; NSLog(@&quot;NSUSerDefault存储显示:未安装&quot;); &#125;else&#123; NSLog(@&quot;NSUSerDefault存储显示:安装过&quot;); &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Lib</category>
        <category>SSKeychain</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-Symbolicatecrash分析Crash文件]]></title>
<url>../../../../../../../../2017/12/12/iOS-Func/iOS-Func-Symbolicatecrash分析crash文件/</url>
    <content type="text"><![CDATA[没有集成发送崩溃报告功能导出 所有崩溃记录都会记录在设备上，没有集成让用户发送崩溃报告功能的i，要获得crash文件就必须先连上崩溃过的机器 打开Xcode---&gt;选择Window -&gt; Devices，选择你自己的机器，然后点击View Device Logs，打开小窗口，这是机器上至目前为止存的所有app的崩溃信息了如果是好久没看过这个信息，打开后还要读取好久才能完全读完，总之，找到你的app最后一次崩溃记录，右键导出 导出来的.crash文件，上半部分都是一些基本信息（基本没用），重点看下崩溃部分的记录 找到你上次发布的ipa（如果实在没有了就再从Archives里导出来一个，但一定要保证是你上次发布用的那个），右键 -&gt; 打开方式 -&gt; 归档实用工具(就是解压缩)，然后把Payload文件夹下的.app文件也扔到刚刚的crash文件夹里接下来还需要dSYM文件，还是在Archives里，找到发布用的那个，右键Show in Finder 然后对文件夹中的这个.xcarchive文件右键，显示包内容，就可以看到一个名为dSYMs的文件夹，把里面的.dSYM文件拷出来，还是放到桌面的crash文件夹里 symbolicatecrash是一个隐藏工具 /Applications/Xcode8.1.app/Contents/SharedFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/symbolicatecrash 终端中输入命令搜索： $ find /Applications/Xcode8.1.app -name symbolicatecrash -type f 这个路径拷贝一下，然后粘到Finder的“前往文件夹”下，前往，就可以看到symbolicatecrash工具了，现在把它也拷到桌面的crash文件夹里。至此，crash文件夹里现在有4个文件了，分别是.app, .crash, .dSYM, symbolicatecrash。接下来就是用终端敲命令，生成更易分析的crash 首先用cd命令进入到crash文件夹下，然后输入以下命令 $ ./symbolicatecrash /Users/xxxx/Desktop/crash/InOrder.crash /Users/xxxx/Desktop/crash/InOrder.app.dSYM &gt; Control_symbol.crash 上述命令中，”xxxx”和”InOrder”请自行替换成对应的名称。运行，这时候终端可能会报错Error: “DEVELOPER_DIR” is not defined at /usr/local/bin/symbolicatecrash line 53. 这时候在终端中再输入如下（Xcode6.1.app依然是要替换成实际名称） $ export DEVELOPER_DIR=&quot;/Applications/Xcode8.1.app/Contents/Developer&quot; 然后再跑一下刚刚的那个命令，这时候看一下桌面的crash文件夹下就会多出一个名为“Control_symbol.crash”的文件，这就是可定位问题的crash文件了，我们打开看一下 现在红框里原来的那些乱七八糟的东西已经“翻译”成了崩溃在具体的哪一个.m文件的哪一行。下面就是进行合理的猜想和调试了，比如我的崩溃就是因为这个第三方时间选择控件使用截取字符串的形式来获得时间，像09:23 PM就被固定的拆成了时、分、上下午标识3段，结果用户使用24小时制的时候，时间就成了21:23，没了上下午标识，array[2]超出下标妥妥的闪退。想想我脑洞也是蛮大的，这种问题原因都被猜到了]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
      <tags>
        <tag>Symbolicatecrash</tag>
        <tag>Crash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-AccessControl-open]]></title>
<url>../../../../../../../../2017/12/11/Swift-Grammar/Swift-Grammar-AccessControl-open/</url>
    <content type="text"><![CDATA[open作业 open则是弥补public语义上的不足。现在的pubic有两层含义：①这个元素可以在其他作用域被访问②这个元素可以在其他作用域被继承或者override 继承问题 继承是一件危险的事情尤其对于一个framework或者module的设计者而言在自身的module内，类或者属性对于作者而言是清晰的，能否被继承或者override都是可控的,但是对于使用它的人，作者有时会希望传达出这个类或者属性不应该被继承或者修改。这个对应的就是 final ========================== final 的问题在于在标记之后，在任何地方都不能override而对于lib的设计者而言，希望得到的是在module内可以被override在被import到其他地方后其他用户使用的时候不能被override ========================== 这就是open产生的初衷通过open和public标记区别一个元素在其他module中是只能被访问还是可以被override /// ModuleA:// 这个类在ModuleA的范围外是不能被继承的，只能被访问public class NonSubclassableParentClass &#123; public func foo() &#123;&#125; // 这是错误的写法，因为class已经不能被继承， // 所以他的方法的访问权限不能大于类的访问权限 open func bar() &#123;&#125; // final的含义保持不变 public final func baz() &#123;&#125;&#125;// 在ModuleA的范围外可以被继承open class SubclassableParentClass &#123; // 这个属性在ModuleA的范围外不能被override public var size : Int // 这个方法在ModuleA的范围外不能被override public func foo() &#123;&#125; // 这个方法在任何地方都可以被override open func bar() &#123;&#125; ///final的含义保持不变 public final func baz() &#123;&#125;&#125;/// final的含义保持不变public final class FinalClass &#123; &#125;/// ModuleB:import ModuleA// 这个写法是错误的，编译会失败// 因为NonSubclassableParentClass类访问权限标记的是public，只能被访问不能被继承class SubclassA : NonSubclassableParentClass &#123; &#125;// 这样写法可以通过，因为SubclassableParentClass访问权限为 `open`.class SubclassB : SubclassableParentClass &#123; // 这样写也会编译失败 // 因为这个方法在SubclassableParentClass 中的权限为public，不是`open'. override func foo() &#123; &#125; // 这个方法因为在SubclassableParentClass中标记为open，所以可以这样写 // 这里不需要再声明为open，因为这个类是internal的 override func bar() &#123; &#125;&#125;open class SubclassC : SubclassableParentClass &#123; // 这种写法会编译失败，因为这个类已经标记为open // 这个方法override是一个open的方法，则也需要表明访问权限 override func bar() &#123; &#125; &#125;open class SubclassD : SubclassableParentClass &#123; // 正确的写法，方法也需要标记为open open override func bar() &#123; &#125; &#125;open class SubclassE : SubclassableParentClass &#123; // 也可以显式的指出这个方法不能在被override public final override func bar() &#123; &#125; &#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
        <category>AccessControl</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Grammar</tag>
        <tag>AccessControl</tag>
        <tag>open</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-AccessControl-fileprivate-文件内私有]]></title>
<url>../../../../../../../../2017/12/11/Swift-Grammar/Swift-Grammar-AccessControl-fileprivate-文件内私有/</url>
    <content type="text"><![CDATA[在原有的swift中的 private &lt;其实并不是真正的私有，如果一个变量定义为private，在同一个文件中的其他类依然是可以访问到的这个场景在使用extension的时候很明显 class User &#123; private var name = "private"&#125;extension User&#123; var accessPrivate: String &#123; return name &#125;&#125; 带来了两个问题： 标记为private时，意为真的私有还是文件内可共享呢？ 如果意图为真正的私有时，必须保证这个类或者结构体在一个单独的文件里。否则可能同文件里其他的代码访问到 在swift 3中，新增加了一个 fileprivate 来显式的表明，这个元素的访问权限为文件内私有过去的private对应现在的fileprivate现在的private则是真正的私有，离开了这个类或者结构体的作用域外面就无法访问]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
        <category>AccessControl</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Grammar</tag>
        <tag>AccessControl</tag>
        <tag>fileprivate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-RequiredInit必要初始化器]]></title>
<url>../../../../../../../../2017/12/11/Swift-Grammar/Swift-Grammar-RequiredInit必要初始化器/</url>
    <content type="text"><![CDATA[必要初始化器 重写类的时候经常提示要添加代码 required init?(coder aDecoder: NSCoder) &#123; fatalError("init(coder:) has not been implemented") &#125; 必要初始化器，这种情况一般会出现在继承了遵守NSCoding protocol的类，比如UIView系列的类、UIViewController系列的类 为什么一定要添加 这是NSCoding protocol定义的，遵守了NSCoding protoaol的所有类必须继承只是有的情况会隐式继承，而有的情况下需要显示实现 什么情况下要显示添加： 当我们在子类定义了指定初始化器(包括自定义和重写父类指定初始化器)，那么必须显示实现required init?(coder aDecoder: NSCoder)，而其他情况下则会隐式继承，可不用理会。 什么情况下会调用： 当使用storyboard实现界面的时候，程序会调用这个初始化器。注意要去掉fatalError，fatalError的意思是无条件停止执行并打印。在obj-c中可以通过下面代码实现 NSException *exception = [NSException exceptionWithName:@"HotTeaException" reason:@"The tea is too hot" userInfo:nil]; @throw exception; 举例分析普通子类 通常情况下，一说到required修饰符，最先想到的应该就是普通类（class）的init()方法 class MyClass &#123; var str:String init(str:String) &#123; self.str = str &#125;&#125; 定义一个MyClass的子类（subclass）并实例化这个子类 在实例化MySubClass时，其实是继承了它父类MyClass的init()方法class MySubClass:MyClass &#123; &#125;var MySubClass(str:"Hello Swift") 子类的初始化方法 子类中添加一个init()方法在init()方法前加上override修饰符，表示MySubClass重写了其父类的init()方法，然后还要调用父类的init()方法，并将参数一并传给父类的方法 class MySubClass:MyClass &#123; override init(str:String) &#123; super.init(str:str) &#125; &#125;var MySubClass(str:"Hello Swift" 当子类的初始化方法参数类型与父类的初始化方法参数类型不同时，我们就不必在子类的初始化方法前加override修饰符了，但是要把子类初始化方法的参数类型转换为符合父类初始化方法的参数类型，然后传给父类的初始化方法 lass MyClass &#123; var str:String init(str:String) &#123; self.str = str &#125;&#125;class MySubClass:MyClass&#123; init(i:Int) &#123; super.init(str:String(i)) &#125;&#125;MySubClass(i: 10) 给父类的init()方法加上required修饰符class MyClass &#123; var str:String required init(str:String) &#123; self.str = str &#125;&#125;class MySubClass:MyClass&#123; init(i:Int) &#123; super.init(str:String(i)) &#125; // 编译错误&#125;MySubClass(i: 10) 因为我们没有实现父类中要去必须要实现的方法 class MyClass &#123; var str:String required init(str:String) &#123; self.str = str &#125;&#125;class MySubClass:MyClass&#123; required init(str:String) &#123; super.init(str: str) &#125; init(i:Int) &#123; super.init(str:String(i)) &#125; &#125;MySubClass(i: 10) 子类需要添加异于父类的初始化方法时，必须先要实现父类中使用required修饰符修饰过的初始化方法，并且也要使用required修饰符而不是override如果子类中不需要添加任何初始化方法，我们则可以忽略父类的required初始化方法： class MyClass &#123; var str:String required init(str:String) &#123; self.str = str &#125;&#125;class MySubClass:MyClass&#123; //编译器不会报错，因为如果子类没有任何初始化方法时，Swift会默认使用父类的初始化方法You do not have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initialiser.&#125;MySubClass(str: "hello swift") required修饰符的使用规则 required修饰符只能用于修饰类初始化方法 当子类含有异于父类的初始化方法时（初始化方法参数类型和数量异于父类），子类必须要实现父类的required初始化方法，并且也要使用required修饰符而不是override 当子类没有初始化方法时，可以不用实现父类的required初始化方法 总结： 如果代码实现界面，那么我们只要根据编译器提示添加必要初始化器后，就不用理会，我们创建界面的工作可以在自定义的初始化器里实现。 补充：let vc = UIViewController()方式初始化类UIViewController类视乎只有两个初始化器，一个是必要初始化器init?(coder aDecoder: NSCoder)，一个是指定初始化器init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?)，那么为什么我们可以用let vc = UIViewController()这种方式初始化类呢？原因可能是这个初始化方式是来自uikit,也就是调用了Object-c下的UIViewController初始化方法，是object-c bridge过来的]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
        <category>RequiredInit</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Grammar</tag>
        <tag>RequiredInit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-4.0更新]]></title>
<url>../../../../../../../../2017/12/11/Swift-Grammar/Swift-Grammar-4-0更新/</url>
    <content type="text"><![CDATA[用系统方法setValuesForKeys()赋值问题 (swift4) 在swift3中，编译器自动推断@objc，换句话说，它自动添加@objc在swift4中，编译器不再自动推断，你必须显式添加@objc @objc var content = ""swift 4.0 版本要在前面加@objc 还有一种更简单的方法，不必一个一个属性的添加,下面这种写法 @objcMembersclass Test &#123;&#125; setValuesForKeys()奔溃(swift4) @objc解决了单个属性的问题，一个属性的值是数组字典，用setValuesForKeys() 程序奔溃，xcode9.0.1提示如下 [__NSCFConstantString count]: unrecognized selector sent to instance 0x102cb3290 造成崩溃是因为该字段如果为空 用了空串来占位，造成数据类型不一致而崩溃。这个在swift3中没有问题]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
        <category>Swift4.0</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Grammar</tag>
        <tag>Swift4.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Guard-关键字/守护]]></title>
<url>../../../../../../../../2017/12/11/Swift-Grammar/Swift-Grammar-Guard-关键字-守护/</url>
    <content type="text"><![CDATA[guard语句 guard语句判断其后的表达式布尔值为false时，才会执行之后代码块里的代码，如果为true，则跳过整个guard语句guard语句只会有一个代码块，if语句可以if else多个代码块类似 OC里的Continue func checkup(person: [String: String!]) &#123; // 检查身份证，如果身份证没带，则不能进入考场 guard let id = person["id"] else &#123; print("没有身份证，不能进入考场!") return &#125; // 检查准考证，如果准考证没带，则不能进入考场 guard let examNumber = person["examNumber"] else &#123; print("没有准考证，不能进入考场!") return &#125; // 身份证和准考证齐全，方可进入考场 print("您的身份证号为:\(id)，准考证号为:\(examNumber)。请进入考场!") &#125; checkup(["id": "123456"]) // 没有准考证，不能进入考场!checkup(["examNumber": "654321"]) // 没有身份证，不能进入考场!checkup(["id": "123456", "examNumber": "654321"]) // 您的身份证号为:123456，准考证号为:654321。请进入考场! 上述代码中的第一个guard语句用于检查身份证，如果检查到身份证没带，也就是表达式为false时，执行大括号里的代码，并返回。第二个guard语句则检查准考证。如果两证齐全，则执行最后一个打印语句，上面的两个guard语句大括号内的代码都不会执行，因为他们表达式的布尔值都是true。这里值得注意的是，id和examNumber可以在guard语句之外使用，也就是说当guard对其表达式进行验证后，id和examNumber可在整个方法的作用域中使用，并且是解包后的 if else语句 用if else实现的方法显然不如guard实现的那么精准。而且id和examNumber的作用域只限在if的第一个大括号内，超出这个作用域编译就会报错 func checkupUseIf(person: [String: String!]) &#123; if let id = person["id"], let examNumber = person["examNumber"] &#123; print("您的身份证号为:\(id)，准考证号为:\(examNumber)。请进入考场！") &#125; else &#123; print("证件不齐全，不能进入考场!") &#125; print("您的身份证号为:\(id)，准考证号为:\(examNumber)") // 报异常 &#125; checkupUseIf(["id": "123456"]) // 证件不齐全，不能进入考场!checkupUseIf(["examNumber": "654321"]) // 证件不齐全，不能进入考场!checkupUseIf(["id": "123456", "examNumber": "654321"]) // 您的身份证号为:123456，准考证号为:654321。请进入考场!]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
        <category>Guard</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Grammar</tag>
        <tag>Guard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Inheritance-类继承]]></title>
<url>../../../../../../../../2017/12/10/Swift-Grammar/Swift-Grammar-Inheritance-类继承/</url>
    <content type="text"><![CDATA[Inheritance-类继承-简介 继承性是面向语言特征之一swift的类继承只能发生生在类上，不能发生在枚举和结构体上swift中一个类可以继承另一个类的方法、属性、下标等特征子类 父类（超类）子类继承父类后，可重写父类的方法、属性、下标等单继承，但可遵从多个协议，多重继承可以通过遵从多个协议实现 案例 场景：面向对象的程序员岳克奎，在编程过程中需要描述和处理个人信息定义类Person class Person&#123; var name:String var age :Int func desription()-&gt;String&#123; return "\(name)年龄是：\(age)岁" &#125; init() &#123; name = "" age = 1 &#125; &#125; 场景：1天后岳克奎遇到新需求，需描述和处理学生的信息，于是定义了一个新的类Student class Student&#123; var name:String var age :Int var school: String func desription() -&gt; String &#123; return "\(name)年龄是：\(age)岁" &#125; init() &#123; name = "" age = 1 school = "" &#125;&#125; 继承方式写 class Student:Person&#123; var school: String //子类新增 override init() &#123; //重写父类 构造函数 school = "" // 注意 school 和 super.init() 顺序 super.init() name = "" age = 6 &#125; &#125; 构造函数的调用规则修改上面案例//Person class Person&#123; var name:String var age :Int func desription()-&gt;String&#123; return "\(name)年龄是：\(age)岁" &#125; convenience init () &#123; // ① 便利构造函数 self.init (name: "岳克奎") self.age = 99 &#125; convenience init (name: String) &#123; // ② 便利构造函数 self.init(name:name,age:18) &#125; init(name: String,age: Int) &#123; // ③ 指定构造函数 self.name = name self.age = age &#125; &#125; class Student:Person&#123; var school: String init(name: String, age: Int,school: String ) &#123; // ④ 指定构造函数 self.school = school super.init(name: name, age: age) &#125; convenience override init(name: String, age: Int) &#123; // ⑤ 便利构造函数 self.init (name: name, age: age, school: "许昌学院") &#125; &#125; let oneStudent = Student() print("学生： \(oneStudent.desription())")//学生： 岳克奎年龄是：99岁 构造函数之间的调用形成构造函数链 swift限制构造函数之间代理调用规则3条： 1.指定构造函数必须调用其直接父类的指定构造函数 Student中的 ④ 指定函数调用Person中③ 指定构造函数 2.便利构造函数必须调用同一类中定义的其他构造函数 Student 中的 ⑤ 便利构造函数 调用 同一类中 ④号构造函数，Person中的 ① 便利构造函数调用同一类中的 ② 便利构造函数，Person中的 ② 便利构造函数 调用同一类中的 ③ 指定构造函数 3.便利构造函数必须最终以调用一个指定构造函数结束 Student 中的 ⑤ 便利构造函数 调用 同一类中 ④号构造函数， Person中的 ② 便利构造函数 调用同一类中的 ③ 指定构造函数 构造过程安全检查类的构造的两个阶段 分析图：书Page 200页 1.分配内存 ---&gt;初始化子类存储属性---&gt;沿构造函数链向上初始父类存储属性 到达构造函数链顶部，出书画全部的父类存储属性2.修改属性 ---&gt; 调用方法]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
        <category>Inheritance</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Grammar</tag>
        <tag>Inheritance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Character字符]]></title>
<url>../../../../../../../../2017/12/08/Swift-Grammar/Swift-Grammar-Character字符/</url>
    <content type="text"><![CDATA[字符 swift 采用Unicode编码 一个字符可以用字符本身，也可以用Unicode编码 Unicode编码 C 和 OC等，字符放在(‘)之间的 Swift （””）双引号 Unicode编码可以有 单、双、四字节编码表现形式 \u{} n为1-8个16尽职数 let andSign1:Character = "&amp;" //用字符本print(andSign1) // &amp;let andSign2:Character = "\u&#123;26&#125;" //用Unicode编码print(andSign2) // &amp; Swift字符类型是Character。声明let/var如果省略Character类型声明,自动推段是字符串，”&amp;”默认是字符串类型 转义符 字符表示 Uicode编码 说明 \t \u{0009} 水平制表符tab \n \u{000a} 换行 \r \u{000d} 回车 \” \u{0022} 双引号 \’ \u{0027} 单引号 \ \u{005c} 反斜线 //转义符 let specialCharTab1 = "Yue\tKekui" print("specialCharTab1:\(specialCharTab1)")]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Swift, Grammar,String, Character]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Lazy-懒加载]]></title>
<url>../../../../../../../../2017/12/08/Swift-Grammar/Swift-Grammar-Lazy-懒加载/</url>
    <content type="text"><![CDATA[惰性初始化 懒加载本质上是一个 闭包懒加载会在第一次访问的时候执行, 闭包执行结束后, 会把结果保存在 属性 中后续调用, 直接返回 属性 的内容懒加载的属性会分配空间, 存储值只要调用过一次, 懒加载后面的闭包再也不会执行了延迟加载, 减少内存的消耗,初始化并且分配空间, 会提前创建可以解除解包的烦恼被设置为 nil, 懒加载也不会再次执行懒加载的代码只会在第一次调用的时候, 执行闭包, 然后将闭包的结果保存在 的属性中Swift中，有两种方式来惰性初始化 class DemoLabel: UILabel &#123; //模型 ---&gt; 给视图设置模型, 由视图自己根据模型的数据显示内容 var person: Student? &#123; // 就是替代 OC 中重写 setter 方法 , 区别: 再也不需要考虑 _成员变量 = 值, OC 中如果是 copy 属性, 应该 _成员变量 = [值 copy] didSet&#123; // 此时 name 属性已经有值, 可以直接使用设置 UI 内容 text = person?.name &#125; &#125;&#125;class ViewController: UIViewController &#123; var label: DemoLabel? /* &#123;&#125; 包装代码 () 执行代码 日常开发: 1. 闭包中的智能提示不好 2. 闭包中如果出现 self. 还需要注意循环引用 */ lazy var label2 = &#123; () -&gt; DemoLabel in let l = DemoLabel() // 设置 Label 的属性... return l &#125;() // 注意: 一旦 label 被设置为 nil, 懒加载也不会再次执行 // 懒加载的代码只会在第一次调用的时候, 执行闭包, 然后将闭包的结果保存在 label 的属性中 private lazy var label3: UILabel? = UILabel() override func viewDidLoad() &#123; super.viewDidLoad() // 设置 UI setupUI() label3?.text = "hello" label3?.sizeToFit() print(label3 as Any) label3 = nil print(label3 as Any) &#125; private func setupUI() &#123; // 1. swvf控件 label = DemoLabel() // ! 解包, 为了参与计算, addSubView 用 subViews 数组记录控件, 数组中不允许加入 nil // ? 可选解包, 调用方法, 如果为 nil, 不调用方法, 但是不能参与计算 view.addSubview(label!) label?.text = "hello" label?.sizeToFit() label?.center = view.center &#125; override func didReceiveMemoryWarning() &#123; // Swift 中一定注意不要主动清理视图或者控件// 因为懒加载不会再次创建 &#125;&#125; 简单表达式lazy var first = NSArray(objects: "1","2") ##闭包 不要忘记最后的小括号，只有加了小括号，必包才会在掉用的时候立刻执行要类型声明lazy var second:String，这样Xcode会进行类型检 lazy var second:String = &#123; return "second" &#125;() //&#123;&#125; 包装代码 () 执行代码 惰性初始化的使用场景①属性本身依赖于外部因素才能初始化 completeURL表示完整的URL，这个变量依赖于自身的url是否含有http://前缀 class Demo&#123; var url:NSString lazy var completeURL:NSString = &#123; [unowned self] in if self.url.hasPrefix("http://")&#123; return self.url &#125;else&#123; return "http://".stringByAppendingString(self.url) &#125; &#125;() init(url:NSString)&#123; self.url = url &#125;&#125; ②属性需要复杂计算，消耗大量CPUlazy var second:Int = &#123; var sum = 0 for i in 1...100000&#123; sum += i &#125; return sum &#125;() ③属性不确定是否会使用到 官网的例子，注意，对于Manager来说，使用的时候，可能导入，也可能不倒入数据。从硬盘读取数据的代价是很大的，不导入数据的时候，不要初始化 class DataImporter &#123; /* DataImporter is a class to import data from an external file. The class is assumed to take a non-trivial amount of time to initialize. */ var fileName = "data.txt" // the DataImporter class would provide data importing functionality here&#125;class DataManager &#123; lazy var importer = DataImporter() var data = [String]() // the DataManager class would provide data management functionality here&#125;let manager = DataManager()manager.data.append("Some data")manager.data.append("Some more data") ④定制化的初始化 有些初始化只需要初始化一次，在变量定义的地方初始化，有助于代码维护 lazy var dataArray:NSMutableArray = &#123; var array = NSMutableArray() for i in 1...100&#123; array.addObject(NSNumber(integer: i)) &#125; return array &#125;()]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
        <category>Lazy</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Grammar</tag>
        <tag>Lazy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Override重写]]></title>
<url>../../../../../../../../2017/12/08/Swift-Grammar/Swift-Grammar-Override-重写/</url>
    <content type="text"><![CDATA[定义一个类 定义可继承的基础类nameStr： 人名abilityInt ： 能力值 class People&#123; var nameStr: String var abilityInt: Int func des() -&gt; String &#123; return "\(nameStr)的能力值\(abilityInt)" &#125; init() &#123; nameStr = "YueKekui" abilityInt = 0 &#125;&#125; 重写父类方法重写init initnationalityStr:新加国籍 class ChinesePeople:People&#123; var nationalityStr = "中国🇨🇳" override init() &#123; super.init() nameStr = "ChenJian" abilityInt = 666 //self.nameStr = "LuGaygay" //self.abilityInt = 8888 //继承了父类的属性，因此nameStr、 self.nameStr的属性 &#125; override func des()-&gt;String&#123; return super.des() + "他是\(nationalityStr)人" &#125;&#125; 打印let onePeople = ChinesePeople.init()print( onePeople.des()) // ChenJian的能力值666他是中国🇨🇳人 重写属性 子类并不知道继承来的属性是储值型还是算值型，它只知道继承来的属性有一个名字和类型，所以在重写属性时必须把它的名字和类型都写出来储值属性可以重写为算值属性只读可以重写为读写；读写不能重写为只读不想重写getter，可以直接返回super.Someproperty Get/Setclass AmericanPeople: ChinesePeople &#123; // override var nationalityStr = "美国🇺🇸"////重写了父类的属性nationalityStr，因此self和super的nationalityStr是两个不同的属性 override var nationalityStr:String &#123; get &#123; return super.nationalityStr &#125; set &#123; super.nationalityStr = "美国🇺🇸" &#125; &#125;&#125; 打印let secondPeople = AmericanPeople.init() secondPeople.nationalityStr = "注意重写set get的返回" print(secondPeople.des()) // ChenJian的能力值666他是美国🇺🇸人 重写属性观察器 可以为继承来的变量储值属性添加属性观察器可以值重写didSet或willSet didSetclass AustraliansPeople: People &#123; var richInt = 1 override var abilityInt: Int&#123; didSet&#123; richInt = Int(abilityInt*2)+2; &#125; &#125; //重写打印方法 override func des() -&gt; String &#123; return super.des()+"财富指标\(richInt)" &#125;&#125; 打印let thirdPeople = AustraliansPeople.init() thirdPeople.abilityInt = 5 print(thirdPeople.des()) //YueKekui的能力值5财富指标12 防止重写 通过把方法、属性或下标标记为final来防止它们被重写在扩展中，添加到类里的方法、属性或下标也可以在扩展的定义里标记为final可以在class前添加final来将整个定义为不能重写，这样的类是不可继承的]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Grammar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UITableView]]></title>
<url>../../../../../../../../2017/12/07/Swift-UIKit/Swift-UIKit-UITableView/</url>
    <content type="text"><![CDATA[UITableView声明tableView:UITableView变量var kSize=UIScreen.main.bounds;var _tableView:UITableView! //tableViewvar data :[(String,String)] = [("寥寥","有点绿"),("卢Gaygay","有点Gay"),("222","2---2"),("333","3--3")] //数据源 声明tableView的数据源的代理协议class ViewController: UIViewController,UITableViewDataSource,UITableViewDelegate &#123; MARK: 设置tableViewfunc makeTableView() &#123; _tableView = UITableView.init(frame: CGRect(x: 0.0, y: 64, width: kSize.width, height: kSize.height-64), style:.plain) self.view.addSubview(_tableView); // 添加tableView _tableView.dataSource = self; _tableView.delegate = self; _tableView.showsVerticalScrollIndicator = false _tableView.showsHorizontalScrollIndicator = false _tableView.tableFooterView = UIView() //tableFooter&#125; MARK: 实现tableView.dataSource协议中方法MARK: 行func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return data.count;&#125; MARK: Cellfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; var cell = tableView.dequeueReusableCell(withIdentifier: "陈建") if cell == nil &#123; cell = UITableViewCell(style:UITableViewCellStyle.default,reuseIdentifier:"陈建") &#125; let btn:UIButton = UIButton.init(type:UIButtonType.custom) btn.frame = CGRect(x:UIScreen.main.bounds.width - 100, y:10, width:80, height:50) btn.backgroundColor = UIColor.red; btn.setTitle("btn标题", for: UIControlState.normal) btn.setTitleColor(UIColor.blue, for: UIControlState.normal) btn.tag = indexPath.row btn.addTarget(self, action:#selector(clickBtnAction), for: .touchUpInside) cell?.textLabel?.text = data[indexPath.row].0; cell?.contentView.addSubview(btn); cell?.accessoryType=UITableViewCellAccessoryType.disclosureIndicator return cell!&#125; MARK: cell- 高度func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123; return 66;&#125; 头部高度func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123; return 0.01&#125; 底部高度func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&gt; CGFloat &#123; return 0.01&#125; 选中cell时触发public func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)&#123; print("indexPath.row = SelectRow 第\(indexPath.row)行")&#125; 取消选中cell时public func tableView(_ tableView: UITableView, didDeselectRowAt indexPath: IndexPath)&#123; print("indexPath.row = DeselectRow 第\(indexPath.row)行")&#125; 允许编辑cellfunc tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool &#123; return true&#125; 右滑触发删除按钮func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -&gt; UITableViewCellEditingStyle &#123; return UITableViewCellEditingStyle.init(rawValue: 1)!&#125; 点击删除cell时触发func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123; print("indexPath.row = editingStyle第\(indexPath.row)行")&#125; 点击btn的方法 func clickBtnAction (sender:UIButton)&#123; print("点击了 btn") &#125;&#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UITableView</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-Error-AFN]]></title>
<url>../../../../../../../../2017/12/07/iOS-Code/iOS-Code-Error-AFN/</url>
    <content type="text"><![CDATA[不接受返回类型 解决方案： AFURLResponseSerialization.m中，228行左右把 这句： self.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, nil];修改为：self.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;,@&quot;text/html&quot;, nil];在进行网络请求时出现-1016 是因为只支持text/json，application/json，text/javascript 3840错误 Error Domain=NSCocoaErrorDomain Code=3840 &quot;Invalid value around character 64.&quot; UserInfo=&#123;NSDebugDescription=Invalid value around character 64.&#125;服务器没有返回json数据]]></content>
      <categories>
        <category>iOS</category>
        <category>Error</category>
        <category>AFN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-网络状况侦测]]></title>
<url>../../../../../../../../2017/12/07/iOS-Func/iOS-Func-网络状况侦测/</url>
    <content type="text"><![CDATA[官方示例程序 将Reachability.h 和 Reachability.m 加到自己的项目中并引用 SystemConfiguration.framework 网络的几种状态// the network state of the device for Reachability 2.0.typedef enum &#123; NotReachable = 0, //无连接 ReachableViaWiFi, //使用3G/GPRS网络 ReachableViaWWAN //使用WiFi网络&#125; NetworkStatus; 运用 #import "ViewController.h"#import "Reachability.h"@interface ViewController ()@property (nonatomic, strong) UIAlertController *alertVC;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 创建网络探测对象 Reachability *reach = [Reachability reachabilityWithHostName:@"www.baidu.com"]; // 想通知中心注册通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkChange:) name:kReachabilityChangedNotification object:nil]; // 开启通知监控 [reach startNotifier]; &#125;// 网络状况发生改变后，执行该方法- (void)networkChange:(NSNotification *)noti &#123; self.alertVC = [UIAlertController alertControllerWithTitle:@"网络提示" message:@"当前网络状况有变更" preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *action1 = [UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; [_alertVC dismissViewControllerAnimated:YES completion:nil]; &#125;]; [_alertVC addAction:action1]; Reachability * reach = [noti object]; // 判断当前网络是否可达，可达则继续后边的判断：通过哪种途径到达，不可达，直接返回，不再执行后边的代码 if ([reach isReachable]) &#123; NSLog(@"网络可达"); &#125; else &#123; NSLog(@"网络有故障"); _alertVC.message = @"当前网络有故障"; [self presentViewController:_alertVC animated:YES completion:nil]; return; &#125; if ([reach isReachableViaWiFi]) &#123; NSLog(@"通过WIFI到达"); _alertVC.message = @"当前网络是无线网,为您加载高清资源"; [self presentViewController:_alertVC animated:YES completion:nil]; &#125; else if ([reach isReachableViaWWAN]) &#123; NSLog(@"通过基站到达"); _alertVC.message = @"当前网络是流量，正在为您节省流量"; [self presentViewController:_alertVC animated:YES completion:nil]; &#125; else &#123; NSLog(@"通过其他到达"); _alertVC.message = @"当前使用未知网络"; [self presentViewController:_alertVC animated:YES completion:nil]; &#125;&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UIWebView/WKWebView]]></title>
<url>../../../../../../../../2017/12/07/Swift-UIKit/Swift-UIKit-UIWebView-WKWebView/</url>
    <content type="text"><![CDATA[UIWebView UIWebView功能强大，除了能够显示页面之外，还能显示HTML语言，CSS，PPT，Word等等，其用法也简单 创建let webView = UIWebView.init(frame:self.view.frame) ##添加self.view.addSubview(webView) 加载网页webView.loadRequest(NSURLRequest(url:NSURL.init(string:"http://www.jianshu.com/u/1acf2b5a2f69") as! URL) as URLRequest) 脚本注入let jsPath = NSBundle.mainBundle().pathForResource("app", ofType: "js") 获取到脚本中的内容var jsString :String = try! String(contentsOfFile: jsPath!, encoding: 4)//将获得的文本内容后面的\n替换为空的字符串jsString = jsString.stringByReplacingOccurrencesOfString("\n", withString: "") 触发脚本webView.stringByEvaluatingJavaScriptFromString(jsString as String) webView.scalesPageToFit 有点时候我们加载的网页页面比较大的话 是无法的完全显示在webView上，这个时候我们需要调节webView的scalesPageToFit属性来实现页面适应webView区域的效果 webView.scalesPageToFit = true dataDetectorTypes 我们可以通过设置webView的dataDetectorTypes属性来识别出网页上的电话号码，超链接，邮箱等一些特殊信息，在我们对其进行相关操作的时候可以出发关联事件 webView.dataDetectorTypes = .address//dataDetectorTypes包含以下类型：public struct UIDataDetectorTypes : OptionSet &#123; public init(rawValue: UInt) public static var phoneNumber: UIDataDetectorTypes &#123; get &#125; // Phone number detection public static var link: UIDataDetectorTypes &#123; get &#125; // URL detection @available(iOS 4.0, *) public static var address: UIDataDetectorTypes &#123; get &#125; // Street address detection @available(iOS 4.0, *) public static var calendarEvent: UIDataDetectorTypes &#123; get &#125; // Event detection @available(iOS 10.0, *) public static var shipmentTrackingNumber: UIDataDetectorTypes &#123; get &#125; // Shipment tracking number detection @available(iOS 10.0, *) public static var flightNumber: UIDataDetectorTypes &#123; get &#125; // Flight number detection @available(iOS 10.0, *) public static var lookupSuggestion: UIDataDetectorTypes &#123; get &#125; // Information users may want to look up public static var all: UIDataDetectorTypes &#123; get &#125; // Enable all types, including types that may be added later&#125; UIWebView在加载网页的时候有一些对应的状态，我们可以进行检测：首先实现其代理：UIWebViewDelegate然后设置其代理对象： webView.delegate = self; 实现代理方法： public protocol UIWebViewDelegate : NSObjectProtocol &#123;//链接地址发生改变的时候调用 @available(iOS 2.0, *) optional public func webView(_ webView: UIWebView, shouldStartLoadWith request: URLRequest, navigationType: UIWebViewNavigationType) -&gt; Bool//开始加载 @available(iOS 2.0, *) optional public func webViewDidStartLoad(_ webView: UIWebView)//完成加载 @available(iOS 2.0, *) optional public func webViewDidFinishLoad(_ webView: UIWebView)//加载失败 @available(iOS 2.0, *) optional public func webView(_ webView: UIWebView, didFailLoadWithError error: Error)&#125; 可以对webView加载状态进行控制，比如：停止加载，继续加载等，其设置方法为： //重新加载- (void)reload;//停止加载- (void)stopLoading;//返回- (void)goBack;//前往- (void)goForward; 以下是UIWebView对于HTML语言，本地文件等信息的加载： //加载HTML文本- (void)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;//加载Data类型- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;//实现与JS的交互- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; WKWebView 使用方法 //创建let wkWebView = WKWebView()//设置位置和大小wkWebView.frame = self.view.frame;//创建的时候就设置位置和大小/* public init(frame: CGRect, configuration: WKWebViewConfiguration)*/let webview = WKWebView(frame: CGRectMake(0, 0, self.view.frame.width, self.view.frame.height))//添加self.view.addSubview(wkWebView)//请求/* open func load(_ request: URLRequest) -&gt; WKNavigation?*/wkWebView.load(NSURLRequest(url: NSURL(string:"http://www.baidu.com") as! URL) as URLRequest) WKWebView的代理方法：WKNavigationDelegate通过WKNavigationDelegate提供的代理方法，我们可以追踪WKWebView加载的过程 /页面开始加载时调用 @available(iOS 8.0, *) optional public func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!)// 页面加载失败时调用 @available(iOS 8.0, *) optional public func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error)// 当内容开始返回时调用 @available(iOS 8.0, *) optional public func webView(_ webView: WKWebView, didCommit navigation: WKNavigation!)// 页面加载完成之后调用 @available(iOS 8.0, *) optional public func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) 页面跳转的代理方法有三种，分为（收到跳转与决定是否跳转两种） // 接收到服务器跳转请求之后调用 @available(iOS 8.0, *) optional public func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!)// 在发送请求之前，决定是否跳转 @available(iOS 8.0, *) optional public func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Swift.Void)// 在收到响应后，决定是否跳转 @available(iOS 8.0, *) optional public func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: @escaping (WKNavigationResponsePolicy) -&gt; Swift.Void)//web内容视图被终止的时候触发 @available(iOS 9.0, *) optional public func webViewWebContentProcessDidTerminate(_ webView: WKWebView) WKUIDelegate / 创建一个新的WebView @available(iOS 8.0, *) optional public func webView(_ webView: WKWebView, createWebViewWith configuration: WKWebViewConfiguration, for navigationAction: WKNavigationAction, windowFeatures: WKWindowFeatures) -&gt; WKWebView? web界面的三种提示框（警告框、确认框、输入框）分别对应三种代理方法 /** * web界面中有弹出警告框时调用 * @param webView 实现该代理的webview * @param message 警告框中的内容 * @param frame 主窗口 * @param completionHandler 警告框消失调用 */ @available(iOS 8.0, *) optional public func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -&gt; Swift.Void)/** * web界面中有弹出确认框时调用 * @param webView 实现该代理的webview * @param message 确认框中的内容 * @param frame 主窗口 * @param completionHandler 确认框消失调用 */ @available(iOS 8.0, *) optional public func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -&gt; Swift.Void)/** * web界面中有弹出输入框时调用 * @param webView 实现该代理的webview * @param message 输入框中的内容 * @param frame 主窗口 * @param completionHandler 输入框消失调用 */ @available(iOS 8.0, *) optional public func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -&gt; Swift.Void) WKScriptMessageHandler @available(iOS 8.0, *) public func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) 这个方法是WKscriptMessageHandler协议中必须实现的方法，是提高App与web端交互的关键，它可以直接将接收到的JS脚本转为OC或Swift对象获取网页标题需要遵守WKNavigationDelegate协议并设置：webview.navigationDelegate = self网页加载完的时候我们能获取网页的标题，所以这个步骤应该写在网页状态加载完成的方法里面： func webView(webView: WKWebView, didFinishNavigation navigation: WKNavigation!) &#123; //print(self.webview.title) &#125; 获取当前网页的url func webView(webView: WKWebView, decidePolicyForNavigationAction navigationAction:WKNavigationAction, decisionHandler: (WKNavigationActionPolicy) -&gt;Void) &#123; var urlString:NSString! = navigationAction.request.URL?.absoluteStringdecisionHandler(WKNavigationActionPolicy.Allow)//一定要加上这一句代码不然会出异常 &#125; 前进，后退，停止。。。WKWebView想UIWebView一样，可以获取一些状态，以及进行对应操作 open func reload()//重新加载open func stopLoading()//停止加载 open func goBack()//返回open func goForward()//前进 //能不能后退 前往 加载open var canGoBack: Bool &#123; get &#125;open var canGoForward: Bool &#123; get &#125;open var isLoading: Bool &#123; get &#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UIWebView/WKWebView</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UIImageView]]></title>
<url>../../../../../../../../2017/12/07/Swift-UIKit/Swift-UIKit-UIImageView/</url>
    <content type="text"><![CDATA[UIImageView创建的时候直接设置图片let imageView = UIImageView(image:UIImage(named:"girl")) 先创建出对象再设置图片let imageView1 = UIImageView()imageView1.image = UIImage(named:"girl") 图片获取 从文件目录中获取图片 let path = Bundle.main.path(forResource:"girl", ofType: "png")let newImage = UIImage(contentsOfFile: path!) 网络地址获取图片 let url = URL(string:"http://image.cnpp.cn/upload/images/20160905/09380421552_400x300.jpg")let data = try! Data(contentsOf: url!)let smallImage = UIImage(data: data)//imageView1.image = smallImagelet imageView1 = UIImageView(image:smallImage) 图片显示填充样式imageView1.contentMode = UIViewContentMode.scaleAspectFit 对于UIImageView的图片填充样式有多种public enum UIViewContentMode : Int &#123;case scaleToFillcase scaleAspectFit // contents scaled to fit with fixed aspect. remainder is transparentcase scaleAspectFill // contents scaled to fill with fixed aspect. some portion of content may be clipped.case redraw // redraw on bounds change (calls -setNeedsDisplay)case center // contents remain same size. positioned adjusted.case topcase bottomcase leftcase rightcase topLeftcase topRightcase bottomLeftcase bottomRight&#125; 分组图片轮展 UIImageView中有设置多张图片一块展示的功能，类似于幻灯片的自动播放。其实现过程如下： //设置图片数组imageView1.animationImages = [UIImage(named:"2")!,UIImage(named:"3")!]//所有图片展示完一遍的总时长imageView1.animationDuration = 2//开始imageView1.startAnimating()//结束imageView1.stopAnimating() 添加点击事件 UIImageView和UILabel类似，其用户交互默认关闭，我们要给其添加点击事件，需要打开其用户交互 imageView1.isUserInteractionEnabled = truelet tapGestureRecognizer = UITapGestureRecognizer(target: self, action:#selector(ViewController.tapGestureRecognizer(sender:)))imageView1.addGestureRecognizer(tapGestureRecognizer)func tapGestureRecognizer(sender:UITapGestureRecognizer) &#123; //code&#125; 属性设置 //边框设置imageView.layer.borderColor = UIColor.redColor().CGColorimageView.layer.borderWidth = 2//圆角的设置imageView.layer.cornerRadius = 150imageView.layer.masksToBounds = trueUIImageView继承UIView，很多常见的属性在此就不列举。。]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UIImageView</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UIImageView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UISegmentedControl-分段选择控件]]></title>
<url>../../../../../../../../2017/12/07/Swift-UIKit/Swift-UIKit-UISegmentedControl-分段选择控件/</url>
    <content type="text"><![CDATA[UISegmentedControl 继承自UIControl 分段选项显示###初始化数据源 let items = ["见哥1","见哥2",UIImage(named:"1")!] as [Any] 初始化对象let segmentedControl = UISegmentedControl(items:items) 设置位置segmentedControl.center = self.view.center 当前选中下标segmentedControl.selectedSegmentIndex = 1 ##添加事件 segmentedControl.addTarget(self, action: #selector(segmentedControlChanged), for: UIControlEvents.valueChanged) 添加self.view.addSubview(segmentedControl) 选择点击后的事件func segmentedControlChanged(sender:UISegmentedControl) &#123; print(sender.selectedSegmentIndex) print(sender.titleForSegment(at: sender.selectedSegmentIndex))&#125; 添加删除选项 UISegmentedControl每个选项的宽度在默认情况下会根据选项的个数自动分配，而个数在初始化控件之后可以添加和删除 添加图片选项segmentedControl.insertSegment(with: UIImage(named:"2"), at: 0, animated: true) 添加文字选项segmentedControl.insertSegment(withTitle: "见哥0", at: 1, animated: true) 移除制定下标的选项segmentedControl.removeSegment(at: 1, animated: true) 移出所有segmentsegment.removeAllSegments() 颜色设定segmentedControl.tintColor = UIColor.red 获取颜色var segmentColor = segment.tintColor 显示文字修改segmented.setTitle("swfit", forSegmentAt:1) 获取某一个下标下的标题var title = segment.titleForSegmentAtIndex(1) 修改选项图片segmented.setImage(UIImage(named:"icon"), forSegmentAt:2) 获取某一个下标下得图片var image = segment.imageForSegmentAtIndex(2) 修改选项内容偏移位置segmented.setContentOffset(CGSize(width:10, height:7), forSegmentAt:1) 宽度 UISegmentedControl每个选项的宽度在默认情况下会根据选项的个数自动分配，但是有时候根据项目情况的需要，我们也是可以手动来进行设置/获取的。 设置指定下标选项的宽度segmentedControl.setWidth(10, forSegmentAt: 1) 获取某一个下标segment的宽度var width = segment.widthForSegmentAtIndex(2) 是否根据segment的内容改变segment的宽度segment.apportionsSegmentWidthsByContent = true ###momentary属性 分段选择控件在点击之后一直处于选中状态，除非点击其他分段，才恢复。 momentary属性用来设置是否一直保持选中状态，当设置为YES时，点击选中，但一会就是恢复到正常状态segment.momentary = true]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UISegmentedControl</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UISegmentedControl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UISwitch]]></title>
<url>../../../../../../../../2017/12/07/Swift-UIKit/Swift-UIKit-UISwitch/</url>
    <content type="text"><![CDATA[UISwitch 继承自UIControl UISwitch的大小是确定的不能进行修改 51*31let switchOne = UISwitch(frame:CGRect(x:10.0, y:100.0, width:0.0,height: 0.0))self.view.addSubview(switchOne)switchOne.backgroundColor = UIColor .yellow; 设置打开状态背景颜色switchOne.onTintColor = UIColor.brown 设置关闭状态的背景颜色switchOne.tintColor = UIColor.orange 开关快的颜色switchOne.thumbTintColor = UIColor.red 设置开关状态switchOne.setOn(true, animated: true) 添加按钮事件switchOne.addTarget(self, action: #selector(ViewController.switchOneValueChanged(sender:)), for: UIControlEvents.valueChanged) 状态改变之后的执行方法func switchOneValueChanged(sender:UISwitch) &#123; print("我是一个帅哥，你信不？value=%d",sender.isOn)&#125;switchOne.onImage = UIImage(named:"1")switchOne.offImage = UIImage(named:"2")]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UISwitch</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UISwitch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UIStepper]]></title>
<url>../../../../../../../../2017/12/07/Swift-UIKit/Swift-UIKit-UIStepper/</url>
    <content type="text"><![CDATA[UIStepper创建+framelet stepper = UIStepper()stepper.center = self.view.center 设置最大和最小值stepper.maximumValue = 10stepper.minimumValue = 1 当前值stepper.value = 1 每次变化的单位stepper.stepValue = 1 按住的时候连续变化stepper.isContinuous = true 是否循环 当增长到最大值的时候再从新开始stepper.wraps = true 改变事件添加stepper.addTarget(self, action:#selector(ViewController.stepperChanged(stepper:)), for: UIControlEvents.valueChanged)func stepperChanged(stepper:UIStepper) &#123; print("我是一个帅哥，你信不？value=%d",stepper.value)&#125;self.view.addSubview(stepper) 设置颜色stepper.tintColor = UIColor.green 设置imgstepper.setDecrementImage(UIImage(named:"1"), for: .normal)stepper.setIncrementImage(UIImage(named:"1"), for: .normal)]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UIStepper</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UIStepper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift—UIKit-UISlider]]></title>
<url>../../../../../../../../2017/12/07/Swift-UIKit/Swift-UIKit-UISlider/</url>
    <content type="text"><![CDATA[UISlider创建+framelet slider = UISlider()slider.frame = CGRect(x: 50, y: 100, width: 200, height: 50) ##最小/大值 slider.minimumValue = 0slider.maximumValue = 1 当前值（在取值范围之内的位置）slider.value = 0.5 ##按钮最小/大端图片slider.minimumValueImage = UIImage(named:"SSS")slider.maximumValueImage = UIImage(named:"DDD") 不同状态之下，圆点显示图片slider.setThumbImage(UIImage(named:""), for: .normal)slider.setThumbImage(UIImage(named:""), for: .highlighted)slider.setThumbImage(UIImage(named:""), for: .disabled)slider.setThumbImage(UIImage(named:""), for: .selected) ##设置圆点的颜色 slider.thumbTintColor = UIColor.red 设置划过和没有划过颜色（圆点左/右）slider.minimumTrackTintColor = UIColor.yellowslider.maximumTrackTintColor = UIColor.brown 改变事件 滑块滑动停止后才触发ValueChanged事件 slider.isContinuous = falseslider.addTarget(self, action: #selector(ViewController.change(slider:)), for: UIControlEvents.valueChanged)slider.addTarget(self, action: #selector(ViewController.sliderDragUp(sender:)), for: UIControlEvents.touchUpInside)func change(slider:UISlider) &#123; print("slider.value = %d",slider.value)&#125;func sliderDragUp(sender: UISlider) &#123; print("value:(sender.value)")&#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UISlider</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UISlider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UITextField]]></title>
<url>../../../../../../../../2017/12/07/Swift-UIKit/Swift-UIKit-UITextField/</url>
    <content type="text"><![CDATA[文本输入框 创建+frame let textField = UITextField(frame: CGRect(x:10, y:60, width:200, height:30))// let textField = UITextField()// textField.frame = CGRect(x:20,y:30,width:100,height:30) 设置边框样式为圆角矩形 textField.borderStyle = UITextBorderStyle.roundedRectself.view.addSubview(textField) 文本输入框的边框样式 public enum UITextBorderStyle : Int &#123; case none 无边框 case line 直线边框 case bezel 圆角矩形边框 case roundedRect 边线+阴影&#125; 文本输入框的提示文字 textField.placeholder = "请输入相关信息" 文字大小超过文本框长度时自动缩小字号，而不是隐藏显示省略号 textField.adjustsFontSizeToFitWidth=true //当文字超出文本框宽度时，自动调整文字大小textField.minimumFontSize=14 //最小可缩小的字号 水平/垂直对齐方式 /** 水平对齐 **/textField.textAlignment = .right //水平右对齐textField.textAlignment = .center //水平居中对齐textField.textAlignment = .left //水平左对齐 /** 垂直对齐 **/textField.contentVerticalAlignment = .top //垂直向上对齐textField.contentVerticalAlignment = .center //垂直居中对齐textField.contentVerticalAlignment = .bottom //垂直向下对齐 背景图片设置 textField.borderStyle = .none //先要去除边框样式textField.background = UIImage(named:"background1") 清除按钮（输入框内右侧小叉） textField.clearButtonMode = .whileEditing //编辑时出现清除按钮textField.clearButtonMode = .unlessEditing //编辑时不出现，编辑后才出现清除按钮textField.clearButtonMode = .always //一直显示清除按钮 键盘类型 Default： 系统默认的虚拟键盘ASCII Capable： 显示英文字母的虚拟键盘Numbers and Punctuation：显示数字和标点的虚拟键盘URL： 显示便于输入url网址的虚拟键盘Number Pad： 显示便于输入数字的虚拟键盘Phone Pad： 显示便于拨号呼叫的虚拟键盘Name Phone Pad： 显示便于聊天拨号的虚拟键盘Email Address： 显示便于输入Email的虚拟键盘Decimal Pad： 显示用于输入数字和小数点的虚拟键盘Twitter： 显示方便些Twitter的虚拟键盘Web Search： 显示便于在网页上书写的虚拟键盘 设置文本框关联的键盘 textField.keyboardType = UIKeyboardType.numberPad 使文本框失去焦点，并收回键盘 textField.resignFirstResponder() 设置键盘return键的样式 extField.returnKeyType = UIReturnKeyType.done //表示完成输入textField.returnKeyType = UIReturnKeyType.go //表示完成输入，同时会跳到另一页textField.returnKeyType = UIReturnKeyType.search //表示搜索textField.returnKeyType = UIReturnKeyType.join //表示注册用户或添加数据textField.returnKeyType = UIReturnKeyType.next //表示继续下一步textField.returnKeyType = UIReturnKeyType.send //表示发送 键盘return键的响应 import UIKitclass ViewController: UIViewController,UITextFieldDelegate &#123; override func viewDidLoad() &#123; super.viewDidLoad() let textField = UITextField(frame: CGRect(x:10,y:160,width:200,height:30)) //设置边框样式为圆角矩形 textField.borderStyle = UITextBorderStyle.roundedRect textField.returnKeyType = UIReturnKeyType.done textField.delegate=self self.view.addSubview(textField) &#125; func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123; //收起键盘 textField.resignFirstResponder() //打印出文本框中的值 print(textField.text) return true; &#125;&#125; 输入/显示文本字体的颜色 textField.textColor = UIColor.cyan 文本框的字体大小设置 //text.font = [UIFont fontWithName:@"Arial" size:20.0f]; //设置输入框内容的字体样式和大小textField.font = UIFont.systemFont(ofSize: 14) 文本输入框的代理设置（遵守UITextFieldDelegate协议） class ViewController: UIViewController,UITextFieldDelegate &#123;textField.delegate = self 输入框的背景颜色 text.backgroundColor = [UIColor whiteColor]//设置输入框的背景颜色，此时设置为白色 如果使用了自定义的背景图片边框会被忽略掉 ~~~ 输入框中一开始就有的文字 text.text = @"文字"; 是否自动纠错 text.autocorrectionType = UITextAutocorrectionTypeNo 几种选择样式typedef enum &#123; UITextAutocorrectionTypeDefault, 默认 UITextAutocorrectionTypeNo, 不自动纠错 UITextAutocorrectionTypeYes, 自动纠错&#125; UITextAutocorrectionType; 再次编辑就清空 text.clearsOnBeginEditing = YES 首字母是否自动大 text.autocapitalizationType = UITextAutocapitalizationTypeNone;typedef enum &#123; UITextAutocapitalizationTypeNone, 不自动大写 UITextAutocapitalizationTypeWords, 单词首字母大写 UITextAutocapitalizationTypeSentences, 句子的首字母大写 UITextAutocapitalizationTypeAllCharacters, 所有字母都大写&#125; UITextAutocapitalizationType; 键盘外观 textView.keyboardAppearance=UIKeyboardAppearanceDefault typedef enum &#123; UIKeyboardAppearanceDefault， 默认外观，浅灰色 UIKeyboardAppearanceAlert， 深灰 石墨色&#125; UIReturnKeyType; 最右侧加图片是以下代码（左侧类似） UIImageView *image=[[UIImageView alloc] initWithImage:[UIImage imageNamed:@"right.png"]] //text.rightView=image;text.rightViewMode = UITextFieldViewModeAlwaystypedef enum &#123; UITextFieldViewModeNever, UITextFieldViewModeWhileEditing, UITextFieldViewModeUnlessEditing, UITextFieldViewModeAlways&#125; UITextFieldViewMode; 重写绘制行为除了UITextField对象的风格选项，你还可以定制化UITextField对象，为他添加许多不同的重写方法，来改变文本字段的显示行为。这些方法都会返回一个CGRect结构，制定了文本字段每个部件的边界范围。以下方法都可以重写 – textRectForBounds: //重写来重置文字区域– drawTextInRect: //改变绘文字属性.重写时调用super可以按默认图形属性绘制,若自己完全重写绘制函数，就不用调用super了.– placeholderRectForBounds: //重写来重置占位符区域– drawPlaceholderInRect: //重写改变绘制占位符属性.重写时调用super可以按默认图形属性绘制,若自己完全重写绘制函数，就不用调用super了.– borderRectForBounds: //重写来重置边缘区域– editingRectForBounds: //重写来重置编辑区域– clearButtonRectForBounds: //重写来重置clearButton位置,改变size可能导致button的图片失真– leftViewRectForBounds:– rightViewRectForBounds: 委托方法 (BOOL)textFieldShouldBeginEditing:(UITextField *)textField&#123;//返回一个BOOL值，指定是否循序文本字段开始编辑return YES;&#125;(void)textFieldDidBeginEditing:(UITextField *)textField&#123;//开始编辑时触发，文本字段将成为first responder&#125;(BOOL)textFieldShouldEndEditing:(UITextField *)textField&#123;//返回BOOL值，指定是否允许文本字段结束编辑，当编辑结束，文本字段会让出first responder//要想在用户结束编辑时阻止文本字段消失，可以返回NO//这对一些文本字段必须始终保持活跃状态的程序很有用，比如即时消息return NO;&#125;(BOOL)textField:(UITextField*)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123;//当用户使用自动更正功能，把输入的文字修改为推荐的文字时，就会调用这个方法。//这对于想要加入撤销选项的应用程序特别有用//可以跟踪字段内所做的最后一次修改，也可以对所有编辑做日志记录,用作审计用途。//要防止文字被改变可以返回NO//这个方法的参数中有一个NSRange对象，指明了被改变文字的位置，建议修改的文本也在其中return YES;&#125;(BOOL)textFieldShouldClear:(UITextField *)textField&#123;//返回一个BOOL值指明是否允许根据用户请求清除内容//可以设置在特定条件下才允许清除内容return YES;&#125;-(BOOL)textFieldShouldReturn:(UITextField *)textField&#123;//返回一个BOOL值，指明是否允许在按下回车键时结束编辑//如果允许要调用resignFirstResponder 方法，这回导致结束编辑，而键盘会被收起[textField resignFirstResponder];//查一下resign这个单词的意思就明白这个方法了return YES;&#125; 通知 UITextField派生自UIControl，所以UIControl类中的通知系统在文本字段中也可以使用。除了UIControl类的标准事件，你还可以使用下列UITextField类特有的事件UITextFieldTextDidBeginEditingNotificationUITextFieldTextDidChangeNotificationUITextFieldTextDidEndEditingNotification当文本字段退出编辑模式时触发。通知的object属性存储了最终文本。因为文本字段要使用键盘输入文字，所以下面这些事件发生时，也会发送动作通知UIKeyboardWillShowNotification //键盘显示之前发送UIKeyboardDidShowNotification //键盘显示之后发送UIKeyboardWillHideNotification //键盘隐藏之前发送UIKeyboardDidHideNotification //键盘隐藏之后发送//添加通知方法NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("textFiledEditChanged:"), name: UITextFieldTextDidChangeNotification, object: textfield) 限制只能输入特定的字符 -(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123;NSCharacterSet *cs;cs = [[NSCharacterSet characterSetWithCharactersInString:NUMBERS]invertedSet];NSString *filtered = [[string componentsSeparatedByCharactersInSet:cs]componentsJoinedByString:@""];//按cs分离出数组,数组按@""分离出字符串BOOL canChange = [string isEqualToString:filtered];return canChange;&#125;上面这个NUMBERS是一个宏，可以在文件顶部定义：define NUMBERS @”0123456789\n”如果你要限制输入英文和数字的话，就可以把这个定义为：define kAlphaNum @”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789″ 限制只能输入一定长度的字符 (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;&#123; //string就是此时输入的那个字符 textField就是此时正在输入的那个输入框 返回YES就是可以改变输入框的值 NO相反if ([string isEqualToString:@"\n"]) //按会车可以改变&#123;return YES;&#125;NSString * toBeString = [textField.text stringByReplacingCharactersInRange:range withString:string];//得到输入框的内容if (self.myTextField == textField) //判断是否时我们想要限定的那个输入框&#123;if ([toBeString length] &gt; 20) &#123; //如果输入框内容大于20则弹出警告textField.text = [toBeString substringToIndex:20];UIAlertView *alert = [[[UIAlertView alloc] initWithTitle:nil message:@"超过最大字数不能输入了" delegate:nil cancelButtonTitle:@"Ok" otherButtonTitles:nil, nil] autorelease];[alert show];return NO;&#125;&#125;return YES;&#125;//设置能不能进行编辑/用户交互的开关textfield.enabled = truetextfield.userInteractionEnabled = true//设置圆角属性textField.layer.cornerRadius = 10.0textField.layer.masksToBounds = true//自定义输入源控件let inputview = UIButton(frame: CGRectMake(0.0, 0.0, CGRectGetWidth(self.view.bounds), 100.0))inputview.setImage(UIImage(named: "normalImage"), forState: UIControlState.Normal)inputview.backgroundColor = UIColor.lightGrayColor()inputview.addTarget(self, action: Selector("click:"), forControlEvents: UIControlEvents.TouchUpInside)textfield.inputView = inputview// 自定义输入源控件副视图let accessoryview = UIView(frame: CGRectMake(0.0, 0.0, CGRectGetWidth(self.view.bounds), 40.0))accessoryview.backgroundColor = UIColor.greenColor()let accessoryLeft = UIButton(frame: CGRectMake(10.0, 10.0, 60.0, 20.0))accessoryview.addSubview(accessoryLeft)accessoryLeft.setTitle("取消", forState: UIControlState.Normal)accessoryLeft.backgroundColor = UIColor.orangeColor()accessoryLeft.addTarget(self, action: Selector("leftClick:"), forControlEvents: UIControlEvents.TouchUpInside)let accessoryRight = UIButton(frame: CGRectMake((CGRectGetWidth(accessoryview.bounds) - 10.0 - 60.0), 10.0, 60.0, 20.0))accessoryview.addSubview(accessoryRight)accessoryRight.setTitle("确定", forState: UIControlState.Normal)accessoryRight.backgroundColor = UIColor.orangeColor()accessoryRight.addTarget(self, action: Selector("rightClick:"), forControlEvents: UIControlEvents.TouchUpInside)textfield.inputAccessoryView = accessoryview// 自定义输入源控件时响应事件// MARK: - clickfunc click(button:UIButton)&#123;self.view.endEditing(true)&#125;//MARK: - left/right clickfunc leftClick(button:UIButton)&#123;print("取消")&#125;func rightClick(button:UIButton)&#123;self.view.endEditing(true)print("确定")&#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UITextField</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UITextField</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UIButton]]></title>
<url>../../../../../../../../2017/12/06/Swift-UIKit/Swift-UIKit-UIButton/</url>
    <content type="text"><![CDATA[UIButton UIButton继承自UIControl 创建btnlet btn: UIButton = UIButton() //没有样式//let btns:UIButton =UIButton(type: UIButtonType)//有样式//let button = UIButton(frame:CGRect(x:10, y:150, width:100, height:30))//简化创建方式self.view.addSubview(button) UIButtonType有以下类型public enum UIButtonType : Int &#123; case custom // no button type @available(iOS 7.0, *) case system // standard system button case detailDisclosure case infoLight case infoDark case contactAdd public static var roundedRect: UIButtonType &#123; get &#125; // Deprecated, use UIButtonTypeSystem instead&#125;//使用let btn: UIButton = UIButton(type: .Custom) UIButton设置字内容和颜色 UIButton所对应的状态有几种 /** Normal (默认状态) Highlighted （高亮状态）点击按钮不放 Disabled （使能状态）就是是否可用状态--&gt;禁用的状态才会显现 Selected （选中状态）通过selected属性设置 */ /显示文字button1.setTitle("普通状态", for: .normal)button1.setTitle("高粱状态", for: .highlighted)button1.setTitle("禁用状态", for: .disabled)//显示文字颜色button1.setTitleColor(UIColor.red, for: .normal)button1.setTitleColor(UIColor.blue, for: .highlighted)button1.setTitleColor(UIColor.cyan, for: .selected)button1.setTitleColor(UIColor.cyan, for: .disabled)//阴影文字颜色设置button1.setTitleShadowColor(UIColor.cyan, for: .normal)button1.setTitleShadowColor(UIColor.green, for: .highlighted)button1.setTitleShadowColor(UIColor.brown, for: .disabled)button1.setTitleShadowColor(UIColor.darkGray, for: .selected) UIButton设置背景颜色和背景图片 //背景颜色button2.backgroundColor = UIColor.orange//背景图片 button4.setBackgroundImage(UIImage(named:"XXX"), for: .normal) UIButton设置字体大小button.titleLabel?.font = UIFont.systemFont(ofSize: 12) 禁用UIButton button.isEnabled = falsebutton.isEnabled = true 设置圆角 button.layer.cornerRadius = 5button.layer.masksToBounds = true 设置边框宽度/颜色 button.layer.borderWidth = 2button.layer.borderColor = UIColor.red.cgColor 设置背景图片为圆角 buttonImage.setImage(UIImage(named:"1") , forState: UIControlState.Normal)//设置背景图片为圆角buttonImage.imageView?.layer.cornerRadius = 50默认情况下按钮会被渲染成单一颜色；系统蓝button.setImage(UIImage(named:"icon1"),forState:.Normal) //设置图标button.adjustsImageWhenHighlighted=false //使触摸模式下按钮也不会变暗（半透明）button.adjustsImageWhenDisabled=false //使禁用模式下按钮也不会变暗（半透明）也可以设置成保留图标原来的颜色let iconImage = UIImage(named:"icon2")?.withRenderingMode(.alwaysOriginal)button.setImage(iconImage, for:.normal) //设置图标button.adjustsImageWhenHighlighted = false //使触摸模式下按钮也不会变暗（半透明）button.adjustsImageWhenDisabled = false //使禁用模式下按钮也不会变暗（半透明） UIButton上图片和文字调整 UIButton上添加图片和文字，有时需要我们调整,方向为逆时针方向，上、左、下、右依次去设置的 btn.imageEdgeInsets =UIEdgeInsetsMake(top: CGFloat, left: CGFloat, bottom: CGFloat, right: CGFloat)btn.titleEdgeInsets =UIEdgeInsetsMake(top: CGFloat, left: CGFloat, bottom: CGFloat, right: CGFloat) //创建一个图片一个文字的按钮 let btn2: UIButton = UIButton(type: .Custom) btn2.frame = CGRectMake(50, 100, 120, 35) btn2.setImage(UIImage(named: "1"), forState: .Normal) btn2.backgroundColor = UIColor.blackColor() btn2.titleLabel?.font = UIFont.systemFontOfSize(20) btn2.imageView?.contentMode = UIViewContentMode.ScaleAspectFit btn2.setTitle("图片按钮", forState: .Normal) //偏移量，分别为上下左右 btn2.imageEdgeInsets = UIEdgeInsetsMake(0, -50, 0, 0) btn2.titleEdgeInsets = UIEdgeInsetsMake(0, -80, 0, 5) btn2.setTitleColor(UIColor.whiteColor(), forState: .Normal) btn2.adjustsImageWhenHighlighted = false self.view.addSubview(btn2) 添加按钮的点击事件 按钮的触摸时间有以下类型 touchDown：单点触摸按下事件，点触屏幕touchDownRepeat：多点触摸按下事件，点触计数大于1，按下第2、3或第4根手指的时候touchDragInside：触摸在控件内拖动时touchDragOutside：触摸在控件外拖动时touchDragEnter：触摸从控件之外拖动到内部时touchDragExit：触摸从控件内部拖动到外部时touchUpInside：在控件之内触摸并抬起事件touchUpOutside：在控件之外触摸抬起事件touchCancel：触摸取消事件，即一次触摸因为放上太多手指而被取消，或者电话打断 button1.addTarget(self,action:#selector(methodName), for: .touchUpInside)button1.addTarget(self, action:#selector(someMethod(button:)), for:.touchUpInside)//上 func methodName() &#123; print("tapped") &#125;//下 func someMethod(button:UIButton) &#123; print("你是谁啊，其实就是一个按钮") &#125; 按钮文字过长时候的显示处理 修改 button 按钮中 titleLabel 的 lineBreakMode 属性，便可以调整按钮在文字超长的情况下如何显示，以及是否换行 let button = UIButton(frame:CGRect(x:20, y:50, width:130, height:50))button.setTitle("这个是一长长长长长长长长长长的文字", for:.normal) //普通状态下的文字button.setTitleColor(UIColor.white, for: .normal) //普通状态下文字的颜色button.titleLabel?.lineBreakMode = .byTruncatingTailbutton.backgroundColor = UIColor.orangeself.view.addSubview(button) NSLineBreakMode样式可供选择，API的介绍也是简单明 public enum NSLineBreakMode : Int &#123; case byWordWrapping // Wrap at word boundaries, default case byCharWrapping // Wrap at character boundaries case byClipping // Simply clip case byTruncatingHead // Truncate at head of line: "...wxyz" case byTruncatingTail // Truncate at tail of line: "abcd..." case byTruncatingMiddle // Truncate middle of line: "ab...yz"&#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UIButton</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIButton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-UILabel]]></title>
<url>../../../../../../../../2017/12/06/Swift-UIKit/Swift-UIKit-UILabel/</url>
    <content type="text"><![CDATA[lab 创建&amp;&amp; 设置frame let lab = UILabel(frame:CGRect(x:10,y:100,width:self.view.frame.size.width - 40,height:200)) 或 let lab = UILabel()lab.frame = CGRect(x:10,y:100,width:self.view.frame.size.width - 40,height:200) 添加父层 self.view.addSubview(lab); 显示文本内容 lab.text = "chen jian !" 设置bg颜色 lab.backgroundColor = UIColor.green 文字颜色 lab.textColor = UIColor.white 文字对齐方式 lab.textAlignment = NSTextAlignment.left 高亮文字颜色 lab.highlightedTextColor = UIColor.cyan 阴影颜色 lab.shadowColor = UIColor.black 阴影偏移位置 lab.shadowOffset = CGSize(width:-5,height:5) 设置圆角 lab.layer.cornerRadius = 20lab.layer.masksToBounds = true 边框的宽度和颜色 lab.layer.borderColor = UIColor.green.cgColorlab.layer.borderWidth = 2 文字类型/大小 lab.font = UIFont.boldSystemFont(ofSize: 20) //加粗类型lab.font = UIFont.systemFont(ofSize: 20) //文字大小lab.font = UIFont.italicSystemFont(ofSize: 20)//斜体类型lab.font = UIFont(name:"您好",size:50) //大小和文字一起设置 显示de样式 lab.lineBreakMode = NSLineBreakMode.byCharWrapping // NSParagraphStyle@available(iOS 6.0, *)public enum NSLineBreakMode : Int &#123;case byWordWrapping // Wrap at word boundaries, defaultcase byCharWrapping // Wrap at character boundariescase byClipping // Simply clipcase byTruncatingHead // Truncate at head of line: "...wxyz"case byTruncatingTail // Truncate at tail of line: "abcd..."case byTruncatingMiddle // Truncate middle of line: "ab...yz"&#125; 多行de显示 lab.numberOfLines = 2 //最多显示2行lab.numberOfLines = 0 // 默认没有行数显示lab.numberOfLines = 1 //只能显示一行 自动调整文字de大小 lab.adjustsFontSizeToFitWidth = true 富文本设置 //创建对象let attributeString = NSMutableAttributedString(string:"Welcome to Swift! Welcome to Swift! Welcome to Swift! Welcome to Swift!")//设置字体大小/字体类型attributeString.addAttribute(NSFontAttributeName, value: UIFont(name: "HelveticaNeue-Bold", size: 16)!, range: NSMakeRange(0, 6))//设置背景颜色 attributeString.addAttribute(NSForegroundColorAttributeName, value: UIColor.red, range: NSMakeRange(0, 3)) //设置文档背景色 attributeString.addAttribute(NSBackgroundColorDocumentAttribute, value: UIColor.lightGray, range: NSMakeRange(10, 10))//设置下划线attributeString.addAttribute(NSUnderlineStyleAttributeName, value:NSUnderlineStyle.StyleSingle.rawValue, range: NSMakeRange(5,12)) testLable.attributedText = attributeString; 文本高度计算 extension NSString &#123; func textSizeWithFont(font: UIFont, constrainedToSize size:CGSize) -&gt; CGSize &#123; var textSize:CGSize! if CGSizeEqualToSize(size, CGSizeZero) &#123; let attributes = NSDictionary(object: font, forKey: NSFontAttributeName) textSize = self.sizeWithAttributes(attributes) &#125; else &#123; let option = NSStringDrawingOptions.UsesLineFragmentOrigin let attributes = NSDictionary(object: font, forKey: NSFontAttributeName) let stringRect = self.boundingRectWithSize(size, options: option, attributes: attributes, context: nil) textSize = stringRect.size &#125; return textSize &#125;&#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>UILabel</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>UILabel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-UIKit-AppDelegate项目入口]]></title>
<url>../../../../../../../../2017/12/06/Swift-UIKit/Swift-UIKit-AppDelegate项目入口/</url>
    <content type="text"><![CDATA[AppDelegate.swift //import是导入文件的/库的关键字//UIKit是iOS中所有的控件的所在库文件import UIKit@UIApplicationMain //调用了OC中的UIApplicationMain函数;//UIApplicationMain是IOS应用程序的入口//UIApplacationMain:1.创建了一个UIApplication对象,代表当前应用程序.作用是用来检测当前应用程序状态的改变// 2.创建一个遵守UIApplicationDelegate的协议的子类对象作为UIApplication的代理,作用是处理应用程序状态的改变(创建AppDelegate对象并且设置为UIApplication对象的代理)class AppDelegate: UIResponder, UIApplicationDelegate &#123; //属性: var window: UIWindow? //方法: //一.当应用程序已经启动成功后,会自动调用这个方法 func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool &#123; // Override point for customization after application launch. //1.在这个方法中来搭建应用程序中的所有的界面 //2.获取应用程序需要展示的数据 //3.使用界面展示数据 //注意:如果不再做这个方法中去创建window,那么程序会通过Main.stroyboard去创建应用程序的界面 print("程序启动成功") return true &#125; //二.当应用程序将要成为非活跃状态的时候会自动调用这个方法. //活跃状态:程序在屏幕上可见 //非活跃状态:程序没有显示在屏幕上(按home键进入后台,来电打断,在当前应用程序中打开其他的应用程序) func applicationWillResignActive(application: UIApplication) &#123; //按下home键:command + shift + h //在这个方法中一般去暂停视频/音频播放;游戏需要暂停;保存数据 print("将要成为非活跃状态") &#125; //三.应用程序已经进入后台的时候会自动调用 //进入后台:按home键 func applicationDidEnterBackground(application: UIApplication) &#123; print("进入后台") &#125; //四.应用程序将要进入前台的时候会自动调用 //进入前台: func applicationWillEnterForeground(application: UIApplication) &#123; print("将要进入前台") &#125; //五.应用程序已经变成活跃状态的时候会自动调用 //1.程序启动成功后 //2.程序从后台重新进入前台 //3.来电打断结束... func applicationDidBecomeActive(application: UIApplication) &#123; print("已经变成活跃状态") &#125; //六.应用程序将要终止的时候会调用这个方法 func applicationWillTerminate(application: UIApplication) &#123; print("应用程序将要终止") &#125;&#125; ViewController.swift class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() //UIView:是IOS中所有视图(控件)直接/间接的父类;所以UIView的属性和方法,对于其他类型的视图都有效 //视图:在屏幕上能看到的所有的东西都属于视图 //一.创建UIView的对象 let redView = UIView.init() //想要将视图展示在屏幕上的两个必要条件 //1.必须设置坐标的大小(默认坐标是(0,0),大小(0,0,)) //2.将视图添加到已经展示在屏幕上的视图上 //二.设置frame属性(由坐标(x,y)和大小(width,height)两个部分组成) redView.frame = CGRect(x: 10, y: 10, width: 100, height: 100) //IOS中所有的结构体都有一个对应的Make方法用来快速的创建一个结构体变量 redView.frame = CGRectMake(10, 10, 100, 100) //三.将视图添加到界面上 self.view.addSubview(redView) //四.设置背景颜色 //视图的背景颜色默认是透明色 //颜色的创建方式: //1.通过类型方法创建指定颜色 // redView.backgroundColor = UIColor.redColor() //通过三原色来创建颜色 //CGFloat就是UI中的浮点型 //参数1,2,3:红,绿,蓝的值(0~1)-(0/255~255/255) //参数4:透明度 //redView.backgroundColor = UIColor(red: 149/255.0, green: 106/255.0, blue: 55/255.0, alpha: 1) //设置不同程度的灰色 //redView.backgroundColor = UIColor(white: 0.2, alpha: 1) //练习:创建一个黄色的矩形,显示在红色视图的中心位置,大小(50,50) //方式1: //创建视图对象并且设置frame属性 /* let yellowView = UIView.init() yellowView.frame = CGRectMake(35, 35, 50, 50) //添加到界面上 self.view.addSubview(yellowView) //设置背景颜色 yellowView.backgroundColor = UIColor.yellowColor() */ //方式2: let yellowView = UIView(frame: CGRectMake(25,25,50,50)) redView.addSubview(yellowView) yellowView.backgroundColor = UIColor.yellowColor() //GET:计算视图的坐标的时候,注意相对性.当前视图被添加到那个视图上,那么当前视图的坐标就是相对于谁来算的 &#125;&#125; 视图对象的基本属性 mport UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() //创建一个视图对象 let redView = UIView.init() //添加到界面上 self.view.addSubview(redView) //设置背景颜色 redView.backgroundColor = UIColor.redColor() //1.frame(坐标和大小) redView.frame = CGRectMake(100, 100, 100, 100) //2.center(中心点坐标) //通过frame和确定视图的中心点坐标 print(redView.center) print(redView.frame) redView.center = CGPointMake(200, 200) print(redView.frame) //3.bounds(坐标和大小) //默认情况下bounds的坐标(0,0),大小和视图的frame大小一样 print(redView.bounds) //了解: //如果改变bounds的大小,不改变center的坐标,改变frame的坐标和大小 /* redView.bounds = CGRectMake(0, 0, 200, 200) print(redView.frame) print("center\(redView.center)") */ //如果改变bounds的坐标,不影响当前视图的位置.但是影响添加到当前视图上的子视图的坐标,不建议修改bounds redView.bounds = CGRectMake(0, 0, 100, 100) let yellowView = UIView.init(frame:CGRectMake(10, 10, 40, 40)) yellowView.backgroundColor = UIColor.yellowColor() redView.addSubview(yellowView) //4.transform(形变) // 当前视图发生形变,那么添加到当前视图上的所有的视图会跟着一起形变 //1). 缩放 //参数1:x方向上的缩放比例 //参数2:y方向上的缩放比例 redView.transform = CGAffineTransformMakeScale(0.5, 0.5) //2).旋转 //参数:旋转角度(圆周率对应的角度) redView.transform = CGAffineTransformMakeRotation(CGFloat(M_PI_4)) //3).平移 //参数1:在x方向上平移的距离 //参数2:在y方向上平移的距离 redView.transform = CGAffineTransformMakeTranslation(0, 300) //4).多个形变同时进行 //在另外一个形变的前提下旋转 //参数1:另外一个形变 //在拥有缩放这个形变的前提下旋转(既可以缩放又可以旋转) redView.transform = CGAffineTransformRotate(CGAffineTransformMakeScale(0.5, 0.5), CGFloat(M_PI_4 / 2)) //在另外一个形变的前提下平移(既可以缩放和旋转又可以平移) redView.transform = CGAffineTransformTranslate(redView.transform, 0, 100) //既可以平移又可以缩放 redView.transform = CGAffineTransformScale(CGAffineTransformMakeTranslation(100, 0), 0.5, 2) //组合两个形变 //旋转形变 let rotate = CGAffineTransformMakeRotation(0.2) //平移形变 let transLation = CGAffineTransformMakeTranslation(100, 100) //将旋转形变和平移形变组合 redView.transform = CGAffineTransformConcat(rotate, transLation) &#125;&#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>UIKit</category>
        <category>AppDelegate</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>UIKit</tag>
        <tag>AppDelegate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-基础]]></title>
<url>../../../../../../../../2017/12/06/Swift-Grammar/Swift-Grammar-基础/</url>
    <content type="text"><![CDATA[语法打印print("Hello,Word!") 定义变量和常量 let/var在同一行代码中 不用书写分号 let myCount = 11 //定义一个常量为myCount = 11 常量是不可改变的量var myVariable = 22myVariable = 33 //定义一个变量为myVariable = 22 然后改变它的值,将33赋给myVariable。现在myVariable的值为33。 字符串插值打印 符串插值的是在print的过程中，将你定义的常量或变量插入你要输出的字符串中 print("ChenJian,\(myCount)!")print("YueKekui!\(myVariable)") 类型推断 在swift中 如果可以的话 尽可能省略类型标记，让swift自己推断类型 关于Swift中类型int，float，double相关的 Double(three) 和C语言的强制转换有很大区别Double(three) swift 中是将three这个数据的值取出来，从新定义一个Double类型的变量，并将Three的值赋这个变量 let three = 3let pointOneFourOneFiveNine = 0.14159let pi = Double(three) + pointOneFourOneFiveNine 元组 元组是用一个变量或常量，保存多项数据 let http404Error = (404, "Not Found")// http404Error is of type (Int, String), and equals (404, "Not Found") 下划线的意思 忽略这一项 let (justTheStatusCode, _) = http404Errorprint("The status code is \(justTheStatusCode)")// Prints "The status code is 404 运算符 运算符 可以分为一元运算符，二元运算符，三元运算符 一元运算符 数字前面代表数字正负的正负号是唯一的一元运算符 -8,-14,+8(正数我们一般省略前面的正号写为：8) 二元运算符 赋值运算符 let b = 10var a = 5a = b// a is now equal to 10 关系运算符 1 == 1 2 != 1 2 &gt; 1 1 &lt; 2 1 &gt;= 1 2 &lt;= 1 算术运算符：加减乘除取余 1 + 2 // equals 35 - 3 // equals 22 * 3 // equals 610.0 / 2.5 // equals 4.0 9 % 2 // equals 1 三元运算符 //让c 取a 和b中较小的值let a =5 , b=10let c = a &lt; b ? a : b//问号前面是一个产生Bool类型的变量，常量或表达式 Parentheses 圆括号的作用 可以使用圆括号改变运算顺序 ，如果不清楚运算的执行程序也可以直接使用圆括号来改变运算顺序 容器类型-数组 数组是一个有序的集合数组的第一个元素的下标是从0开始的 而不是1 var threeDoubles = [Double](count: 3, repeatedValue: 0.0)var array1 = [Int]()var array2: [Int] = []var array3 = [99,12,34,156,7]var array4 = [Int](count: 100, repeatedValue: 1)var arrayString1 = [String]()var arrayString2: [String] = []var arrayString3 = ["abc","def","ghi","apple","orange"]var arrayString4 = [String](count: 100, repeatedValue: "") 两个数组可以相加 var anotherThreeDoubles = [Double](count: 3, repeatedValue: 2.5)// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5] var sixDoubles = threeDoubles + anotherThreeDoubles// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2. 向数组中添加元素的方法 shoppingList.append("Flour")//可以使用append这个函数shoppingList += ["Baking Powder"]// shoppingList now contains 4 itemsshoppingList += ["Chocolate Spread", "Cheese", "Butter"]//也可以用+=向数组中添加一个或多个元素 对数组进行遍历（迭代） let shoppingList = ["Six egg","Milk","Flour","Baking Powder","Bananas"]for item in shoppingList &#123; print(item)&#125;for (index, value) in shoppingList.enumerate() &#123; print("Item \(index + 1): \(value)")&#125;// Item 1: Six eggs// Item 2: Milk// Item 3: Flour// Item 4: Baking Powder// Item 5: Bananas”作者：芒果微笑链接：http://www.jianshu.com/p/8e8ff60121c4來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 控制流程##顺序结构 ,程序按正常顺序执行。 ##分支结构 ##循环结构 //循环 //第一种循环import Foundationvar i = 1while i &lt;= 10 &#123; print("\(i)") print("Hello, World!") i += 1//i++&#125; //第二种循环 这种循环和上一种循环主要的区别是 --repeat循环至少执行一次var i = 1repeat&#123; print("\(i).Hello,Word") i += 1&#125;while i &lt;= 100 //第三种循环for i in 1...10&#123; print("\(i).Hello,World!")&#125;// 不想用循环变量 i可以使用 _ 来省略i 猜数字 题目要求：书写一段Swift代码实现，随机出现一个1-100的数字，让用户猜这个数字是几，每次提示用户猜的数字是比实际数字大还是小，直到用户猜中为止 let answer = Int(arc4random_uniform(100)) + 1var thyAnswer:Intvar counter = 0repeat&#123; counter += 1 print("请输入你猜的数字：",terminator:"") thyAnswer = inputInt() if thyAnswer &gt; answer&#123; print("猜小一点") &#125; else if thyAnswer &lt; answer&#123; print("猜大一点") &#125; else&#123; print("恭喜你猜对了！您一共猜了\(counter)次") &#125;&#125;while thyAnswer != answerif counter &gt; 7&#123; print("你的智商该充值了！！！")&#125; 得出1-100的素数 //得出1-100的素数func isPrime(n: Int) -&gt; Bool&#123; var i = 2 while i &lt;= Int(sqrt(Double(n)))&#123; if n % i == 0&#123; return false &#125; i += 1 &#125; //如果上面的循环没有返回false 就说明在2到n开根号之间没有n的因子 因此返回true 表示n是素数 return true&#125;for n in 1...100&#123; if isPrime(n)&#123; print(n) &#125;&#125; 百钱白鸡 题目要求：现在有100块钱，公鸡5块一只，母鸡3块一只，小鸡1块三只，现在要用这100块买100只鸡，问公鸡，母鸡，小鸡各有多少只？ for x in 0...20&#123; for y in 0...33&#123; let z = 100 - x - y if 5 * x + 3 * y + z / 3 == 100 &amp;&amp; z % 3 == 0 &#123; print("公鸡：\(x),母鸡:\(y),小鸡\(z)") &#125; &#125;&#125;// GET:穷举法（穷尽所有的可能性直到正确答案 摇色子游戏 题目要求：现有两人，一个玩家，一个庄家。玩家摇两个色子，如果第一次摇到7，11点玩家胜，摇到2，3，12庄家胜，摇到其他点数记住这个点数并继续摇下一次；以后每次玩家摇色子的点数和第一次记住的点数相同玩家胜，摇到7点庄家胜。用swift代码实现以上要求 func roll() -&gt; Int&#123; return Int(arc4random_uniform(6)) + 1&#125;var money = 1000repeat&#123; print("玩家总资产:￥\(money)元") var debt:Int repeat&#123; print("请下注:",terminator:"") debt = inputInt() &#125;while debt &lt;= 0 || debt &gt; money var needsGoOn = false let fristPoint = roll() + roll() print("玩家摇出了\(fristPoint)") switch fristPoint&#123; case 7,11: money += debt print("玩家胜!!!") case 2,3,12: money -= debt print("庄家胜!!!") default: needsGoOn = true //游戏继续 &#125; while needsGoOn&#123; let currentPoint = roll() + roll() print("玩家摇出了\(currentPoint)") if currentPoint == 7 &#123; money -= debt print("庄家胜!!!") needsGoOn = false &#125; else if currentPoint == fristPoint&#123; money += debt print("玩家胜!!!") needsGoOn = false &#125; &#125;&#125;while money &gt; 0print("你破产了！！！！") 排序选择 题目要求：一个数组中无序的数字，使用简单选择排序法排序。ps：简单选择排序:每次从剩下元素中找最小的元素放到对应的位置 var array = [27,45,78,58,44,89,12,5]for i in 0..&lt;array.count - 1&#123; var mindex = i for j in i+1..&lt;array.count&#123; if array[j] &lt; array[mindex]&#123; mindex = j &#125; &#125;(array[i],array[mindex]) = (array[mindex],array[i])&#125;print(array) 冒泡排序 题目要求：一个数组中无序的数字，使用冒泡排序法排序。ps:冒泡排序：两个数字排序将大的数字排在后面 var array = [27,45,78,58,44,89,12,5]for i in 0..&lt;array.count - 1&#123; var swapped = false for j in 0..&lt;array.count - 1 - i&#123; if array[j] &gt; array[j+1]&#123; (array[j],array[j+1]) = (array[j+1],array[j]) swapped = true &#125; &#125; if swapped == false // if !swapped &#123; break &#125;&#125;print(array) 字典和集合 //字典(存放键值对组合的容器)//字典中的每个元素都是由两部分构成,冒号前面的是键，冒号后面的是值var dict:[String:String] = ["abacus":"算盘","abnormal":"异常的","hello":"你好","good":"好的"]//print 前面的键 就会输出后面的值//但是print 后面的值 不会输出前面的键print(dict["hello"]!)print(dict["abcxyz"])print(dict["你好"])// 添加元素dict["shit"] = "狗屎"dict["delicious"] = "好吃的"print(dict)// 删除元素 dict.removeValueForKey("hello") //第一种dict["hello"] = nil //第二种print(dict)print(dict["hello"])// 修改元素dict["shit"] = "牛粪"print(dict)// 遍历字典中所有的值for value in dict.values &#123; print(value)&#125;// 遍历字典中所有的键for key in dict.keys &#123; print("\(key) ---&gt; \(dict[key])")&#125;// 直接通过一个元组获得字典中的键和值(原始类型)for (key, value) in dict &#123; print("\(key) ---&gt; \(value)")&#125; 集合 集合中两个值相同的元素，会合并到一起 var a: Set&lt;Int&gt; = [1, 2, 3, 1, 2, 5]a.insert(100) // 添加元素a.remove(2) // 删除元素print(a)var b: Set&lt;Int&gt; = [3, 5, 7, 9, 11]print(b)print(a.intersect(b)) // 交集(a和b都有的元素)print(a.union(b)) // 并集(a和b的所有元素)print(a.subtract(b)) // 差集(a有b没有的元素)print(a == b)print(b.isSubsetOf(a))let c: Set&lt;Int&gt; = [1, 3]print(c.isSubsetOf(a)) // 判断c是不是a的子集print(a.isSupersetOf(c)) // 判断a是不是c的超集let d: Set&lt;Int&gt; = [2, 1000, 10000]print(a.isDisjointWith(d)) // 判断两个集合是否相交 函数 函数我认为是swift语言中最重要的章节之一。定义函数的关键词为func // 函数的参数名// 函数名(外部参数名 内部参数名: 类型, 外部参数名 内部参数名: 类型)// 如果不写外部参数名那么内部参数名也是外部参数名// 可以使用_来作为外部参数名表示省略外部参数名func myMin(a x: Int, b y: Int) -&gt; Int &#123; return x &lt; y ? x : y&#125;// 调用函数的时候要写函数的外部参数名print(myMin(a: 3, b: 5))// 定义函数// func 函数名(参数列表) -&gt; 返回类型 &#123; 函数的执行体 &#125;// Swift中函数的参数可以设定默认值// 如果调用函数的时候没有给该参数赋值就直接使用默认值func sayHello(personName: String, alreadyGreeted: Bool = false) -&gt; String &#123; // let greeting = "Hello, " + personName + "!" // 如果函数的返回类型不是Void 那么函数中一定有return语句 // return greeting // personName = "王小锤" // 编译错误 if alreadyGreeted &#123; return "怎么又是你, " + personName + "!" &#125; else &#123; return "你好, " + personName + "!" &#125;&#125;// 调用函数// 函数名(参数值)// 调用Swift的函数时, 在默认情况下从第二个参数开始需要写参数名print(sayHello("王大锤", alreadyGreeted: true))// 如果没有给第二个参数赋值那么就直接使用默认值falselet str = sayHello("Jack")print(str)// Swift中函数的参数列表可以是可变参数列表(参数的个数是任意多个)func sum(nums: Int...) -&gt; Int &#123; var total = 0 for num in nums &#123; total += num &#125; return total&#125;print(sum())print(sum(999))print(sum(1, 2, 3))print(sum(90, 82, 37, 68, 55, 11, 99))// 可以使用元组(tuple)让函数一次返回多条数据func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123; if array.count == 0 &#123; return nil &#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;if let b = minMax([23, 45, 99, 68, 72, 12, 55]) &#123; print(b.min) // print(b.0) print(b.max) // print(b.1)&#125;else &#123; print("数组中没有元素!!!")&#125;func swap(inout a: Int, inout _ b: Int) -&gt; Void &#123; (a, b) = (b, a)// let temp = a// a = b// b = temp&#125;var a = 300, b = 500swap(&amp;a, &amp;b)print("a = \(a)")print("b = \(b)")// inout - 输入输出参数(不仅将数据传入函数还要从函数中取出数据)func createX(inout x: Int) &#123; x = 1000&#125;var x = 1// inout类型的参数前要加上&amp;符号createX(&amp;x)print(x) // 设计一个函数根据系统时间返回不同的问候语func sayHello(name: String) -&gt; String &#123; let date = NSDate() let cal = NSCalendar.currentCalendar() let hour = cal.component(.Hour, fromDate: date)//这三句代码的意思为：第一句 获取当前系统时间 //第二句是 当前历法//第三句是 当前小时 var greeting: String switch hour &#123; case 0...6: // 不同的分支可以有重叠的部分 greeting = "滚去碎觉了" // fallthrough // 继续执行下一个case case 4...10: // 匹配了一个分支之后不再匹配其他的分支 greeting = "早起的鸟儿有虫吃" case 11...13: greeting = "中午好" case 14...18: greeting = "下午好" default: greeting = "晚上好" &#125; return name + ", " + greeting + "!"&#125;print(sayHello("小刚"))// 设计一个函数传入两个正整数m和n, 计算从m加到n的和func sum(m: Int, _ n: Int) -&gt; Int &#123; let (a, b) = m &gt; n ? (n, m) : (m, n) var value = 0 for i in a...b &#123; value += i &#125; return value&#125;print(sum(1, 100))print(sum(5, -4))print(sum(-1, -5)) 调用苹果自身的Api，进行程序应用开发调用苹果的指纹识别，开发一个带有指纹识别的支付功能的app class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let errPointer = NSErrorPointer() let ctx = LAContext() // 判断设备是否支持指纹识别 if ctx.canEvaluatePolicy(.DeviceOwnerAuthenticationWithBiometrics, error: errPointer) &#123; // z = f(x, g(y)) // Swift中允许将一个函数作为另一个函数的参数 // evalutePolicy方法的第三个参数是一个函数 // 该函数有两个参数没有返回值 // 给该参数传参时可以在花括号中写一个匿名函数传进去 // 该匿名函数通常也称之为闭包(closure) ctx.evaluatePolicy(.DeviceOwnerAuthenticationWithBiometrics, localizedReason: "请输入指纹进行支付", reply: &#123; (isOK, err) -&gt; Void in if isOK &#123; print("支付成功!!!") &#125; else &#123; print("指纹验证失败, 请输入支付密码") &#125; &#125;) &#125; else &#123; print("你的设备不支持指纹识别") &#125; &#125;&#125; 闭包 闭包也称：匿名函数 意思是没有名字的函数闭包由来：在swift中函数也是一种类型这也就意味着函数可以作为变量或常量的类型同理函数也可以作为另一个函数和参数或返回值 func sum(a: Int, _ b: Int) -&gt; Int &#123; return a + b&#125;func mul(a: Int, _ b: Int) -&gt; Int &#123; return a * b&#125;func foo(array: [Int], fn: (Int, Int) -&gt; Int) -&gt; Int &#123; var sum = array[0] for x in array[1..&lt;array.count] &#123; sum = fn(sum, x) &#125; return sum&#125; 由于在swift中能省则省的原则和传统就将调用函数做了以下几步写法省略 let a = [1, 2, 3, 4, 5]// 当调用foo函数时第二个参数可以传什么?// 1. 所有自定义的(Int, Int) -&gt; Int类型的函数print(foo(a, fn: sum))// 2. 传入已有的二元运算符: +-*/%(因为运算符也是函数)print(foo(a, fn: +))// 3. 传入匿名函数(闭包)// 3.1 完整的闭包写法print(foo(a, fn: &#123; (a, b) -&gt; Int in return a + b&#125;))// 3.2 省略掉类型和不必要的括号print(foo(a, fn: &#123; a, b in a + b &#125;))// 3.3 省略参数名print(foo(a, fn: &#123; $0 + $1 &#125;))// 3.4 尾随闭包print(foo(a) &#123; (a, b) -&gt; Int in return a + b&#125;)print(foo(a) &#123; $0 + $1 &#125;) 需要注意的是：如果函数的最后一个参数是闭包可以写成尾随闭包的形式也就是将闭包放到函数参数的圆括号外面写在一对花括号中如果函数后面有尾随闭包且函数的圆括号中没有参数那么函数的圆括号也可以省略(仅限于有尾随闭包的场景）例如 var array = ["game", "abacus", "hello", "cat", "good", "internationalization", "chaos", "dislike", "zealot", "young"]// array.sortInPlace(&gt;)array.sortInPlace(&#123; $0 &gt; $1 &#125;)array.sortInPlace() &#123; $0 &gt; $1 &#125;array.sortInPlace &#123; $0 &gt; $1 &#125; //这就是尾随闭包的最简写法 数组最重要的三个功能 1.过滤 2.映射 3.缩减 let array = [23, 37, 96, 55, 40, 92, 68, 88]// 1. 过滤let newArray1 = array.filter &#123; $0 &gt; 50 &#125; //找到数组中比50大的数输出出来print(newArray1)let newArray2 = array.filter &#123; $0 % 2 == 0 &#125; //找到数组中得偶数print(newArray2)// 2. 映射let newArray3 = array.map &#123; $0 * $0 &#125; //将数组中的每个数平方print(newArray3)let newArray4 = array.map &#123; sqrt(Double($0)) &#125; //将数组中得每个数开根号print(newArray4)// 3. 缩减let result1 = array.reduce(0, combine: +)// 将数组中的每个数想加print(result1)let result2 = array.reduce(1, combine: *)//将数组中的每个数相乘print(result2)let result3 = array.reduce(array[0]) &#123; //取数组中最大的数 $1 &gt; $0 ? $1 : $0&#125;print(result3)let strArray = ["I", "love", "you"]let result4 = strArray.reduce("") &#123; $0 + " " + $1 &#125;//将数组中的三个元素合为一个print(result4) 类 类和上文提到的函数 紧密相关类是一类事物 而对象是这类事物中具体的实例 步骤1: 定义类(如果你要用的类苹果已经提供了就直接进入第2步) 定义类就可以创建出新的类型 学生类class Student &#123; // 变量定义到类的外面就叫变量 - variable // 变量定义到类的里面就叫属性 - property // 数据抽象 - 找到和学生相关的属性(找名词) var name: String var age: Int // 初始化方法(构造方法/构造器) - constructor init(name: String, age: Int) &#123; self.name = name self.age = age &#125; // 函数写到类的外面就叫函数 - function // 函数写到类的里面就叫方法 - method // 行为抽象 - 找到和学生相关的方法(找动词) func eat() &#123; print("\(name)正在吃饭.") &#125; func study(courseName: String) &#123; print("\(name)正在学习\(courseName).") &#125; func watchJapaneseAV() &#123; if age &gt;= 18 &#123; print("\(name)正在动作片.") &#125; else &#123; print("亲爱的\(name), 我们推荐你观看《熊出没》") &#125; &#125;&#125;// 步骤2: 创建对象(调用初始化方法)let stu1 = Student(name: "小刚", age: 35)// 步骤3: 给对象发消息(通过给对象发消息来解决问题)stu1.eat()stu1.study("Swift程序设计")stu1.watchJapaneseAV()let stu2 = Student(name: "王大锤", age: 15)stu2.eat()stu2.study("中国近代史")stu2.watchJapaneseAV() 下面定义一个圆的类类里面有求圆的面积和周长的方法（函数） // 0. 发现类// - 在对问题的描述中找名词和动词// - 名词会成为类或者类中的属性 动词会成为类中的方法// 1. 定义类// - 数据抽象(属性)// - 行为抽象(方法)// - 初始化方法// 访问修饰符// - public (公开)// - internal (内部的) - 默认// - private (私有)class Circle &#123; // stored property // 存储属性(保存和圆相关的数据的属性) var center: Point var radius: Double init(center: Point, radius: Double) &#123; self.center = center self.radius = radius &#125; // 通常获得某个计算出的值的方法都可以设计成计算属性 // computational property // 计算属性(通过对存储属性做运算得到的属性) var perimeter: Double &#123; // 圆的周长是一个只读属性 // 所以此处只有get&#123;&#125;没有set&#123;&#125; get &#123; return 2 * M_PI * radius &#125; &#125; var area: Double &#123; get &#123; return M_PI * radius * radius &#125; &#125;&#125;注意：运算符重载```swift//运算符重载（为自定义的类型定义运算符）func +(one: Fraction, two: Fraction) -&gt; Fraction &#123; return one.add(two)&#125;func -(one: Fraction, two: Fraction) -&gt; Fraction &#123; return one.sub(two)&#125;func *(one: Fraction, two: Fraction) -&gt; Fraction &#123; return one.mul(two)&#125;func /(one: Fraction, two: Fraction) -&gt; Fraction &#123; return one.div(two)&#125; 继承 // 继承: 从已有的类创建新类的过程// 提供继承信息的称为父类(超类/基类)// 得到继承信息的称为子类(派生类/衍生类)// 通常子类除了得到父类的继承信息还会增加一些自己特有的东西// 所以子类的能力一定比父类更强大// 继承的意义在于子类可以复用父类的代码并且增强系统现有的功能class Teacher: Person &#123; var title: String init(name: String, age: Int, gender: Gender, title: String) &#123; self.title = title super.init(name: name, age: age, gender: gender) &#125; func teach(courseName: String) &#123; print("\(name)\(title)正在教\(courseName).") &#125;&#125;//父类和子类关系let p1 = Person(name: "王大锤", age: 25, gender: .Male)p1.eat()// 可以将子类型的对象赋值给父类型的变量(因为子类跟父类之间是IS-A关系)// 学生是人, 老师是人, 所以学生和老师的对象可以赋值给人类型的变量let p2: Person = Student(name: "张尼玛", age: 18, gender: .Female, major: "计算机科学与技术")p2.eat()// 如果要将父类型的变量转换成子类型需要用as运算符进行类型转换// 如果能够确认父类型的变量中就是某种子类型的对象可以用as!进行转换// 如果不确定父类型的变量中是哪种子类型可以用as?尝试转换(p2 as! Student).study("Swift程序设计")if let temp = p2 as? Teacher &#123; temp.teach("Java")&#125;else &#123; print("\(p2.name)不是老师!!!")&#125;let p3: Person = Teacher(name: "骆昊", age: 35, gender: .Male, title: "叫兽")p3.eat() 多态 同样的对象类型(pet类型)接受了相同的消息(调用了相同的方法)但是做了不同的事情 这就是多态(polymorphism)例如：猫(cat)继承它的父类动物(pet) / Cat和Pet之间是IS-A关系(继承)class Cat: Pet &#123; var hairColor: String? // 父类有的方法子类可以重新实现 这个过程叫方法重写 // 需要在方法前添加override关键字 // 重写有时也被称为置换/覆盖/覆写 override func play() &#123; super.play() print("\(nickname)正在玩毛线球.") &#125; override func shout() &#123; print("\(nickname): 喵喵喵……") &#125; func catchTheMouse() &#123; print("\(nickname)正在抓老鼠.") &#125;&#125; 对父类的方法可以重新实现， 这个过程叫方法重写这是实现多态的重要步骤之一！下面是实现多态的第二个步骤： let petsArray = [ Cat(nickname:"加菲",gender: .Male,age:2), Dog(nickname: "吉娃娃", gender: .Male, age: 3, isLarge: false), Dog(nickname: "大黄", gender: .FeMale, age: 2, isLarge: true), Mistress(nickname: "小花",gender: .FeMale,age:16)]for pet in petsArray&#123; pet.eat() // 同样的对象类型(pet类型)接受了相同的消息(调用了相同的方法) // 但是做了不同的事情 这就是多态(polymorphism) // 实现多态的关键步骤： // 1.方法的重写(子类在继承父类的过程中对父类已有的方法进行重写,而且不同的子类给出各自不同的实现版本) // 2.对象造型(将子类对象当成父类型来使用) pet.play() pet.shout() // 如果dog是属于pet中 如果dog是Dog类型就可以调用keepTheDoor这个特有的方法 if let dog = pet as? Dog&#123; dog.keepTheDoor() &#125; else if let cat = pet as? Cat&#123; cat.catchTheMouse() &#125; else if let mistress = pet as? Mistress&#123; mistress.makeTrouble() &#125;&#125;//枚举enum Gender&#123; case Male case FeMale &#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-网速实时显示]]></title>
<url>../../../../../../../../2017/12/06/iOS-Func/iOS-Func-网速实时显示/</url>
    <content type="text"><![CDATA[原理：通过函数getifaddrs来得到系统网络接口的信息，网络接口的信息, 包含在if_data字段中, 有很多信息, 但我现在只关心ifi_ibytes, ifi_obytes, 应该就是接收到的字节数和发送的字节数, 加起来就是流量了. 还发现, 接口的名字, 有en, pdp_ip, lo等几种形式, en应该是wifi, pdp_ip大概是3g或者gprs, lo是环回接口, 通过名字区分可以分别统计 #include &lt;ifaddrs.h&gt;#include &lt;sys/socket.h&gt;#include &lt;net/if.h&gt;+ (long long) getInterfaceBytes&#123; struct ifaddrs *ifa_list = 0, *ifa; if (getifaddrs(&amp;ifa_list) == -1) &#123; return 0; &#125; uint32_t iBytes = 0; uint32_t oBytes = 0; for (ifa = ifa_list; ifa; ifa = ifa-&gt;ifa_next) &#123; if (AF_LINK != ifa-&gt;ifa_addr-&gt;sa_family) continue; if (!(ifa-&gt;ifa_flags &amp; IFF_UP) &amp;&amp; !(ifa-&gt;ifa_flags &amp; IFF_RUNNING)) continue; if (ifa-&gt;ifa_data == 0) continue; /* Not a loopback device. */ if (strncmp(ifa-&gt;ifa_name, "lo", 2)) &#123; struct if_data *if_data = (struct if_data *)ifa-&gt;ifa_data; iBytes += if_data-&gt;ifi_ibytes; oBytes += if_data-&gt;ifi_obytes; &#125; &#125; freeifaddrs(ifa_list); NSLog(@"\n[getInterfaceBytes-Total]%d,%d",iBytes,oBytes); return iBytes + oBytes;&#125; 资料01]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-内存泄漏问题]]></title>
<url>../../../../../../../../2017/12/06/iOS-Func/iOS-Func-内存泄漏问题/</url>
    <content type="text"><![CDATA[AFHTTP 内存泄漏问题 AFHTTP 框架的通病。这个问题很常见，也最好解决，网上也有不少的解决方案主流的解决方案就是使用单例。定义一个单例对象 SessionManager： @interface SessionManager : NSObject@property(nonatomic,strong)AFHTTPSessionManager *manager;+(SessionManager *)share;@end@implementation SessionManager+(SessionManager *)share&#123; static SessionManager *shareObj = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; shareObj = [[SessionManager alloc] init]; AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; /** 设置超时*/ [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"]; manager.requestSerializer.timeoutInterval = 10; [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"]; shareObj.manager = manager; &#125;); return shareObj;&#125;@end 使用SessionManager AFHTTPSessionManager* manager = [SessionManager share].manager;manager.requestSerializer = [AFHTTPRequestSerializer new];…… 环信 UI 框架中的内存泄漏问题 环信框架中，有一个对 UIViewController 的扩展（Category） :UIViewController+HUD，它对 MBHUD 进行了二次封装，通过它可以使你的 MBHUD 的调用变得更简单，比如显示一个 HUD 你可以这样： [self showHudInView:self.view hint:@""]; 但是这个方法中有一个严重的内存泄漏问题。当你在一个 View Controller 中多次显示 HUD 之后（比如反复下拉刷新表格），用视图调试器查看 UIView，你会发现视图树中显示了多个 HUD 对象。也就是说每次 showHudInView 之后都会重新生成一个新的 HUD，而原来的 HUD 虽然被隐藏了，但它们在内存中仍然是持续存在的。每次 showHudInView 调用大概会导致 400-500 k 的内存泄漏。如果你反复刷新表格（比如 5 分钟或更长）直到内存撑爆，app 崩溃解决的方法很简单，在 showHudInView 方法中加入一句： HUD.removeFromSuperViewOnHide = YES; O-C 块中对 self 强引用导致的内存泄漏问题 在 View Controller 类的 O-C 块中，如果你直接引用了 self，则会导致 View Controller 被强引用（因为块的参数都是以 copy 引用的，会导致 retained count 加 1）。这样，当 View Controller 被 pop 出导航控制器栈后不会被释放，导致内存泄漏。这个泄漏就比较严重了，少则几百 K,多则几兆 一个比较明显的例子就是 MJRefresh。在 View Controller 中，如果我们想支持下拉刷新，通常会这样使用 MJRefresh： self.tableView.mj_header=[MJRefreshNormalHeader headerWithRefreshingBlock:^&#123; [self.tableView.mj_header endRefreshing]; currentPage = 1; [self loadNoticeList:1 success:^(NSArray&lt;CampusNoticeModel *&gt; *data) &#123; [self.models removeAllObjects]; [self.models addObjectsFromArray:data]; [self.tableView reloadData]; &#125; failure:^(NSString *msg) &#123; &#125;]; &#125;]; 注意，O-C 块中对 View Controller 进行了强引用，比如：self.tableView 和 self.models。原则上，当我们在 O-C 块中引用 self 时，应当使用弱引用，比如上面的代码应当改为： __weak __typeof(self) weakSelf=self; self.tableView.mj_header=[MJRefreshNormalHeader headerWithRefreshingBlock:^&#123; [weakSelf.tableView.mj_header endRefreshing]; currentPage = 1; [weakSelf loadNoticeList:1 success:^(NSArray&lt;CampusNoticeModel *&gt; *data) &#123; [weakSelf.models removeAllObjects]; [weakSelf.models addObjectsFromArray:data]; [weakSelf.tableView reloadData]; &#125; failure:^(NSString *msg) &#123; &#125;]; &#125;]; 也就是将 OC 块中所有的 self 改成 weakSelf。这里有一个例外，如果引用的是实例变量而不是属性，原则上是不需要 weakSelf 的。比如 currentPage 在 View Controller 中是以实例变量形式定义的（也就是说没有用 @property 进行声明），那么我们不需要通过 weakSelf 来进行引用但是，如果你在项目中使用 MLeaksFinder 来检测内存泄漏时，MLeaksFinder 仍然会认为 O-C 块中对 currentPage 的引用存在问题。因此，为了让 MLeaksFinder 彻底“闭上嘴”，我们最好也将 currentPage 修改为属性（使用 @property 声明），然后将 O-C 块中的引用方式修改为：weakSelf.currentPage CADisplayLink 导致的内存泄漏 在使用 CADisplayLink 时，如果不释放 CADisplayLink，很容易出现内存泄漏。以自定义 UIView 为例，我们会使用定时器进行某些自定义的绘图和动画操作。这时我们会用到 CADisplayLink displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(animateDashboard:)]; 当我们需要开启定时器时，可以将它添加到 runloop： [displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; 但是 displayLink 会持有 UIView 对象，导致 UIView 永远不会被释放。因此我们需要在一个适当的时机释放 displayLink，比如在 CADisplayLink 的 action 方法中根据一定的条件来 invalidate 它： -(void)animateDashboard:(CADisplayLink *)sender&#123; if( endValue &lt;= self.value)&#123;// 到达终点值，停止动画 ...... [displayLink invalidate]; ...... &#125;else&#123; ...... &#125;&#125; 另外，CADisplayLink 最好不要复用。也就是说，每次启动 CADisplayLink 时都重新初始化并将它添加到 runloop，而每次停止动画时都 invalidate： -(void)animating&#123; if(_stopped == YES)&#123; displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(blink:)]; [displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; _stopped = NO; [self setNeedsDisplay]; &#125;&#125;-(void)stopAnimating&#123; if(_stopped == NO)&#123; [displayLink invalidate]; _stopped = YES; &#125;&#125; reloadRowsAtIndexPaths 导致的内存泄漏 UITableView 的 reloadRowsAtIndexPaths 的行为非常奇怪，在刷新 cell 时，它并不会重用原有的 cell，而是重新创建新的 cell 覆盖在原来的 cell 上，这会导致额外的内存开销。当重复多次调用 reloadRowsAtIndexPaths 之后，你可以在视图调试器中看下效果：无论你用不用 beginUpdates/endUpdates，结果都是一样。解决的办法目前只有一个，不要用 reloadRowsAtIndexPaths，而是使用 reloadData，当然会有一点性能上的代价，但也是没有办法的事情 定时器导致的内存泄漏问题 有时候 NSTimer （尤其是 repeated 为 YES 时）会导致内存泄漏问题。因为定时器是在另外一个线程中运行的，当界面消失后，定时器仍然还在运行，如果在定时器任务中引用了 UI 元素，则这些视图都会被强引用，从而导致界面消失后 view 无法释放，导致内存泄漏。因此，如果在你的 UIViewController 中使用了定时器，一定要记得在 viewWillDisappear 方法中 invalidate 它 addScriptMessageHandler 导致的内存泄漏 WKUserContentController 的 addScriptMessageHandler 方法会导致一个对 handler 对象的强引用，从而导致 handler （通常是 webView 所在的 ViewController）不会被释放，于是内存泄漏。解决的办法是 removeScriptMessageHandlerForName。根据官方文档，当你 addScriptMessageHandler 之后，需要在不再需要 handler 时，需要调用 removeScriptMessageHandlerForName 解除 handler 的强引用。问题在于，“当你不在需要它的时候”到底是什么时候？我们一般会在 viewDidLoad 中 addScriptMessageHandler，按道理应该在 dealloc 中 removeScriptMessageHandlerForName。但由于内存都已经泄漏了，ViewContoller 的 dealloc 根本不会调用，这个方法是无效的。解决的办法有两个，一个是将 addScriptMessageHandler 放到 viewDidAppear 中执行，那么我们就可以在 viewDidDisappler 中 removeScriptMessageHandlerForName 了。另一个方法是将 handler 弱引用。这需要新建一个类，创建一个弱引用的属性，用这个属性来包装 handler 对象： @interface WeakScriptMessageDelegate : NSObject&lt;WKScriptMessageHandler&gt;// 1@property (nonatomic, weak) id&lt;WKScriptMessageHandler&gt; scriptDelegate;- (instancetype)initWithDelegate:(id&lt;WKScriptMessageHandler&gt;)scriptDelegate;@end@implementation WeakScriptMessageDelegate- (instancetype)initWithDelegate:(id&lt;WKScriptMessageHandler&gt;)scriptDelegate&#123; self = [super init]; if (self) &#123; _scriptDelegate = scriptDelegate; &#125; return self;&#125;// 2- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123; [self.scriptDelegate userContentController:userContentController didReceiveScriptMessage:message];&#125;@end 这个属性就是用来弱引用 handler 的属性，它保存了一个对 handler 的弱引用。类型是 id，因为 addScriptMessageHandler 方法需要一个 WKScriptMessageHandler 对象作为参数 这个对象对 WKScriptMessageHandler 进行了封装，它同样实现了 WKScriptMessageHandler 协议，这个协议中有一个唯一的方法需要实现，即 userContentController 方法。在方法内部，我们可以直接调用 handler 的同名方法实现（因为二者的行为是一致的） 使用 / 将 handler 转换成一个若引用的 handler,从而避免内存泄漏WeakScriptMessageDelegate* weakHandler = [[WeakScriptMessageDelegate alloc] initWithDelegate:handler];[webView.configuration.userContentController addScriptMessageHandler:weakHandler name:methodName]; MLeaksFinder 内存泄漏问题多种多样，它们经常以出乎人意料的形式存在，我们无法以一种固定的模式来判断 app 中存在的内存泄漏问题。我们常常需要使用多个工具和手段来检查 app 中的内存问题，比如可以用 Xcode 的 Analyze 工具对代码进行静态语法分析，用 Instrument 的 Leaks/Allocations 工具进行动态内存检查分析，用视图调试器查看 UI 问题等等。 但我们还可以用许多第三方内存泄漏检测框架，比如：MLeaksFinder 和 HeapInspector-for-iOS，尤其是前者（后者目前会导致 App “冻死”的问题，作者还在解决这个问题）。 MLeaksFinder 是一个专门用于检测 UI 类内存泄漏的工具，我们可以利用它来检测 UIViewController 和 UIView 中未 dealloc 的 subview。 它的使用非常简单，直接 pod MLeaksFinder，然后找到 MLeaksFinder.h 头文件，将其中的 MEMORY_LEAKS_FINDER_ENABLED 宏和 MEMORY_LEAKS_FINDER_RETAIN_CYCLE_ENABLED 宏打开（设置为 1）就可以了。 编译运行 app，测试各种操作，切换到不同的 view controller，当 MLeaksFinder 发现内存泄漏会弹出一个 alert（同时控制台会有输出），告诉你哪个类和 UIView 中存在内存泄漏（以及循环持有）]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-NSSet]]></title>
<url>../../../../../../../../2017/12/06/iOS-Garmmar/iOS-NSSet/</url>
    <content type="text"><![CDATA[NSSet初始化 NSSet是无序的注意:这个是最为重要的功能 NSSet中不能够存储重复的数据,可以用它来去除重复的值 NSString * str1 = @"one"; NSString * str2 = @"two"; NSString * str3 = @"three"; NSSet * set = [[NSSet alloc] initWithObjects:str1,str2,str3,str1, nil]; 这样其实在set中指存储了 @“one”,@“two”,@“three” set.count 值为3[set containsObject:str1]; 是否包含str1 遍历NSEnumerator * enumerator = [set objectEnumerator]; NSString * value; while (value = [enumerator nextObject]) &#123; NSLog(@"value %@",value); &#125; 可变集合NSMutableSet 创建一个可变集合 NSMutableSet * muSet = [[NSMutableSet alloc] init]; 增加值 [muSet addObject:str1]; 删除 [muSet removeObject:str1]; 删除所有 [muSet removeAllObjects]; 集合之间相互转换 NSArray 转换成 NSMutableArray NSArray * array = @[@"one",@"two",@"three"];NSMutableArray * muArray = [NSMutableArray arrayWithArray:array]; NSDictionary 转换成 NSMutableDictionary NSDictionary * dic = @&#123;@"one":@"1",@"two":@"2"&#125;;NSMutableDictionary * muDic = [NSMutableDictionary dictionaryWithDictionary:dic]; NSSet 转换成 NSMutableSet NSSet * set = [[NSSet alloc] initWithObjects:@"one",@"two", nil];NSMutableSet *muSet = [NSMutableSet setWithSet:set]; NSArray 转换成NSSetNSMutableSet * muSet2 = [NSMutableSet setWithArray:array]; NSDictionary 转化成NSArrayNSArray * keys = [dic allKeys];NSArray * values = [dic allValues]; 字符串转换成数组NSString * str = @"aa.bb.cc";NSArray * strArray =[str componentsSeparatedByString:@“."];]]></content>
      <categories>
        <category>iOS</category>
        <category>UIKit</category>
        <category>NSSet</category>
      </categories>
      <tags>
        <tag>UIKit</tag>
        <tag>iOS</tag>
        <tag>NSSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit-NSDictionary-字典]]></title>
<url>../../../../../../../../2017/12/06/iOS-Garmmar/iOS-NSDictionary-字典/</url>
    <content type="text"><![CDATA[#初始化 创建字段,不可变的 NSDictionary * dic = [NSDictionary dictionaryWithObjectsAndKeys:@"s",@"name", nil]; 快捷创建方式 NSDictionary * dic2 = @&#123; @"one":@"1",@"two":@"2"&#125;;dic2.count 获得字典长度 遍历NSArray * keys = [dic3 allKeys]; for (int i = 0; i &lt; keys.count; i++) &#123; NSString * key = [keys objectAtIndex:i]; //如果你的字典中存储的多种不同的类型,那么最好用id类型去接受它 id obj = [dic3 objectForKey:key]; NSLog(@"obj %@",obj); &#125; 枚举器 NSEnumerator * enumerator = [dic3 objectEnumerator];id value;while (value = [enumerator nextObject]) &#123; NSLog(@"value %@",value);&#125; 可变字典NSMutableDictionary 创建一个可变长度字典 NSMutableDictionary * muDic = [[NSMutableDictionary alloc] initWithCapacity:0]; 向字典中村如数据 [muDic setObject:@"1" forKey:@"one"]; 删除 [muDic removeObjectForKey:@“one"]; 全部删除 [muDic removeAllObjects];]]></content>
      <categories>
        <category>iOS</category>
        <category>UIKit</category>
        <category>NSDictionary</category>
      </categories>
      <tags>
        <tag>UIKit</tag>
        <tag>iOS</tag>
        <tag>NSDictionary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit-NSArray-数组]]></title>
<url>../../../../../../../../2017/12/06/iOS-Garmmar/iOS-UIKit-NSArray-数组/</url>
    <content type="text"><![CDATA[初始化、取值等基础操作 NSArray 是不可变数组,一旦创建完成就不能够对数组进行,添加,删除等操作 NSArray * array = [[NSArray alloc] init]; NSArray * array1 = [NSArray arrayWithObjects:@"one",@"two",@"three", nil]; ``` &gt;在创建一个NSArray的时候最后一个元素一定是nil 不要把nil存到数组中，会导致数据丢失&gt;数组实际上存储的时对象的地址,同样也可以存储数组的地址```objectivec NSArray * a1 = [[NSArray alloc] initWithObjects:@"one",@"two",@"three", nil]; NSArray * a2 = [[NSArray alloc] initWithObjects:@"1",@"2",@"3", nil]; NSArray * a3 = [[NSArray alloc] initWithObjects:a1,a2, nil];``` &gt;创建数组的快捷方式```objectivec NSArray * array = @[@"a",@"b",@"c"]; 快速获得一个数组中的元素 NSString * str = array[0]; [array objectAtIndex:0]; 数组的index从0开始 [array count] 获得元素个数[array containsObject:p1] 判断数组中是否包含某个对象 遍历数组 普通的for循环 for (int i = 0; i &lt; array.count; i++)&#123; NSString * str = array[i]; NSLog(@"array[%d] = %@",i,str);&#125; 使用增强for循环的方式遍历数组 for (NSString * str in array)&#123; NSLog(@"str = %@",str);&#125; 枚举器 NSArray * array = @[@"one",@"two",@"three"];NSEnumerator * enumerator = [array objectEnumerator];NSString * value;while (value = [enumerator nextObject]) &#123; NSLog(@"enum str %@",value);&#125; 数组排序 使用sortedArrayUsingSelector [array sortedArrayUsingSelector:@selector(compare:)] 使用block方式排序 array2 = [array2 sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) &#123; /* NSComparisonResult result = [obj1 compare:obj2]; return result; */ //obj1 compare obj2 就是正序排序 //return [obj1 compare:obj2]; //obj2 compare obj1 就是倒序排序 return [obj2 compare:obj1]; &#125;]; 如果你向给你自己定义的对象排序,必须根据某一个属性来排序,如果你向给你自己定义的对象排序,必须根据某一个属性来排序,sortDescriptorWithKey 参数要的就是你对象中,要依据哪个属性来排序,你就把哪个 属性的名字当成key传入ascending YES表示正序 NO表示倒叙 NSSortDescriptor * d1 = [NSSortDescriptor sortDescriptorWithKey:@"age" ascending:NO]; NSSortDescriptor * d2 = [NSSortDescriptor sortDescriptorWithKey:@"year" ascending:NO]; ``` &gt;如果你要使用多个属性进行排序,默认在前面的NSSortDescriptor优先级比较高```objectivec NSArray * description = @[d2,d1]; array3 = [array3 sortedArrayUsingDescriptors:description]; 可变数组NSMutableArray 创建可变数组 NSMutableArray * array = [[NSMutableArray alloc] initWithCapacity:0]; 使用addObject 动态给数组中增加元素 [array addObject:@“one"]; 数组中可以存储,同一个对象多次指定对象插入的位置 [array insertObject:str1 atIndex:2]; 删除 会通过对象,删除数组中所有的同一个地址的对象 [array removeObject:str1]; 通过索引的方式删除对象,超出了数组的count值,那么就会导致异常 index beyond bounds [array removeObjectAtIndex:0];[array removeAllObjects];]]></content>
      <categories>
        <category>iOS</category>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UIKit</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-AccessControl-访问控制]]></title>
<url>../../../../../../../../2017/12/01/Swift-Grammar/Swift-Grammar-AccessControl-访问控制/</url>
    <content type="text"><![CDATA[AccessControl访问控制 Swift和C++，Java一样，也有访问控制的概念。通过访问权限的控制，我们可以对外隐藏内部的代码细节，防止修改。Swift的访问控制是基于模块（modules）和源文件（source file） Swift的模块概念是这样的： 1、一个App bundle，或者一个framework都可以看成一个独立的module。 你可以使用import来引入别的module到你的module中来。当你将你的代码打包成一个framework，这个framework就是一个module。里面的所有的东西都是属于这个framework，无论你将这个framework引入到别的framework或app中。 2、一个源文件里面虽然可以定义多个类，但是建议一般一个源文件建立一个类。 Swift的访问权限有：open，public，internal，fileprivate，private 1、public 这个权限允许同一个module内部的所有源代码访问，同时允许其他引入了该module的module使用。总的来说就是全开放 2、internal 这个权限允许同一个module内部的所有源代码访问，不允许其他module使用。 3、private 这个权限仅允许同一个source file的代码访问。 Swift的默认访问权限是internal。 public是最高访问权限，而private是最低访问权限。 Swift的权限编程原则： 一、高权限的东西不能包含在低权限的东西里面。 举例： 1、说就是一个public的类型不能定义在一个声明为internal的类型里面。 2、方法的权限不能高于参数和范围值的权限。否则会导致这个方法没法使用。 二、单一app中 一般就用默认的internal就行了。如果你想对其他源文件隐藏，可以使用private。 三、framework中 对于要提供给外边使用的属性，方法。必须使用public权限。其他的可以默认使用internal。如果相对framework里面的其他源文件隐藏，可以使用private。 四、单元测试中 单元测试和我们编写的代码属于不同的module，所以测试模块一般只能访问到public的东西。但是在引入要测试的模块的时候可以加上@testable，这样测试模块就可以访问了。然后要允许被测试的单元可以测试 public class SomePublicClass &#123;&#125; internal class SomeInternalClass &#123;&#125; private class SomePrivateClass &#123;&#125; public var somePublicVariable = 0 internal let someInternalConstant = 0 private func somePrivateFunction() &#123;&#125; 给类型定义访问权限的时候，会影响到类型里面的成员（属性，方法，下标，构造器） 1、将一个类型定义为private后，它里面的成员都是private的。 2、将一个类型定义为public或internal后，它里面的成员还是internal的。如果要某个成员变为public，必须在该成员里面加上public。 Tuple Tuple的访问权限由tuple成员里面访问权限最小那个决定。 方法 方法的访问权限由方法的参数和返回值中最小权限的那个决定。当方法的权限是private的时候，方法的前面要加上private关键字。 枚举类 枚举类型的成员变量的访问权限决定于枚举类型。例如你定义了一个public的枚举类型，那么它里面的case成员都是public的，不允许单独给每个case成员定义访问权限。case成员的raw vlaue的值的权限必须大于等于枚举类的访问权限。 内部类 定义在private类型里面的内部类是private权限；定义在public或internal类型里面的内部类默认是internal类型。如果想要定义在public类型里面的内部类变为public的话，需要自己显式给内部类加上public。 子类 子类不能比父类具有更高的访问权限。但是可以重写父类当前能访问到的父类成员，而且可以重写成更高权限的成员 public class A &#123; private func someMethod() &#123;&#125; &#125; internal class B: A &#123; override internal func someMethod() &#123; super.someMethod() &#125; &#125; 里再补充一点，如果父类是public类的，继承之后不加权限修饰符的话，那么这个子类是internal的属性，常量，变量和下标的访问权限不能超过它所属的类型的权限 getter和setter方法 这两个方法的访问权限默认和属性的是一样的。但是可以修改setter的权限，可以将setter的权限修改得比属性的权限低，但是不能比属性的权限高 public class Animal &#123; public internal(set) var age: Int = 0 &#125; 构造器 构造器的权限不能大于它所属类型的权限。除了标志有require的构造器之外，这种构造器的权限必须和它所属的类的权限相同。构造器参数的权限不能低于构造器。 默认构造器 默认构造器的默认权限和类型权限一样。但是如果类型是public，那么默认构造器还是internal的，想要public的无参构造器必须自己实现。对于结构体的memberwise构造器，想要public的，也要自己实现。 协议 协议的需求的权限和协议权限是一样的，协议是public的，那么需求也是public的。继承的协议的权限最多只能有父类的权限。例如：不能继承一个internal的协议为一个public协议。 协议的一致性 类型可以实现比自己访问权限低的协议。比如，可以定义一个public的类，它可以实现一个internal的类，并且只能在定义了该协议的模块中使用。实现了协议的类访问权限是它本身和采用协议中的最低访问权限。也就是说如果一个类是public的级别，实现的是internal的协议，那么采用这个协议之后，该类的访问权限也是internal的。如果你采用了协议，那么实现协议方法之后，该方法的访问权限遵循协议的访问级别。例如：一个public的类，采用了internal的协议之后，那么该类的实现协议的方法至少也是internal的。 扩展 扩展的默认访问权限由所扩展类型的访问权限决定。 如果你扩展了一个public的类型，那么扩展的成员的默认访问权限就是internal。如果扩展一个private类型，那么扩展的默认访问权限就是private。当然可以自己给扩展自定义访问权限。但是权限不能超过所扩展的类型。另外可以自己给扩展成员再自定义权限。如果你是用扩展来实现协议，那么这个扩展不允许自定义权限，它的权限由协议的权限决定。 泛型 泛型分为泛型类型和泛型方法泛型类型的权限是 泛型类型和泛型参数 之间最小的那个权限。泛型方法的权限是 泛型方法和泛型参数 之间最小的那个权限。 类型别名 每个类型别名都可以看做是对类型的访问权限的定义。但是类型别名的权限必须小于或等于要别名的类型。比如一个private的类型别名可以为private，public，internal的类型进行别名；但是一个public的类型别名不能为internal和private的类型进行别名。]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
        <category>AccessControl</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Grammar</tag>
        <tag>AccessControl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Generics-泛型]]></title>
<url>../../../../../../../../2017/12/01/Swift-Grammar/Swift-Grammar-Generics-泛型/</url>
    <content type="text"><![CDATA[泛型 接受其它函数作为参数的函数有时被称为高阶函数泛型函数 写一个函数的时，一般都会指明参数的类型一般默认在函数中定义的参数都是常量参数，也就是这个参数你只可以查询使用，不能改变它的值如果想要声明一个变量参数，可以在前面加上var，这样就可以改变这个参数的值 //此时这个id值可以在函数中改变 func getName(var id:String)......... 一般默认的参数传递都是传值调用的，而不是传引用。所以传入的参数在函数内改变，并不影响原来的那个参数。传入的只是这个参数的副本下面两个实现交换变量的函数 func swapTwoInts( a:inout Int, b:inout Int)&#123; let t = a // 0 a = b // 100 b = t // 0&#125;var x = 0,y = 100print("x = \(x) ;y = \(y)")//打印x = 0 ;y = 100//交换变量的函数swapTwoInts(a: &amp;x, b: &amp;y)print("x = \(x) ;y = \(y)")x = 100 ;y = 0 上面的只是限于交换整形。但是如果我们相对Double或Float类型，甚至是任何类型的数据实现交换的功能，我们都要分别写一个函数。这是无比麻烦的 所以有了泛型这个概念，泛型就是模糊的类型函数的功能实现和具体类型没关系的时候，就可以使用泛型(感觉类似OC的 id 类型)将上面实现两个变量交换的功能用一个方法完成，这个方法可以用于不同的数据类型swapTwoInts 理解为一个函数族,类型参数 T 的每个选择都会确定一个新函数,该函数接受一个T型数组和一个 T -&gt; T类型的函数作为参数,并返回一个[T]类型的数组 func swapTwoInts&lt;T&gt;( a: inout T, _ b: inout T)&#123; let t = a a = b b = t&#125;var x = 8.12,y = 100.1print("x = \(x) ;y = \(y)") //x = 8.12 ;y = 100.1swapTwoInts( a: &amp;x, &amp;y)print("x = \(x) ;y = \(y)") //x = 100.1 ;y = 8.12问题：x = 8 y = 100.1 发生错误，整数和浮点型数如何写交换方法？？？ 主要的语法就是上面的，这个T就是代表某个类型，但是没有指明具体是哪种类型。而且这个T，可以换成你希望的标示符，只要不是关键字。并且一般要求单词的首字母要大写，比如Element、Value等。而且能指定多个类型，见下面的类型约束 泛型的函数调用方法和普通函数是一样的下面创建了两个Animal实例，然后使用刚刚定义的函数交换数据。 class Animal&#123; var life = 0&#125;var cat = Animal()cat.life = 1var dog = Animal()dog.life = 2swapTwoInts(cat.life, dog.life) //报错！！ 方面交换方法不能交换。。醉了print(cat.life) print(dog.life) 泛型举例分析 参考 // mapfunc map&lt;Element,T&gt;(xs:[Element],transfom:(Element) -&gt;T)-&gt;[T]&#123; var result :[T] = [] for x in xs&#123; result.append(transfom(x)) &#125; return result &#125;func genericComputeArray&lt;T&gt;(xs: [Int], transfom: (Int) -&gt; T) -&gt; [T] &#123; return map(xs: xs, transfom: transfom) &#125;这块 不是很理解 顶层函数和扩展写一个函数,它接受一个给定的整型数组,通过计算得到并返回一个新数组。要求：新数组各项为原数组中对应的整型数据加一。for 循环能实现 泛型类型 定义一个类型，但是它可以对不同类型的数据进行操作比如Array和Dictionary这两个集合结构体，他们可以装不同类型的数据，这就是泛型类型 官方文档展示一个泛型类型的栈，使用Array来实现 struct Stack&lt;Element&gt; &#123; var items = [Element]() mutating func push(item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125; &#125; 然后在创建这种泛型类型实例的时候，我们必须指定所属的类型 var stackOfStrings = Stack&lt;String&gt;() stackOfStrings.push("uno") 泛型约束 我们可以对泛型进行约束，让他们必须遵守某些协议，官方文档语法如下 func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123; // function body goes here &#125; 同时还可以添加where约束符再对泛型进行限制 func someFunction&lt;T: SomeClass, U: SomeProtocol where T.someItem == U, U.someItem: SomeClass2&gt;(someT: T, someU: U) &#123; // function body goes here &#125; 关联类型 在定义协议的时候，我们可能需要定义一个或多个类型作为我们协议的一部分。而这些类型是不确定的，只有到具体的类实现协议的时候才能确定，这个时候我们可以使用关联类型来实现。所谓的关联类型就是一个占位符，等到具体实现协议的时候才知道它具体是什么类型。官方例子如下 protocol Container &#123; typealias ItemType mutating func append(item: ItemType) var count: Int &#123; get &#125; subscript(i: Int) -&gt; ItemType &#123; get &#125; &#125; 然后在实现协议的时候，我们可以指定ItemType具体是什么类型 struct IntStack: Container &#123; // original IntStack implementation var items = [Int]() mutating func push(item: Int) &#123; items.append(item) &#125; mutating func pop() -&gt; Int &#123; return items.removeLast() &#125; // conformance to the Container protocol typealias ItemType = Int mutating func append(item: Int) &#123; self.push(item) &#125; var count: Int &#123; return items.count &#125; subscript(i: Int) -&gt; Int &#123; return items[i] &#125; &#125; &gt;同时又因为有Swift的类型判断机制，所以我们在实现了协议的其他方法之后，编译器会自动判断关联类型是什么，不需要我们显式地指定。所以上面代码指定关联类型为Int的那行可以删去。 泛型OC是不支持的，但是java支持。使用泛型能给编程带来很大的便利]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Extension扩展]]></title>
<url>../../../../../../../../2017/12/01/Swift-Grammar/Swift-Grammar-Extension扩展/</url>
    <content type="text"><![CDATA[Extension扩展 Swift中的扩展就是OC中的分类。但是这里的扩展可以对类、结构体、枚举类进行添加。使用扩展，我们可以在不接触源代码的前提下，对已有的代码进行功能上的添加。 Swift中的扩展提供的一些功能： 1、添加计算属性或类计算属性，但是不能添加存储属性。 2、添加实例方法或类别方法。但是不能覆盖已经存在的方法。 3、定义新的构造器。 4、定义和使用新的嵌套类。 5、令已经存在的类型遵守协议。 假设我们已经有了一个Animal类，但是不能得到它的源代码 class Animal &#123; var life: Int = 0 var height: Double = 0 &#125; 我们利用扩展，对Animal添加一个计算属性和方法、构造器还有嵌套类。 当然也可以添加下标，但这里不演示了 extension Animal &#123; //扩展计算属性 var lifeYear : Double &#123; return Double(self.life) / 365 &#125; //扩展构造器 convenience init(life: Int, height: Double) &#123; self.init() self.life = life self.height = height &#125; //扩展方法 func makeSound() -&gt; String &#123; return "I can live \(lifeYear) years" &#125; // 扩展嵌套类 enum Size &#123; case Big, Small, SuperSmall &#125; // 扩展一个使用嵌套类的计算属性 var size: Size &#123; switch height &#123; case let h where h &gt; 10: return .Big case let h where h &gt; 0.1: return .Small default: return .SuperSmall &#125; &#125; &#125; var a = Animal(life: 3365 * 7, height: 0.001) print(a.size) // SuperSmall print(a.lifeYear) // 7.0 print(a.makeSound()) // I can live 7.0 years 面代码需要注意的是扩展构造器的时候，在构造器的时候讲过，在扩展中添加构造器是不会影响默认构造器的产生。不能添加原来已有的构造器。另外在类扩展里面，是不给添加指定构造器或析构器，只能添加便利构造器。在便利构造器中，要先调用原来的构造器来初始化类后，才能对类进行访问。 扩展还有一个作用就是让类遵守协议。这部分留到协议里面讲下面将以前将过的麻烦的String类型做一个扩展，使得方便截串和获取长度 extension String &#123; //获取字符串长度 var length: Int &#123; return self.characters.count &#125; //获取部分字符串，如果不在范围内，返回nil。如果end大于字符串长度，那么截取到最后 subscript (start: Int, end: Int) -&gt; String? &#123; if start &gt; self.length || start &lt; 0 || start &gt; end &#123; return nil &#125; let begin = self.startIndex.advancedBy(start) var terminal: Index if end &gt;= length &#123; terminal = self.startIndex.advancedBy(length) &#125; else &#123; terminal = self.startIndex.advancedBy(end + 1) &#125; let range = Range(start: begin, end: terminal) return self.substringWithRange(range) &#125; //获取某个字符，如果不在范围内，返回nil subscript (index: Int) -&gt; Character? &#123; if index &gt; self.length - 1 || index &lt; 0 &#123; return nil &#125; return self[self.startIndex.advancedBy(index)] &#125; &#125; 然后就可以这样截串 var s = "哈0123456789" print(s.length) // 11 print(s[0,2]) // Optional("哈01") print(s[9]) // Optional("8")]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Error-Handling错误处理]]></title>
<url>../../../../../../../../2017/12/01/Swift-Grammar/Swift-Grammar-Error-Handling-错误处理/</url>
    <content type="text"><![CDATA[Swift-错误 Swift提供了一套完整的错误抛出-捕获-处理机制Swift采用Error协议来表示错误类型，通过do-try-catch的方式来处理可能会抛出异常的代码 Optional 可选值表示一个值要么有值，要么是nil。在Swift中，Optional是用enum写的， public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral &#123; case none case some(Wrapped) //...&#125; 当发生错误的时候，返回一个可选值是常见的处理方式。但是，这种方式的有一个很明显的缺点 调用者不清楚为什么失败 不好进行相关的处理 Error协议与throws Error是一个空的协议，用来表示错误类型 NSError和CFError都遵循了这个协议 在Swfit中，枚举是一个特别适合用来处理Error的数据类型。首先定义一个类Person表示人 enum Sex&#123; case male case female&#125;class Person&#123; let sex:Sex var money:CGFloat init(sex:Sex ,money:CGFloat) &#123; self.sex = sex self.money = money &#125;&#125; Person可以结婚，结婚的时候会发生一些错误，比如钱不够，比如性别不对，用枚举来表示 enum MarryError : Error&#123; case lackMoney case wrongSex&#125; 方法的实现如下 extension Person&#123; func marry(with another: Person) throws -&gt; Bool&#123; guard self.sex != another.sex else&#123; throw MarryError.wrongSex &#125; guard self.money + another.money &gt; 100000 else &#123; throw MarryError.lackMoney &#125; return true &#125;&#125; 一个带有throws关键字的函数，调用的时候有两种方式选择 ①❶使用 do-try-catch 代码块 let tom = Person(sex: .male, money: 100000)let jack = Person(sex: .male, money: 100000)do&#123; try tom.marry(with: jack)&#125;catch MarryError.wrongSex &#123; print("Two Person have same sex")&#125;catch MarryError.lackMoney&#123; print("Oh, they do not have enough moeny")&#125;catch let error&#123; print(error)&#125; ❷不需要区分每一个Error，也可以这么调用 do&#123; try tom.marry(with: jack)&#125;catch let error&#123; print(error)&#125; ②使用 try?，对于有返回值的throws函数，使用try?会把结果转换为可选值 let tom = Person(sex: .male, money: 100000)let jack = Person(sex: .male, money: 100000)if let result = try? tom.marry(with: jack)&#123;//成功&#125;else&#123; print("Error happen")&#125; defer关键字 defer关键字用来处理类似Ojective C中@try-@catch-@finally中，@finally的作用比如，打开文件，如果抛出错误的话，我们总希望关闭这个文件句柄 func contents(of filePath:String) throws -&gt; String&#123; let file = open(filePath,O_RDWR) defer &#123; close(file) &#125; //...&#125;defer代码块的内容在退出作用域之前会被执行 关于defer的注意 多个defer会按照逆序的方式执行。 当你的程序遇到严重错误，比如fatalError,或者强制解析nil，或者segfaults的时候，defer的代码块并不会执行。 rethrow rethrow关键字在高阶函数中比较常见，所谓高阶函数，就是一个函数的参数或者返回值是函数类型最常见的比如，Sequence协议map方法比如： let array = [1,2,3]let result = array.map&#123;$0 * 2&#125; 由于map函数传入的是一个闭包，这个闭包可能会抛出错误由参数抛出的错误最后会向上传递给map函数 enum MapError : Error&#123; case invalid&#125;func customMapper(input:Int) throws -&gt; Int&#123; if input &lt; 10&#123; throw MapError.invalid &#125; return input + 1&#125;let array = [1,2,3]let result = array.map(customMapper) 这样是编译不通过的调用的时候需要：按照上文提到的throws关键字的路子来 do &#123; let result = try array.map(customMapper)&#125; catch let error&#123;&#125; 这就是rethrows关键字的精髓所在rethrows 关键字表示当参数闭包标记为throws的时候，函数本身为throws。如果参数闭包不会抛出错误，则函数也不会通过这个关键字，你不必每次都进行try-catch Result类型 一个函数执行要么成功，要么失败。成功的时候我们希望返回数据，失败的时候我们希望得到错误信息，这就是Result类型，一个典型的Result类型如下： enum Result&lt;T&gt;&#123; case success(T) case failure(error:Error)&#125; 通过Result类型，不再需要可选值或者do-try-catch来包裹你的代码用Result类型对上述marry函数进行重写 extension Person&#123; func marry(with another: Person) -&gt; Result&lt;Bool&gt;&#123; guard self.sex != another.sex else&#123; return .failure(error: MarryError.wrongSex) &#125; guard self.money + another.money &gt; 100000 else &#123; return .failure(error: MarryError.lackMoney) &#125; return .success(true) &#125;&#125; 然后，这么调用 let tom = Person(sex: .male, money: 100000) let jack = Person(sex: .male, money: 100000) let result = tom.marry(with: jack) switch result &#123; case let .success(value): print(value) case let .failure(error): print(error)&#125; Result链 Swift中有可选链，来处理多个可选值的连续调用。同样的，我们也可以为Result类型来添加链式调用： 如果上一个调用结果是.success, 则继续调用下一个 如果上一个调用结果是.failure, 则传递failure给下一个 用extension来实现 extension Result&#123; func flatMap&lt;V&gt;(transform:(T) throws -&gt; (V)) rethrows -&gt; Result&lt;V&gt;&#123; switch self &#123; case let .failure(error): return .failure(error: error) case let .success(data): return .success(try transform(data)) &#125; &#125;&#125; 于是，可以这么调用 resut.flatMap(&#123;//转换1&#125;).flatMap(//转换2)... 一旦失败，中间有一次flatMap转换失败，则之后的转换逻辑都不会执行进阶：Result类型在Swift版本的Promise中大行其道，可以参见PromiseKit的源码，promise让异步处理变得优雅 assert/precondition Swift也有断言支持在Swfit中，断言是一个函数断言仅在Debug模式下进行检查，帮助开发者发现代码中的问题 func assert(_ condition: @autoclosure () -&gt; Bool, _ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line) 如果需要在Relase模式下也进行检查，则使用precondition func precondition(_ condition: @autoclosure () -&gt; Bool, _ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line) 桥接到Objective C 使用NSError来处理错误的的Objective 方法 //NSFileManager- (BOOL)removeItemAtURL:(NSURL *)URL error:(NSError * _Nullable *)error; 在Swift中会被自动的转换成 func removeItem(at URL: URL) throws 但是，纯Swfit的Error桥接的Objective C的时候，会有一些问题因为NSError需要 domain和code等详细信息可以让Swift的Error实现CustomNSError协议，来提供这些需要的信息 enum MarryError : Error&#123; case lackMoney case wrongSex&#125;extension MarryError : CustomNSError&#123; static let errorDomain = "com.person.marryError" var erroCode:Int&#123; switch self &#123; case .lackMoney: return -100001 case .wrongSex: return -100002 &#125; &#125; var errorUserInfo:[String:Any]&#123; return [:] &#125;&#125; 相关的，还有两个协议LocalizedError和RecoverableError Swift的错误处理是用来处理运行时错误的 当错误发生时，你可以选择抓错误，或者继续往上抛出错误。当一个运行时错误最终没办法处理的时候，程序就会崩溃。 Swift中有一个空的协议用来给用户自定义错误。一般使用枚举类实现这个协议来自定义错误。如下 enum ComputerError: ErrorType &#123; case NoGameError case MemoryError case HardDiskError &#125; 这里定义了三种error。当你要抛出一个error的时候，使用throw关键字。如下 throw ComputerError.NoGameError 可以抛出错误的函数的定义 func canThrowErrors() throws -&gt; String func cannotThrowErrors() -&gt; String 利用上面的语法，我们定义一个Computer类，这个类有一个playGame方法，它会在某些情况下抛出错误 class Computer &#123; var memory = 1024 var hardDisk = 4000 var games = [ "War3": Requirement(memory: 512, HardDisk: 1500), "LOL": Requirement(memory: 1500, HardDisk: 3000), "My World": Requirement(memory: 256, HardDisk: 500)] func playGame(gameName: String) throws -&gt; Bool&#123; guard let game = self.games[gameName] else &#123; throw ComputerError.NoGameError &#125; guard game.HardDisk &lt; self.hardDisk else &#123; throw ComputerError.HardDiskError &#125; guard game.memory &lt; self.memory else &#123; throw ComputerError.MemoryError &#125; return true &#125; &#125; 注意一点的是，如果你要调用能抛出错误的函数的时候，必须使用try、try?或者try!关键字在前面，如下 try myPC.playGame("War4") //这句会因为没有War4这个游戏而抛出NoGameError错误 下面是处理错误的部分。当调用一个可以抛出错误的方法的时候，一般有三种处理方法。第一种是调用者继续向上抛出这个错误。这种情况下，这个调用者也必须是一个可以抛出错误的函数。如果最后没处理这个错误，那么程序崩溃。第二种是使用do…catch语句对错误进行处理。第三种是使用try?或try!调用会抛出错误的函数 第一种方法举例，再定义一个Person类，它的play方法里面调用了Computer的playGame方法，然后继续抛出这个错误 class Person &#123; var pc = Computer() func play() throws &#123; try self.pc.playGame("SC2") &#125; &#125; 第二种方法举例，使用do…catch语句处理。在do范围里面，我们可以调用会产生错误的方法。接着的catch语句可以接上要处理的错误类型 class Person &#123; var pc = Computer() func play() &#123; do &#123; try self.pc.playGame("LOL") print("have fun") &#125; catch ComputerError.NoGameError &#123; print("NoGameError") &#125; catch ComputerError.MemoryError &#123; print("MemoryError") &#125; catch ComputerError.HardDiskError &#123; print("HardDiskError") &#125; catch &#123; print("other error",error) &#125; &#125; &#125; 值得注意的是最后一个catch。这里并没有加上要处理的错误。这的catch会捕捉所有类型的错误。另外还有一个问题，如果不加上这个捕捉所有类型的catch语句。调用playGame的那句会报错说catch没有穷尽会抛出的错误。但是我只有三个错误，照理来讲应该是已经穷尽的了。不知道是Swift的问题，还是我代码哪里有问题。但如果把这个调用放到main.swift中去，也是只使用3个catch，就不会报错。搞不懂。我现在的处理方式是把这个play方法继续写成一个可以抛出错误的方法。只处理自定义的三种错误。其他错误往上抛 class Person &#123; var pc = Computer() func play() throws &#123; do &#123; try self.pc.playGame("LOL") print("have fun") &#125; catch ComputerError.NoGameError &#123; print("NoGameError") &#125; catch ComputerError.MemoryError&#123; print("MemoryError") &#125; catch ComputerError.HardDiskError &#123; print("HardDiskError") &#125; &#125; &#125; 第三种是使用try?或try!调用会抛出错误的函数。在官方文档里面，它原意是使用try?去处理一个会抛出错误的方法的返回值，如果这个方法抛出错误，那么会得到nil。如果没有错误，那么将函数返回值包装成可选类型后返回 var myPC = Computer() var result = try? myPC.playGame("War3") //这里playGame没有抛出错误，所以返回了Bool可选类型，值为true ry!的区别是它默认调用方法是不会报错的，如果调用的方法报错，那么会得到运行时错误。即使你将这个try!写到了一个会抛出错误的方法里面，它也不会向上抛出这个错误。而是直接崩溃。 try? 、try! 和try 三者的区别： try在一个会抛出错误的方法里面，它会把产生的错误交由catch处理或者向上抛出。 try?是出错的时候返回一个nil，屏蔽错误。没错的话，将结果包装成一个可选类型返回。 try!是在没错的情况下返回函数返回值。出错的情况下直接崩溃。错误不会再交给catch处理或者向上抛出。 所以如果在do catch里面将try改为try?或者try!，那么会有一个警告说catch永远不会执行。 defer语句 熟悉java的朋友应该知道finally语句。这个是在try..catch里面无论是否有错误，在退出try..catch范围的时候，最后都会执行finally范围内的代码。一般是用来做一些诸如关闭文件的工作。因为无论出不出错，最后都必须关闭打开的文件。Swift也弄了一个defer语句，同样也是想在最后做这样的一些事情。但是这个defer远远没有finally那么好用。先来开开defer的语法。学过java的朋友知道finally只能用在try..catch里面。但是defer可以不用在do..catch里面。并且defer里面不能用return、break或者抛出错误的语句。 下面是一个没有用在do..catch中的例子 func readFile() &#123; defer &#123; print("Close file") &#125; print("Open file") print("Deal with file") &#125; readFile() //打印 //Open file //Deal with file //Close file 留意上面的打印顺序，可以看出defer中的语句是在最后才执行的。单从这里看，和设计初衷一致：在最后面才执行。但是一旦将这个defer用到do..catch里面，你就会觉得很恶心。我们先来看一个和我们想象中一致的代码，首先改写上面用到的Person类。我们的原意是这样的：Person的play方法调用了Computer的会产生错误的playGame方法。我们定义了一个result的可选变量，用于接收playGame方法的返回值。在退出do..catch的时候，会调用defer语句。我们在里面判断result是否为nil。然后输出心情。 class Person &#123; var pc = Computer() func play() throws &#123; do &#123; var result: Bool? defer &#123; if result != nil &#123; print("have fun") &#125; else &#123; print("sad") &#125; &#125; result = try self.pc.playGame("LOL") print("playGame") &#125; catch ComputerError.NoGameError &#123; print("NoGameError") &#125; catch ComputerError.MemoryError&#123; print("MemoryError") &#125; catch ComputerError.HardDiskError &#123; print("HardDiskError") &#125; &#125; &#125; 然后我们执行下面代码，因为默认的Computer类的hardDisk不足。所以会报MemoryError错误 var p = Person() try p.play() //打印 //sad //MemoryError 注意打印顺序，可以看出defer是先与catch执行的。这个和java的finally是不一样的。finally是在catch执行完后执行。其次是playGame没有打印，说明报错之后的语句不会执行。如果playGame的参数是“War3”，那么程序不会报错。输出是 playGame have fun 从以上来看，似乎还是符合我们的原意。但是当你把defer的位置改改，变为下面这样 class Person &#123; var pc = Computer() func play() throws &#123; do &#123; var result: Bool? result = try self.pc.playGame("LOL") defer &#123; if result != nil &#123; print("have fun") &#125; else &#123; print("sad") &#125; &#125; print("playGame") &#125; catch ComputerError.NoGameError &#123; print("NoGameError") &#125; catch ComputerError.MemoryError&#123; print("MemoryError") &#125; catch ComputerError.HardDiskError &#123; print("HardDiskError") &#125; &#125; &#125; 你会发现输出只有一个MemoryError。也就是说当定义defer前面的语句报错之后，defer得不到执行。这样就要求这个defer必须写在一个合理的位置才行。 另外如果我们再改改上面的代码，使用try! 你会发现输出只有一个MemoryError。也就是说当定义defer前面的语句报错之后，defer得不到执行。这样就要求这个defer必须写在一个合理的位置才行。另外如果我们再改改上面的代码，使用try! 这时候什么都没有打印，程序直接崩溃掉了。这个defer的初衷完全不同。Swift的错误处理也是近几个版本才出现的。估计以后会继续改进]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
        <category>Error</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Optional Chaining-可选链]]></title>
<url>../../../../../../../../2017/12/01/Swift-Grammar/Swift-Grammar-可选链/</url>
    <content type="text"><![CDATA[可选链（Optional Chaining 回顾一下可选类型，当你要使用可选类型的时候，首先必须要对其进行解包。但是存在一个问题就是，如果对一个为nil的可选类型进行强制解包的话，那么会产生运行时错误。第一种解决办法就是使用if语句先判断这个可选类型是否为nil，然后在访问其属性或方法。但是十分繁琐。考虑一下这个可选类型里面访问的属性还是可选类型的情况吧，多几层的时候，if的层数惨不忍睹。一个很好的解决办法就是利用可选链（Optional Chaining）语法很简单，把中间需要解包的可选类型的强制解包符号!替换成？ 伪代码例子 if let 可选链返回值的解包 = 可选类型1?.可选类型2?.返回可选类型的方法1?.可选类型3 &#123; //&lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt;可选链返回值&lt;/span&gt;不为nil &#125; else &#123; //&lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt;可选链返回值&lt;/span&gt;为nil &#125; 解释： 首先检测可选类型1是否为nil，如果不会nil，那么解包。 然后检查可选类型1的属性——可选类型2是否为nil，不为nil，解包。 然后调用可选类型2的一个方法。这个方法会返回一个可选类型.成这个可选类型为可选类型A吧。 然后再对这个可选类型A进行判断，如果不为nil，解包。 最后利用if语句对可选类型A的属性——可选类型3进行判断处理 意点： 1、如果前面的每一次判断有一个为nil了。那么这个可选链直接返回nil，不会再对后面的可选链进行处理。 2、可选链返回的类型是可选链中最后一个类型对应的可选类型。假设上面伪代码中最后一个可选类型3改为一个非可选类型3（比如Int），那么这个链返回的是其对应的可选类型Int? 3、可选链最后不能再用?进行解包，必须用!。但是用!就会产生当可选类型为nil时报错的情况。所以为了判断是否为nil，只能用if 上面的伪代码是访问可选类型的例子。对于给可选链赋值的例子的伪代码如下 可选类型1?.可选类型2?.返回可选类型的方法1?.类型3 = 赋值 //这句中的类型3可以是可选类型也可以是非可选类型。赋值成功与否都不会报错。 //借助if语句判断是否赋值成功 if (可选类型1?.可选类型2?.返回可选类型的方法1?.可选类型3 = 赋值 ) != nil &#123; //&lt;span style="color:#ff0000;"&gt;注意if中赋值语句的返回值是Void?&lt;/span&gt; //赋值成功 &#125; else &#123; //赋值失败 &#125; 例子 class CPU &#123; var name: String? func getClockSpeed() -&gt; Double? &#123; if self.name != nil &#123; return 1.2 &#125; else &#123; return nil &#125; &#125; &#125; class Computer &#123; var cpu: CPU? &#125; var c = Computer() print(c.cpu?.name = "fef") //这句可选链的类型是Void?，打印 nil print(c.cpu?.name) //这句可选链的类型是String?，打印 nil c.cpu = CPU() print(c.cpu?.getClockSpeed()?.isZero) //这句可选链的类型是Bool? ,打印 nil print(c.cpu?.name = "Intel") //这句可选链的类型是Void?，打印 Optional(()) print(c.cpu?.name) //这句可选链类型是String?，打印 Optional("Intel") print(c.cpu?.getClockSpeed()?.isZero) //这句可选链的类型是Bool? ,打印 Optional(false)]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-ARC-自动引用计数]]></title>
<url>../../../../../../../../2017/12/01/Swift-Grammar/Swift-Grammar-ARC-自动引用计数/</url>
    <content type="text"><![CDATA[ARC 自动引用计数Swift引入ARC 对于类实例，它可能存在被多个变量引用的情况如果在还有变量引用的情况下释放了改实例的话，那么其他变量再尝试访问这个实例的方法或属性的时候，程序就会崩溃。所以必须确保在以后都没有变量使用这个实例的情况下，才能去释放这个实例对于值类型（结构体等），因为不存在多个变量对应一个实例的情况，所以不会有上述问题为了解决这个问题，Swift使用自动引用计数(ARC)来管理内存。它只对引用类型起作用，对于值类型不起作用 引用计数的概念 当你给一个创建一个类实例，并且把这个类实例赋值给某个变量或常量的时候，那么这个变量或常量就“拥有”这个实例，我们称为有了一个“强引用”。所谓的引用计数，就是这个实例被多少个常量或变量强引用了 class Apple &#123; deinit&#123; print("deinit") &#125; &#125; var a:Apple! = Apple() 上面这最后一句代码就是变量a对一个Apple类的实例有了一个强引用。这时候这个实例的引用计数为1。因为类实例是引用类型，所以你可以把这个引用传递给其他的常量或变量 var b = a let v = a 这时候这个实例就被三个变量或常量所引用，这个时候它的引用计数为3.当你把其中的b设为nil的时候，引用计数就会变为2.当该实例的引用计数变为0的时候，这个实例就会被销毁，销毁的时候就会调用它的deinit方法。注：因为上面用了常量，所以不能手动把常量设为nil，只能等这个常量离开作用域后被系统自动销毁。(如果你是在main.swift的全局中定义这些变量或常量的话，因为在main执行完之后才会释放这些变量或常量，所以不会打印deinit。但是你可以把他们放到一个函数里面，然后在main.swift里面调用这个函数。当这个函数执行完之后，这些变量或常量就会被释放。) 自动引用计数的规： 1、赋值给不加修饰符的常量和变量的时候，实例的引用计数加1。 2、当一个变量设为nil，或者变量(常量)离开作用域的时候，这个常量或变量所引用实例的引用计数减1。 3、当一个实例的引用计数为0的时候，它就会被销毁。 但是上面看似简单的规则也会有很多问题。比如下面的循环引用问题。 先定义两个类，一个Telephone类和一个Person类。Telephone类有一个Person类的属性，Person类里面有一个Telephone类的属性 class Telephone &#123; var person: Person? deinit&#123; print("Telephone deinit") &#125; &#125; class Person &#123; var telephone: Telephone? deinit&#123; print("Person deinit") &#125; &#125; 定义一个Person类的实例和一个Telephone类的实例。并对他们赋值 var person = Person() var telephone = Telephone() person.telephone = telephone telephone.person = person 下面分析一下Person实例和Telephone实例的引用计数。 在定义Person实例的时候，赋值给了变量person，所以第一句代码后，Person实例的引用计数为1。同样第二句代码后，Telephone实例的引用计数也为1。 然后第三句代码把telephone赋值给了person.telephone。也就是person.telephone也对这个Telephone实例有了强引用，这时候Telephone实例的引用计数为2。 同样，第四局过后，Person实例的引用计数也为2。 现在的状态是一个Person实例强引用了一个Telephone实例，这个Telephone实例又强引用了这个Person实例。你强引用我，我强引用你。这样就成了一个循环引用。 接着执行下面代码，person变量和telephone变量释放对实例的强引用 person = nil telephone = nil 但是Person实例中的telephone属性仍然强引用着Telephone实例。同样的Telephone实例的person属性也引用着Person实例。所以Person实例和Telephone实例的引用计数都为1。但此时我们已经没办法再访问Person和Telephone的实例了。同时又因为他们的引用计数都为1，系统也不会释放他们。这样就造成了内存泄露。 为了解决这种循环引用的问题，办法就是截断这个循环。第一种笨笨的解决方法就是在你把person或telephone变量设为nil之前，把person.telephone或telephone.person设为nil。这样就手动切断了循环引用。而通用的解决方法就是引用一个新概念——弱引用（Weak Reference）弱引用和强引用最大区别就是：当你把一个实例赋值给一个弱引用变量的时候，这个变量的引用计数不会加1。为了实现这一点，在定义变量的时候在最前面加上weak关键字。下面我们重新定义Person类和Telephone类 class Telephone &#123; weak var person: Person? //把这个变量定义为了一个弱引用变量 deinit&#123; print("Telephone deinit") &#125; &#125; class Person &#123; var telephone: Telephone? deinit&#123; print("Person deinit") &#125; &#125; 然后我们再次调用下面的代码 var person: Person? = Person() var telephone: Telephone? = Telephone() person!.telephone = telephone telephone!.person = person //第4句 person = nil // 执行完这句后打印 Person deinit telephone = nil // 执行完这句后打印 Telephone deinit 因为Telephone类里面的person属性是弱引用的，所以执行完了第4句之后，Telephone实例被telephone变量和person.telephone实例所引用，引用计数为2。而Person实例只被person变量所引用，引用计数为1. 当执行完person = nil 之后，person的引用计数就变为了0， 这个时候系统就会释放Person实例，这个过程中，person.telephone也会被释放，所以会导致Telephone实例的引用计数减1，变为1。 当执行完telephone = nil 之后，Telephone实例的引用计数变为0。系统释放Telephone实例。 关于这个弱引用再补充几点 第一、当一个弱引用变量所引用的实例被释放的时候，这个弱引用变量会被自动置为nil。 第二、因为第一条的内容，所以弱引用只能对变量使用，并且必须是可选类型。 第三、如果你在创建实例的时候就把它复制给一个弱引用变量，因为弱引用变量不会增加这个实例的引用计数，所以这个实例创建后立马就会被销毁。 第四、如果你将一个已经赋值的弱引用变量赋值给一个强引用变量(常量)，那么这个实例的引用计数会加1。 Unowned Reference Unowned Reference和弱引用一样，不会对实例产生强引用。区别在于Unowned Reference假设它所指向的实例总是有值的。所以Unowned Reference一般不会设置为可选类型。但缺点就是当Unowned Reference所指向的实例被释放的时候，Unowned Reference变量不会自动置为nil。 语法就是将weak关键字替换为unowned。但一个变量永远不会为nil的时候，建议使用unowned修饰。 循环引用第二种情况——闭包循环引用 在闭包的时候我们说过，闭包是引用类型，且会捕获值。设想，你把一个闭包声明为一个类的属性的时候，这个类的实例拥有了对这个闭包的强引用。此时如果你在这个闭包里面访问了这个类的其他属性(self.someProperty)或者方法(self.someMethod)的话。那么这个闭包就会捕获所访问的属性或方法，统称&quot;捕获了self&quot;。在访问实例的属性或方法的时候，必须使用self.的方式。Swift此意在提醒你可能会产生循环引用。 那么这时候又是一个循环引用了，self引用闭包，闭包引用self。导致这个实例永远不会被释放。 下面定义一个有闭包的Person类 class Person &#123; var name: String? lazy var printName: Void-&gt;Void = &#123; print(self.name) &#125; init(name: String)&#123; self.name = name; &#125; deinit&#123; print(&quot;Person deinit&quot;) &#125; &#125; 这个闭包我们声明为了lazy类型，因为如果你想要在闭包里面访问到self的话，必须是在类初始化之后才行。而一般的属性是在类初始化的最开头阶段初始化的，所以不加lazy的闭包不能访问self关键字。上面的代码很明显闭包和类实例已经可能会产生循环引用了。为什么说可能呢？因为如果你一直没用到闭包的话，那么这个闭包就不会被初始化，所以也不会产生闭包对self的强引用，也就谈不上循环引用了。 所以如果仅仅执行下面代码 var p: Person? = Person(name: "Kate") p = nil //打印出 Person deinit 但是如果执行下面代码 var p: Person? = Person(name: &quot;Kate&quot;) p?.printName() p = nil //打印出 Optional(&quot;Kate&quot;) 这时候因为循环引用导致Person实例不会被释放。解决这个循环引用同样有两种方式。 第一种是在不需要这个实例的时候，将这个可能会引起循环引用的闭包设为nil。 第二种是利用闭包的捕获列表。下面是第二种方法的介绍 下面是语法定义例子，分别是有参数和没参数的闭包。在这种情况下，闭包对捕获的self不会产生强引用。（题外话，在OC中是通过定义另外一个对self的弱引用变量，然后将这个弱引用变量传递给block来实现的。） //有参数的情况 lazy var printName: ((String)-&gt;Void)? = &#123; [unowned self] (say: String) -&gt; Void in print(say,self.name) &#125; //没参数的情况 lazy var printName2: (Void-&gt;Void)? = &#123; [weak self] in print(self!.name) &#125; 这里就是用两个关键字weak和unowned将self修饰。weak和unowned的区别和之前所讲的是一样的。]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
      <tags>
        <tag>ARC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit-UIButton-Img和Title位置]]></title>
<url>../../../../../../../../2017/12/01/iOS-UIKit/iOS-UIKit-UIButton-Img和Title位置/</url>
    <content type="text"><![CDATA[iOS-UI-UIButton-Img和Title位置 UIButton 的image title 的位置都是可以调整的，具体如何调整可以按照下面的步骤 设置内容的水平垂直位置self.contentVerticalAlignment = UIControlContentVerticalAlignmentTop;self.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft; self指的是UIButton对象，这是继承自UIButon的方法里面或者给UIButton添加扩展方法里面。通过这样的设置可以使得imageView显示在UIButton对象的左上角，titleLabel显示在imageView的右边 调整imageView居中CGFloat btn_width = self.frame.size.width;self.imageEdgeInsets = UIEdgeInsetsMake(10, (btn_width - self.imageView.frame.size.width)/2, 0, 0); 调整 titleLabel居中CGFloat btn_width = self.frame.size.width;self.titleEdgeInsets = UIEdgeInsetsMake(self.imageView.frame.size.height + vSpace+10, - self.imageView.frame.size.width+(btn_width/2-self.titleLabel.frame.size.width/2), 0, 0); 通过减去 imageView的宽度使titleLabel处在左上角，让后将label移植中心。经过以上三步就可以使imageView 、titleLabelLabel 居中，其它的显示形式一样可以参照以上的设置。 整理成了方法， 不需要每次都写 - (void) setImageAndTitleCenterWithVerticalGapSpace:(CGFloat) vSpace imageTopSpace:(CGFloat) iSpace &#123; self.contentVerticalAlignment = UIControlContentVerticalAlignmentTop; self.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft; CGFloat btn_width = self.frame.size.width; CGFloat iTop = iSpace; self.imageEdgeInsets = UIEdgeInsetsMake(iTop, (btn_width - self.imageView.frame.size.width)/2, 0, 0);// self.titleEdgeInsets = UIEdgeInsetsMake(self.imageView.frame.size.height + vSpace+iTop, - self.imageView.frame.size.width+(btn_width/2-self.titleLabel.frame.size.width/2), 0, 0);// 使用中发现对于label的width取值不准确，遂通过计算一次获取，准确 CGSize size = [self.titleLabel sizeThatFits:CGSizeMake(CGRectGetWidth(self.frame), CGRectGetHeight(self.frame))]; self.titleEdgeInsets = UIEdgeInsetsMake(CGRectGetHeight(self.imageView.frame)+ vSpace + iTop, - CGRectGetWidth(self.imageView.frame) + (CGRectGetWidth(self.frame) - size.width)/2, 0, 0);&#125; vSpace imageView与titleLabel垂直间隔 iSpace imageView 距离 top的间隔]]></content>
      <categories>
        <category>iOS</category>
        <category>UIKit</category>
        <category>UIButton</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Initialization初始化&Deinitialization析构]]></title>
<url>../../../../../../../../2017/12/01/Swift-Grammar/Swift-Grammar-初始化-析构/</url>
    <content type="text"><![CDATA[Initialization 初始化初始化 初始化，是当创建一个类、结构体、枚举类的时，完成存储属性的值的初始化，和其他一些初始化工作。准备好这个实例以供使用反过来，当一个实例不再使用的时候，由析构过程释放这个实例所占用资源完成初始化工作的一个方法一般称为初始化方法、构造器(Initializer)、构造方法等等Swift中的构造器不需返回值，只是完成初始化工作。 类或结构体在创建的时候必须保证存储属性有初始化值 目的的实现可以通过在定义属性的时候给存储属性添加上默认值，也可以在构造器中赋值。并且在这两种情况中都不会触发属性的观察器。官方文档建议我们在一个存储属性通常具有同一个初始值的时候，使用属性定义的方式添加初始值。 下面是这两种方法的代码class Animal &#123; var life: Int = 0 var height: Double init()&#123; height = 0 &#125; &#125; 这里的init()方法就是构造器。注意它是不带func关键字的。而且也没有返回值。以前创建一个实例的时候，都是使用“类名()”的形式，这其实就是调用了这个构造器。但是当时我们并没有写这个构造器，这是因为当一个类没有其他构造器的时候，编译器会自动生成这个默认的构造器。但是一旦有了其他的构造器，那么系统就不会再默认生成这个构造器。你也就再不能用“类名()”这种创建方法了。当然，当有其他构造器的时候，你也可以手动添加这个默认的构造器。 自定义构造器 可以定义构造器，可以传入自定义的参数列表来初始化类。自定义的构造器的外部参数名规则和方法不太一样，构造器的每一个参数都会生成和局部参数名一样的外部参数名。如果不想要外部参数名，还是可以用下划线取消 class Animal &#123; var life: Int = 0 var height: Double init()&#123; //注意，当有其他构造器的时候，系统不会再生成这个构造器，必须手动写出来 height = 0 &#125; init(life: Int, height: Double) &#123; self.life = life self.height = height &#125; &#125; //可以这样使用自定义的构造器 var a = Animal(life: 29, height: 1.2) 再次提醒，当有类定义里面有自定义构造器的时候，不会再自动生成默认构造器。并且对于结构体也再不会自动生成遍历属性的构造器。但是你可以将你自己的构造器写在扩展里面，这样就不会影响默认构造器的自动生成 构造器委托（Initializer Delegation） 构造器委托，就是在一个构造器里面调用另外一个构造器，这样可以减少多余的代码。在构造器里面使用self.init语法来调用另外一个构造器，且这个语法只能在构造器里面使用。构造器委托在值类型（结构体和枚举类）和类直接是不太一样的。因为类需要考虑到继承问题。先来看值类型的构造器委托。这个很简单，调用另外一个构造器就行了。下面的例子虽然有点脱裤子放屁的感觉，但。。就是举个例子而已 struct Apple &#123; var totalPrice: Double init(totalPrice: Double) &#123; self.totalPrice = totalPrice &#125; init(kg: Double, pricePerKg: Double) &#123; let totalPrice = kg * pricePerKg self.init(totalPrice: totalPrice) //调用另外一个构造器 &#125; &#125; 类的继承和初始化 因为类可以继承，所以它的初始化规则就变得比结构体要复杂多了。首先，类的构造器分为指定构造器（Designated Initializer） 和 便利构造器 （Convenience Initializer）一个类通常具有很少数量（一般只有1个）的指定构造器。但是必须最少具有一个。便利构造器是用来调用指定构造器完成初始化工作的。一个类可以不具有遍历构造器。两种构造器的语法 //指定构造器 init(parameters) &#123; statements &#125; //便利构造器 convenience init(parameters) &#123; statements &#125; 类的构造器委托规则： 1、一个指定构造器必须调用它的直接父类的指定构造器 2、一个便利构造器必须调用同一个类的另外的构造器 3、一个便利构造器必须最终以调用指定构造器结束。 规则2和3连起来就是说，一个便利构造器可能会调用了另外一个便利构造器，然后这个构造器又调用了另外一个便利构造器….但是这个链的最后的一个便利构造器必须是调用指定构造器。下面附上官方的图片。在图片上可以看到，三条规则总结起来就是：指定构造器往上调用，便利构造器平行调用且终结在指定构造器。 类的初始化分为两阶段第一阶段 1、一个指定构造器或便利构造器被调用 2、分配类实例所需的内存，但是内存没有初始化 3、这个类的指定构造器确保该类引入的新的存储属性都初始化。（因为便利构造器最终会到指定构造器）。 4、然后这个构造器调用父类的指定构造器完成和第三步同样的工作。 5、直到继承链的最顶部分。 6、这时候有的存储属性都有初始值了。 第二阶段 1、从继承链的最顶部分出发。每个指定构造器具有了修改实例的权利。并且可以调用实例方法。 2、最后，这个初始化链条里面的便利构造器都具有了修改实例的权利。 遵循上面两个阶段的步骤，避免了当在初始化链后面的构造器修改了属性之后，又被前面的构造器修改属性的可能性。避免了使用没有经过初始化的属性的可能性。 为了确保两个阶段步骤的实施。编译器有4条检测规则，这四条规则决定了你在构造器里面某些代码的顺序。 1、在调用父类构造器之前，必须确保子类引入的新属性已经得到初始化。 2、子类必须在调用了父类的构造器之后，才能访问继承的属性。 3、便利构造器必须在调用了其他构造器之后，才能访问属性或调用实例方法。 4、在完成第一阶段之前（其实就是完成初始化本类定义的新属性，调用父类构造器），构造器不能调用实例方法，不能访问属性的值，不能把self当做值访问。但是可以用self.属性名的方式给属性赋值。 下面可以看看分别违反每个规则的例子 class Animal &#123; var life: Int var height: Double init(getLife: Int, getHeight: Double) &#123; self.life = getLife self.height = getHeight &#125; &#125; class Dog: Animal &#123; var name: String init()&#123; super.init(getLife: 2, getHeight: 2.0) //这句报错，违反第一条，必须先将本类引入的属性初始化才能调用父类构造器 self.name = "Larry" //所以这一句必须写在前面才没错 &#125; init(name: String, getLife: Int, getHeight: Double)&#123; self.name = name self.life = 1 //这句报错，违反第二条，必须调用了父类构造器之后才能访问继承的属性。 super.init(getLife: getLife, getHeight: getHeight) //这句必须放在第二句之前才没错 &#125; convenience init(getLife: Int) &#123; self.name = "Larry" //这句报错，违反第三条，便利构造器里面必须调用了其他构造器之后才能访问属性 self.init() //这句应该放在前面 &#125; init(getName: String) &#123; self.name = getName Dog.sayHello() self.printName() //这句报错，违反第四条，必须完成了阶段1才能调用实例方法或访问属性 super.init(getLife: 21, getHeight: 2.3) //这句应该放在前面 &#125; func printName()&#123; print(self.name) &#125; static func sayHello()&#123; print("hello") &#125; &#125; 属性观察器 以前说过，属性观察器在构造器里面给属性赋值的时候是不会被调用的。但是这个只针对于本类定义的属性。对于继承而来的属性，当已经经过父类的构造器完成初始化后，如果在子类里面修改了继承属性的值，那么就会触发父类观察器，如果你在子类里面也覆盖了这个观察器，那么子类和父类的观察器都会被调用 另外再看 class Animal &#123; var life: Int = 0 &#123; willSet&#123; print("animial life newValue \(newValue)") &#125; &#125; init(getlife: Int)&#123; print("animal life init \(self.life)") self.life = 1 print("animal life after assign \(self.life)") &#125; &#125; 如果我们调用下面的语句 var a = Animal(getlife: 3) //打印 //animal life init 0 //animal life after assign 1 注意一点，我们在init里面第一句已经用到了self。根据编译器规则第四条，不允许在属性没有初始化的前进行访问。从上面代码通过编译来看，这里编译器已经将属性初始化为定义时候的值了。如果你将定义时候的默认值删去，那么第一句就会报错Swift默认是不继承父类的构造器的。如果你想要和父类一样的构造器，那么必须自己写。如果你写的构造器（不管是指定还是便利）和父类的指定构造器一样，那么这个构造器前必须加上override关键字。如果你写的构造器和父类的便利构造器一样，那么不用加override，因为子类永远不能直接调用父类的便利构造器。但是在某些情况下，子类可以自动继承父类构造器。前提条件：子类新引入的属性都必须具有默认值 规则1：如果子类没有定义任何的指定构造器。那么子类自动继承父类所有的指定构造器。 规则2：如果子类实现了父类所有的指定构造器（可以通过规则1继承而来，也可以通过重写而来），那么子类自动继承父类所有的便利构造器。 例子 class Animal &#123; var life: Int var height: Double convenience init(getLife: Int)&#123; self.init(getLife: getLife, getHeight: 0.0) &#125; init(getLife: Int, getHeight: Double) &#123; self.life = getLife self.height = getHeight &#125; &#125; class Dog: Animal &#123; var name: String = "Larry" // override init(getLife: Int, getHeight: Double)&#123; // super.init(getLife: getLife, getHeight:getHeight) // &#125; &#125; 无论上面Dog类里面注释的代码是否打开，Dog都继承了Animal的所有构造器 Failable Initializers可失败的构造器 Swift中有个概念，就是创建实例的时候如果条件不符合，可以返回一个nil对象。这类可以返回nil的构造器叫做可失败的构造器。语法是在init的前面加上一个？。当条件不满足的时候，你可以用 return nil结束构造方法。那么这时候得到的实例其实是一个nil，这里也说明了，可失败构造器返回的是可选类型。其实之前也说过，Swift的构造器是不需要返回值的。所以你成功的时候不需要写return什么东东。 值类型的可失败构造器下面是structure的 struct Apple &#123; var pricePerKg: Double init?(pricePerKg: Double)&#123; if pricePerKg &lt; 0 &#123; return nil &#125; self.pricePerKg = pricePerKg &#125; &#125; print(Apple(pricePerKg: 2)) print(Apple(pricePerKg: -2)) //打印 //Optional(SwiftTest.Apple(pricePerKg: 2.0)) //nil 接下来是枚举类的 enum FruitSet &#123; case apple, orange, banana init?(symbol: Character)&#123; switch symbol &#123; case &quot;a&quot;,&quot;A&quot; : self = .apple case &quot;o&quot;,&quot;O&quot; : self = .orange case &quot;b&quot;,&quot;B&quot; : self = .banana default : return nil &#125; &#125; &#125; print(FruitSet(symbol: &quot;a&quot;)) print(FruitSet(symbol: &quot;e&quot;)) //打印 //Optional(SwiftTest.FruitSet.apple) //nil 对应有默认值的枚举类，会自动生成一个init?(rawValue:)的构造器。如下 enum FruitSet : Character&#123; case apple = "a", orange = "o", banana = "b" &#125; print(FruitSet(rawValue: "a")) print(FruitSet(rawValue: "e")) 类的可失败构造器 有一个规则，就是必须在本类所有的属性（包括继承的）都赋值之后才可以返回nil class Apple &#123; var pricePerKg: Double init?(pricePerKg: Double)&#123; if pricePerKg &lt; 0 &#123; return nil //这句报错，所以你必须先初始化其他属性值 &#125; self.pricePerKg = pricePerKg &#125; &#125; 可失败初始化的传递过程 一个可失败的构造器可以调用其他的构造器，无论是可失败的还是不会失败的。 但是一个不可失败的构造器不能去调用一个可失败的构造器。如果去调用父类的可失败构造器，虽然用解包可以解决，但是一旦父类的可失败构造器返回了nil，那么程序直接崩溃 class Fruit &#123; var name: String init?(name: String)&#123; self.name = name if name.isEmpty &#123; return nil &#125; &#125; &#125; class Apple: Fruit &#123; var pricePerKg: Double init(pricePerKg: Double)&#123; self.pricePerKg = pricePerKg super.init(name: "")! //利用解包调用了父类的可失败构造器，但是因为这样父类会返回一个nil，所以程序在这行会崩溃 &#125; convenience init?()&#123; self.init(pricePerKg: 3) &#125; &#125; var i = Apple(pricePerKg: 3) 同样的，可失败的构造器也可以被重写，你可以重写为不可失败的构造器。但是不可失败的构造器不能覆盖为可失败的构造器。你可以用!代替?来实现可失败构造器，那么这样得到的实例会自动解包。当然，存在nil报错的问题。记得处理。 必须构造器（Required Initializers） 在构造器前面加上required关键字就行了。这样的构造器要求子类必须重写。子类重写这个构造器的时候，也必须加上required关键字。要求子类的子类也要重写这个构造器。写了required后不用写override关键字。写了会有警告。 给属性默认值时使用闭包或函数 func getprice()-&gt;Double &#123; return 1 &#125; class Apple &#123; var pricePerKg: Double = getprice() var name = &#123; return "apple" &#125;() //留意这对小括号，没有的话那就是给属性赋值一个闭包了。 &#125; var a = Apple() print(a.pricePerKg,a.name) 析构器 析构器，就是在一个实例再也不用到时候调用的方法。析构器里面完成一些清理工作或保存数据等等。析构器是系统自动调用的，不允许自行调用。 语法 deinit &#123; // perform the deinitialization &#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Inheritance-类继承基本用法]]></title>
<url>../../../../../../../../2017/12/01/Swift-Grammar/Swift-Grammar-Inheritance-类继承基本用法/</url>
    <content type="text"><![CDATA[类继承.&gt;继承是类独有的，结构体和枚举类都不具有这个功能。继承就好像子承父业一样，一个继承的类（称为子类subClass）可以获得被继承的类（称为父类superClass）的属性，方法和其他特性。 子类可以重写父类的方法，也可以添加自己的属性，还可以为继承而来的属性添加观察器（对继承而来的存储和计算属性都可以） 基类 一个不继承自任何类的类称为基类。在Swift中，是没有共同的终极父类的。oc和java都是有终级父类的 定义一个Animal基类 class Animal &#123; var life : Int = 0 var description: String&#123; return "An animal with a life of \(life)" &#125; func makeSounds() &#123; &#125; &#125; 继承语法 &lt;span style="color:#ff0000;"&gt;class Dog: Animal&lt;/span&gt; &#123; var name : String = "larry" &#125; 上面的Dog类继承自Animal类，并且添加了自己的name属性。我们可以修改一下dog继承的属性，然后打印一下 var dog = Dog() dog.life = 10 print("dog's life is",dog.life) //dog's life is 10 覆盖（override）父类属性 对于继承而来的存储属性或者计算属性，我们可以通过重写这个属性的getter和setter方法来实现覆盖。下面是几条规则： 1、当你重写了setter方法的时候，一定要重写getter方法。但是可以只重写getter方法。 2、覆盖属性的时候，属性名和类型都必须和继承的属性一致才算覆盖。并且前面要加上override关键字。 3、你可以将继承的只读属性重写为读写属性，但是不能将继承的读写属性重写为只读属性。 下面重写Animal的description属性 class Dog: Animal &#123; var name : String = "larry" override var description: String &#123; get&#123; return "It's a dog with the name of \(name)" &#125; &#125; &#125; 覆盖属性观察器 规则： 1、不能对继承的常量，或者只读属性添加属性观察器 2、不能同时对一个继承属性同时添加属性观察器和setter方法。因为setter方法已经可以提供属性观察器的功能。 3、即使覆盖了之后，如果父类的该属性有观察器，那么当值修改的时候，父类的观察器也会被调用 class Dog: Animal &#123; var name : String = "larry" override var life: Int &#123; didSet&#123; print("The dog's life is \(life)") &#125; &#125; override var description: String &#123; get&#123; return "It's a dog with the name of \(name)" &#125; &#125; &#125; 覆盖父类方法 同样的，加上override后，重写父类方法就可以 override func makeSounds() &#123; print("wang! wang!") &#125; 防止覆盖用final关键字去修饰就可以了。比如final var，final func， final class func， final subscript]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
        <category>Inheritance</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Subscripts-下标]]></title>
<url>../../../../../../../../2017/12/01/Swift-Grammar/Swift-Grammar-Subscripts-下标/</url>
    <content type="text"><![CDATA[下标 所谓的下标，就是[]在Array和Dictionary的时候就已经接触过了。它其实算一种特殊的方法，利用下标，我们可以将属性的getter和setter写在一起。而且还可以提供另外的一些功能。String截串的时候无比麻烦,利用下标和扩展（Extension）封装后变得很简单。这个在讲到扩展的时候在写出来吧。下标语法 subscript(index: Int) -&gt; Int &#123; get &#123; // return an appropriate subscript value here &#125; set(newValue) &#123; // perform a suitable setting action here &#125; &#125; 当然可以和计算属性一样将setter删去，变为只读。下面举一个使用例子。假设在买橙子。下标表示你要买多少斤，下标能返回总共价格。 当对下标赋值的时候，表示买那么多斤的时候总共花了多少钱。然后修改了橙子的单价.下标不止一个变量，还可以有多个变量。变量也可以是不同的类型 class Orange &#123; var pricePerKg: Double = 3 subscript(kg: Double, str: String) -&gt; Double &#123; get&#123; print(str) return kg * pricePerKg &#125; set&#123; print(str) self.pricePerKg = newValue / kg &#125; &#125; &#125; var o = Orange() print("price of 10kg orange ",o[10,"buy 10 kg orange"]) o[100,"buy 100kg orange"] = 250 print("price per kg when buying 100kg orange ",o.pricePerKg) //打印 //buy 10 kg orange //price of 10kg orange 30.0 //buy 100kg orange //price per kg when buying 100kg orange 2.5]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FF-Beichoo-有读-结构分布]]></title>
<url>../../../../../../../../2017/12/01/FF-Beichoo/FF-Beichoo-有读-结构分布/</url>
    <content type="text"><![CDATA[Main collect合集 合集列表-CollectListViewC 合集列表Cell - CollectListCell 合集列表Model - CollectListModel]]></content>
      <categories>
        <category>FF</category>
        <category>Beichoo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Method-方法]]></title>
<url>../../../../../../../../2017/12/01/Swift-Grammar/Swift-Grammar-Method-方法/</url>
    <content type="text"><![CDATA[Method 方法 其实就是函数，只不过方法是属于某个类、结构体、枚举类的函数方法的定义和函数一样。调用通过点语法实现。注意，方法和属性不能同名。但是类型方法可以和实例方法重名 Instance Methods实例方法 class Video &#123; func play(videoName: String) &#123; print("Now play",videoName) &#125; &#125; var v = Video() v.play("\"monkey king\"") //打印 Now play "monkey king" 在实例方法里面具有 self 属性，该属性就是指这个实例本身。学习过java或OC的应该很熟悉。就是用来当参数名和属性名一样的时候，用来区分究竟是哪个变量。 class Video &#123; var videoName: String? func play(videoName: String) &#123; self.videoName = videoName print("Now play",videoName) &#125; &#125; var v = Video() v.play("\"monkey king\"") print(v.videoName!) //打印 //Now play "monkey king" //"monkey king" 如果是对于结构体，因为它是值传递，所以一般方法里面如果和上面一样尝试修改存储属性的值的话，是不允许的。直接报错。如果需要修改，那么可以在方法前面加上mutating关键字changeVideo方法将整个self都赋值了一个新实例。因为枚举类是不存在存储属性的，所以没有上面修改属性的情况。但是self关键字还是有的 struct Video &#123; var videoName: String? mutating func play(videoName: String) &#123; self.videoName = videoName print("Now play",videoName) &#125; mutating func changeVideo(newVideo: String)&#123; self = Video(videoName: newVideo) &#125; &#125; var v = Video() v.play("\"monkey king\"") v.changeVideo("misson impossible") print(v.videoName!) //打印 //Now play "monkey king" //misson impossible Type Methods类型方法 这个和类型属性一样，加上static或class就行了。class允许子类覆盖父类方法 struct Video &#123; var videoName: String? static var playTime: Int = 0 mutating func play(videoName: String) &#123; self.videoName = videoName //这里是self指的是Video的实例 print("Now play",videoName) Video.playTime++ &#125; mutating func changeVideo(newVideo: String)&#123; self = Video(videoName: newVideo) &#125; static func showPlayTime()&#123; print(self.playTime) //注意这里的self是指Video这个结构体，而不是实例 &#125; &#125; var v = Video() Video.showPlayTime() v.play("\"monkey king\"") Video.showPlayTime() //打印 //0 //Now play "monkey king" //1 注意，调用类型方法只能通过类名的点语法来实现，不能通过实例的点语法。这点和类型属性是一样的。 关于这个类型方法，需要注意里面的self和实例方法里面的self指向的不是用一个东西，前者是指类型本身，后者是指类型的实例。 所以在类型方法和实例方法里面访问类型变量和实例变量也有不同。在实例方法里面访问类型变量，需要加上类型前缀。 在类型方法里面访问类型变量，可以加上类型前缀，用self，或者不加前缀。在类型方法里面是不能访问实例变量的]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Properties-属性]]></title>
<url>../../../../../../../../2017/12/01/Swift-Grammar/Swift-Grammar-Properties-属性/</url>
    <content type="text"><![CDATA[Properties Swift中，属性大致分为两种，存储属性+计算属性 Stored Properties存储属性 存储属性:能保存数据的属性。枚举类、结构体、类都具有存储属性存储属性可以设为var 或let。分别对应常量和变量 struct CPU &#123; var clockSpeed = 1.0 //变量 let coreNum = 2 //常量 &#125; 计算属性就是它本身不保存数据，而是通过处理其他的数据得到返回值。 结构体和类才具有计算属性然后我们初始化一个CPU实例，但是这个实例我们设置为常量。这样会导致一个后果：对应值传递的结构体，当实例是常量的时候，即使存储属性是变量，也不能修改里面属性的值 let cpu = CPU(clockSpeed: 3.2) //注意到这个初始化方法只有一个参数，因为我们设置了coreNum为常量，并且给了初始值，所以构造方法会发生变化 cpu.clockSpeed = 3.3 //这句会报错 然而对于引用传递的类来讲，即使实例是常量，里面设置为变量的存储属性还是可以更改值的 class Telephone &#123; var cpu = CPU() var screenSize: Int? var price: Int? &#125; let myTelephont = Telephone() myTelephont.screenSize = 4 懒加载存储属性Swift需要保证一个类或结构体或枚举类在初始化之后，所以的存储属性都必须有初始值（除开可选类型）。所以当实例初始化完成以后，所以的存储属性都初始化了。但是有些时候某些存储属性不一定会用到，所以我们可以把这些存储属性设置为lazy存储属性。那么它在要用到的时候才会进行初始化。lazy存储属性只能是变量。而且在多线程调用的时候，如果lazy属性没有初始化，那么不能保证只会初始化一次 struct CPU &#123; lazy var clockSpeed = 1.0 let coreNum = 2 &#125; let cpu = CPU() //这时候clockSpeed还是为nil Computed Properties 计算属性 故名思议，它本身不保存数据，只是用其他数据得到返回值，或者当设置它的时候修改其他数据。下面的例子利用存储属性得到apple的总价。或者修改总价的时候修改重量 struct Apple &#123; let pricePerKg = 6.0 var weight: Double var totalPrice: Double &#123; get &#123; return pricePerKg * weight &#125; set(newTotalPrice) &#123; weight = newTotalPrice / pricePerKg &#125; &#125; &#125; var apple = Apple(weight: 2.0) print(apple.totalPrice) //12.0 apple.totalPrice = 6.0 print(apple.weight) //1.0 算属性的setter方法新值自带一个默认名 newValue，所以上面的定义可以改为 struct Apple &#123; let pricePerKg = 6.0 var weight: Double var totalPrice: Double &#123; get &#123; return pricePerKg * weight &#125; set &#123; weight = newValue / pricePerKg &#125; &#125; &#125; 可以将计算属性的setter去掉，那么这个计算数据就变成了只读的。这时候还可以省去get关键字 struct Apple &#123; let pricePerKg = 6.0 var weight: Double var totalPrice: Double &#123; return pricePerKg * weight &#125; &#125; 不要在计算属性的setter和getter里面获取该计算属性，这样会导致循环调用 Property Observers属性观察器 有了属性观察器，我们可以在属性被修改的时候做一些事情。注意的是对于非继承而来的计算属性，没有必要设置属性观察器，因为直接可以在计算属性的setter定义中完成这项功能。 属性观察器有两个方法willSet 在属性将要赋值的时候调用，这时候属性的值还没改变didSet在属性值被赋值完的时候就会调用。（即使是赋值和原来值一样的值）这时候属性的值已经改变。willSet方法里面会传递新值过来，你可以自己定义这个新值的名称，如果不定义，会具有默认值newValuedidSet方法里面会传递属性的旧值过来，你可以自己定义这个旧值的名称，如果不定义，会具有默认值oldValue。如果你在didSet方法里面又对这个存储属性赋值，那么这个值会覆盖掉刚刚赋值的值。且不会导致循环调用。比如下面例子里面，当pricePerKg小于3的时候，会把它改为3 struct Apple &#123; var pricePerKg = 6.0 &#123; willSet(priceNewValue)&#123; print("In willSet, priceNewValue=",priceNewValue) print("In willSet, pricePerKg=",pricePerKg) &#125; didSet&#123; print("In didSet, oldValue=",oldValue) print("In didSet, pricePerKg=",pricePerKg) if pricePerKg &lt; 3 &#123; pricePerKg = 3 &#125; &#125; &#125; var weight: Double var totalPrice: Double &#123; get &#123; return pricePerKg * weight &#125; set &#123; weight = newValue / pricePerKg &#125; &#125; &#125; var apple = Apple(pricePerKg: 6.0, weight: 1.0) apple.pricePerKg = 2.0 print("apple.pricePerKg=",apple.pricePerKg) /* 输出 In willSet, priceNewValue= 2.0 In willSet, pricePerKg= 6.0 In didSet, oldValue= 6.0 In didSet, pricePerKg= 2.0 apple.pricePerKg= 3.0 */ Global and Local Variables全局变量和局部变量 所谓的局部变量，就是定义在函数、方法、闭包、类型上下文里面的变量。全局变量就是定义在函数、方法、闭包、类型上下文之外的变量。局部变量和全局变量都称为存储变量。在全局和局部范围内，都可以定义计算变量，或者为存储变量定义观察器 var apple = Apple(pricePerKg: 6.0, weight: 1.0) &#123; //为apple变量定义观察器 willSet &#123; print("newApple",newValue) &#125; didSet&#123; print("oldApple",oldValue) &#125; &#125; apple = Apple(pricePerKg: 6.0, weight: 2.0) var c: Double &#123; //定义一个计算变量 get&#123; return 9 &#125; set &#123; print("In setter,",newValue) &#125; &#125; c = 2 print(c) /* newApple Apple(pricePerKg: 6.0, weight: 2.0) oldApple Apple(pricePerKg: 6.0, weight: 1.0) In setter, 2.0 9.0 */ 官方文档说全局变量常量都是懒加载，局部变量常量都不是懒加载 Type Properties类型属性 所谓的类型属性，就是这个属性是属于这个类型的，即使这个类型由多个实例，也只会有一个类型变量。 类型属性是懒加载的，而且必须在定义的时候给初始值。 一般是用static来定义类型属性。特别的，对应类的计算类型属性，还可以用class关键字定义，这样可以使得子类可以覆盖它。 注意类型属性访问的时候用的是类名，不能使用实例来访问 struct SomeStructure &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 1 &#125; &#125; enum SomeEnumeration &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 6 &#125; &#125; class SomeClass &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 27 &#125; class var overrideableComputedTypeProperty: Int &#123; return 107 &#125; &#125; print(SomeStructure.storedTypeProperty) // prints "Some value." SomeStructure.storedTypeProperty = "Another value." print(SomeStructure.storedTypeProperty) // prints "Another value." print(SomeEnumeration.computedTypeProperty) // prints "6" print(SomeClass.computedTypeProperty) // prints "27"]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-图片的解压缩]]></title>
<url>../../../../../../../../2017/11/30/iOS-Func/iOS-Func-图片的解压缩/</url>
    <content type="text"><![CDATA[http://blog.leichunfeng.com/atom.xml]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-GCD-多线程编程GCD]]></title>
<url>../../../../../../../../2017/11/30/iOS-Garmmar/iOS-GCD-多线程编程GCD/</url>
    <content type="text"><![CDATA[http://blog.mogoal.com/2016/09/12/grand-central-dispatch/]]></content>
      <categories>
        <category>iOS</category>
        <category>GCD</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-类和结构体]]></title>
<url>../../../../../../../../2017/11/30/Swift-Grammar/Swift-Grammar-类和结构体/</url>
    <content type="text"><![CDATA[类和结构体简叙 类和结构体是人们构建代码所用的一种通用且灵活的构造体可以使用完全相同的语法规则来为类和结构体定义属性（常量、变量）和添加方法，从而扩展类和结构体的功能。与其他编程语言所不同的是，Swift并不要求你为自定义类和结构去创建独立的接口和实现文件所要做的是在一个单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口。注意通常一个类的实例被称为对象然而在Swift中，类和结构体的关系要比在其他语言中更加的密切，主要使用实例而不是对象 类和结构体对比类和结构体的共同点在于定义属性用于存储值定义方法用于提供功能定义附属脚本用于访问值定义构造器用于生成初始化值通过扩展以增加默认实现的功能实现协议以提供某种标准功能 与结构体相比，类有如下的附加功能继承允许一个类继承另一个类的特征类型转换允许在运行时检查和解释一个类实例的类型析构器允许一个类实例释放任何其所被分配的资源引用计数允许对一个类的多次引用 结构体总是通过被复制的方式在代码中传递，不使用引用计数 定义语法使用关键字class和struct表示类和结构体 每次定义一个新类或者结构体的时候，实际上你是定义了一个新的Swift类型因此使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），以便符合标准Swift类型的大写命名风格（如String，Int和Bool）相反的，请使用lowerCamelCase这种方式为属性和方法命名（如framerate和incrementCount），以便和类型名区分 struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String? // 可选类型，自动赋值为nil&#125; 类和结构实例 结构体和类都使用构造器语法来生成新的实例构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如Resolution()或VideoMode()通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值属性都必须赋初值！否则编译报错，可选类型可不赋值，实际上默认赋值为nil struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String? // 可选类型，自动赋值为nil&#125;let r = Resolution()let v = VideoMode()print(r) // Resolution(width: 0, height: 0)print(v) // VideoModeprint(v.resolution) // Resolution(width: 0, height: 0)print(v.interlaced) // falseprint(v.frameRate) // 0.0print(v.name) // nil 属性访问 通过使用点语法（dot syntax），你可以访问实例的属性其语法规则是，实例名后面紧跟属性名，两者通过点号(.)连接也可以使用点语法访问子属性。也可以使用点语法为变量属性赋值 ```&gt;与Objective-C语言不同的是，Swift允许直接设置结构体属性的子属性，并不需要重新为整个resolution属性设置新值 struct Resolution { var width = 0 var height = 0} class VideoMode { var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String? // 可选类型，自动赋值为nil} let v = VideoMode()print(v.resolution) // Resolution(width: 0, height: 0)v.resolution.width = 1920v.resolution.height = 1080print(v.resolution.width) // 1920# 结构体类型的成员逐一构造器&gt; 所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性&gt; 新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中&gt; 与结构体不同，类实例没有默认的成员逐一构造器```swiftstruct Resolution &#123; var width = 0 var height = 0&#125;var r = Resolution(width: 1920, height: 1080)print(r) // Resolution(width: 1920, height: 1080) 结构体和枚举是值类型 值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝面我们已经大量使用了值类型。实际上，在 Swift中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。在Swift中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制 struct Resolution &#123; var width = 0 var height = 0&#125;var r = Resolution(width: 1920, height: 1080)print(r) // Resolution(width: 1920, height: 1080)var rr = rprint(rr) // Resolution(width: 1920, height: 1080)，两个完全独立的实例碰巧包含有相同的数值rr.width = 2048print(r) // Resolution(width: 1920, height: 1080)，由于r和rr相互独立，所以值不改变print(rr) // Resolution(width: 2048, height: 1080)enum CompassPoint &#123; case North, South, East, West&#125;var a = CompassPoint.Northvar b = aprint(b) // Southb = CompassPoint.Southprint(a) // Northprint(b) // South 类是引用类型 与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝 struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String? // 可选类型，自动赋值为nil&#125;let a = VideoMode()a.frameRate = 25 // a是常量，但是可以修改属性，因为a本身没有改变let b = ab.frameRate = 30print(a.frameRate) // 30.0// a = VideoMode() // error: cannot assign to value: 'a' is a 'let' constant 注意，a和b被声明为常量而不是变量。然而你依然可以改变a.frameRate和b.frameRate，因为a和b这两个常量的值并未改变。它们并不“存储”这个VideoMode实例，而仅仅是对VideoMode实例的引用。所以，改变的是被引用的VideoMode的frameRate属性，而不是引用VideoMode的常量的值 恒等运算符 因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift内建了两个恒等运算符运用这两个运算符检测两个常量或者变量是否引用同一个实例 等价于（===）不等价于（!==） 等价于”（用三个等号表示，===）与“等于”（用两个等号表示，==）的不同 等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法当你在定义你的自定义类和结构体的时候，你有义务来决定判定两个实例“相等”的标准 struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String? // 可选类型，自动赋值为nil&#125;let a = VideoMode()a.frameRate = 25 // a是常量，但是可以修改属性，因为a本身没有改变let b = ab.frameRate = 30// if a == b &#123; // 两个引用类型之间使用“==”运算符，会出现编译错误：error: binary operator '==' cannot be applied to two 'VideoMode' operandsif a === b &#123; print("a === b") // a === b&#125; else &#123; print("a !== b")&#125; 指针如果你有C、C++或者Objective-C语言的经验，那么你也许会知道这些语言使用指针来引用内存中的地址。一个引用某个引用类型实例的Swift常量或者变量，与C语言中的指针类似，但是并不直接指向某个内存地址，也不要求你使用星号（*）来表明你在创建一个引用。Swift中的这些引用与其它的常量或变量的定义方式相同 类和结构体的选择可以使用类和结构体来定义你的自定义数据类型。然而，结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体： 该数据结构的主要目的是用来封装少量相关简单数据值。 有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。 该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。 该数据结构不需要去继承另一个既有类型的属性或者行为。 举例来说，以下情境中适合使用结构体： 几何形状的大小，封装一个width属性和height属性，两者均为Double类型。 一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。 三维坐标系内一点，封装x，y和z属性，三者均为Double类型。 在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体 字符串、数组和字典类型的赋值与赋值行为Swift中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。Objective-C中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。注意，以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift在幕后只在绝对必要时才执行实际的拷贝。Swift管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FF-Beichoo-有读-API文档]]></title>
<url>../../../../../../../../2017/11/29/FF-Beichoo/FF-Beichoo-有读-API文档/</url>
    <content type="text"><![CDATA[登录注册推荐推荐页-列表 action special/recommend prama 字段 描述 Other config.isSign = NO 未登录设置签名 默认YES user_id 用户ID 登录必传／不登录可不传 page_size 当前请求数据条数 传 3（可不传） interest 用户感兴趣分类 未登录必传、登录可不传 result 返回参数:&#123; code = 0; data = &#123; "banner_list" =banner轮播图模块 ( &#123; img = 图片链接; title = 图片主题; type = 图片跳转界面类型;（article：文章、collection：合集、h5：h5界面） url = 跳转界面需要接受参数; &#125; ); "collection_master_list" = 收藏达人模块 ( &#123; brief = 达人描述; me = 是否是我（1：是我、0不是我）; name = 达人姓名; portrait = 达人头像链接; "user_id" = 达人用户id; &#125; ); "good_collection_list" = 精选合集模块 ( &#123; brief = 合集描述; cover = 合集封面图; "issuer_logo" = 合集作者logo; "read_num" = 已经阅读过人数; id = 合集id; source = 合集来源; title = 合集标题; &#125; ); "guess_collection_list" =猜你喜欢模块 ( &#123; brief = 合集描述; cover = 合集封面图; id = 合集id; me = 是否是我（1：是我、0不是我）; source = 合集来源; title = 合集标题; &#125; ); "hot_article_zixun" = 资讯滚动展示模块 ( cover = 合集封面图; id = 资讯链接; "issuer_nickname" = 作者名称; source = 资讯来源; title =资讯标题; &#125; ); "my_collection_list" = 我的订阅模块 ( &#123; cover = 合集封面图; id = 合集id; "new_article_num" = 最近更新文章数; me = 是否是我（1：是我、0不是我）; source = 合集来源; title = 合集标题; &#125; ); &#125;;&#125; 推荐页- 猜你喜欢刷新接口 action collection/guess_collection Prama 字段 描述 Other user_id 用户id 登录必传／不登录可不传 page_size 当前请求数据条数 传 3（可不传） interest 用户感兴趣分类 未登录必传、登录可不传 netTool.config.isSign = NO 未登录传参 result 返回参数:&#123; code = 0; data = &#123; "guess_collection_list" = 猜你喜欢模块 ( &#123; brief =合集描述; category = 合集类型; "collection_user_id" = 合集用户id; cover = 合集封面图; "custom_cover" = 高清封面图; "forwarding_num" = 转发数量; id = 合集id; "issuer_logo" = 合集作者logo; "issuer_nickname" = 合集作者名称; "read_num" = 阅读人数; source = 合集来源; title = 合集标题; uri = yiheyingxiao; &#125; ); &#125;;&#125; 轻读轻读列表 action special/light_reading 轻读 parameters 字段 类型 描述 refresh Int 值 1 (第一次进入界面传入以及后续下拉刷新，目的为清除缓存) user_id string 用户id interest array 用户兴趣分类(未登录传入) page Int 值 1.2.3 当前获取数据页码 result dic &#123; code: 0, data: item:[ &#123; tab:2 , 2是正常推荐 type:collection(跳转合集),article (跳转文章) me: 是否属于自己， 0不属于 1属于 title: 合集标题 cover: 合集封面 brief: 合集简介 source: 来源 id: 合集ID recommend_num: 推荐人数 read_num: 阅读数量 type: article, recommend_num: 推荐人数, title: 文章标题, issuer_nickname: 发行人名字, cover: 文章封面, read_num: 阅读数量, source: 文章来源, id: 文章ID &#125;, ] page_num: 当前页面, page_max: 最大页面 &#125;&#125; 个人当前登录人-信息页 action(GET/POST) user/my_user_info parameters 参数 user_id Int 用户ID ts Int 时间戳 nonce Int 6位随机数 more Int (more=1会返回创建的合集数量和最近阅读) result 字段 类型 描述 code Int 返回码 data Json {…} &#123; code: 0, data: &#123;​ name: 名字,​ career: 职业,​ company: 公司,​ portrait: 头像,​ read_num: 查看多少篇文章,​ read_time: 阅读时长,​ viewpoint_num: 观点数量​ new_follow_num: 新的关注人数,​ has_message: 是否有新消息,​ message_dic: &#123;​ user_follow: 0, 访客​ message_system: 0, 系统消息​ user_commented: 0, 评论​ comment_praised: 0 点赞​ &#125;​ 如果more==1，多两个字段:​ viewpoint_praise_num: 30天内观点被赞次数,​ visited_num: 被访问数,​ interest: [](array)​ create_collection_num: 创建合集数量,​ create_collection_list: [​ source: youdu,​ cover: 合集封面,​ id: 合集id​ title: 合集名称​ ]​ collection_read_list: [​ ['合集名', '查看文章数量']​ ...​ ]​ article_list:[​ &#123;​ issuer_nickname: 合集名字​ issuer_logo: 合集图片​ title: 文章标题​ cover: 文章封面​ read_num: 文章阅读数量​ id: 文章id,​ recommend_num: 推荐数​ &#125;​ ...​ ]​ visitor_info_list: [​ &#123;​ portrait: 用户头像,​ user_id: 用户id​ &#125;​ ] &#125;]]></content>
      <categories>
        <category>FF</category>
        <category>Beichoo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FF-Beichoo-有读1.1.2开发文档]]></title>
<url>../../../../../../../../2017/11/29/FF-Beichoo/FF-Beichoo-有读1.1.2开发文档/</url>
    <content type="text"><![CDATA[结构图 （1.1.2 ） 开发资料原型文档Tower App多处需求部分(岳) 浏览数据显示 **XX人读过** HUD 默认菊花转动 合计详情 呈现字段：标题，作者，浏览字段，描述 合集为空（无文章列表） 占位图占位文字 “这里空空如也” 评论为空时 占位文字为“快来抢占第一沙发” 合集-详情(岳) 合集描述1.后台下发2.显示几行 合集信息 浏览人数de样式 (岳)（OK）UILabel的text xxx人看过 格式改为 xxx人读过 合集文章图标显示 红点角标 (岳)（OK）最新更新文章更改，文章图 imageview 的右侧显示 角标 合集- 列表- 文章 -图标 (岳)（OK)修改要求: 去掉 创建合集界面——添加介绍输入口 （黄）==================================================== 文章详情 重点弹出修改 （牛）（OK)1、导航右侧btn click后，弹出重点2、无重点 给与提示 显示浏览人数UILabel H5端完成后，iOS需要检查（牛）注册后填写个人信息 你的职业 （周）1.必填 右侧加图标2.展开选择 双tableView 工作年限 （周）1.必填 右侧增加图标 下一步 （周） 1. 职业+年限 增加加判断。HUD提示 ==================================================== 分享文章、合集分享样式 （周）分享 评论图样式 （周）检查更新 （周）个人首页 （周） 设置登录未登录，不再区分 自己还是他人，改为通用推荐 （黄）增加个人信息窗口完善入口（黄）添加求(升)职模块、我的订阅模块分有无订阅数据（黄） 区头标题 -修改格式 区头标题 = [job类型]+ 升/求 + 职必读右侧增加 跳转导引 &gt; 区头标题 -修改标准 1.根据岗位类型判断标题 岗位=“在校学生” 标题=求职必读 其余=升职必读2.如岗位=“产品”或“运营”则 [job]=产品 或 运营或岗位=“在校学生”且引导页感兴趣的分类=“产品经理” 或 “市场运营”则 [job]=产品 或 运营else [job]隐藏，左侧对齐3.下方分类根据[job]岗位判断分类预览，[job]=产品 或 运营时，下方预览分类呈现对应的岗位内容分类，其他分类需点击“全部岗位内容”查看；如[job]≠产品或运营，下方内容分类直接呈现预览8个普通分类，按照现有分类框架排序依次呈现 区尾 呈现逻辑更改：1.无订阅此模块不呈现，2.有订阅，无更新内容，此模块呈现单行入口（文字提示今日暂无更新），无内容预览，3.有订阅，有更新内容，此模块按照现有界面样式仅呈现有更新的合集 合集-列表表头 （岳）1.不可点击 分页选项卡- 分页组 （岳）======================================= 轻读cell里浏览数据修改（牛） 显示浏览数据的Lab 修改更改文案数字+“人读过” UM 统计登录信息（岳）（OK ）======================================= 个人中心（当前登陆者）我的信息页面个人主页我的订阅&gt; 合集 -浏览数据修改 数字+“人读过” 个人中心-个人主页 -动态 文章，合集动态里，浏览数据修改 数字+“人读过” 个人中心-个人主页 -订阅合集 合集 -浏览数据修改 数字+“人读过” ======================================= 任务进度跟踪2017、11、31 注册后填写个人信息，功能的实现（UI API 尚未出）轻读页文案修改，和文章页进入不显示重点弹框排查程序卡顿（尚未定位出），修改部分因线程操作导致卡死的风险（修改3处）合集信息修改（剩余增加UILabel显示合集描述）,合集列表文章文案修改 2017、12、1 周少停 合集分享 微信 朋友圈 微博 字段修改 文章分享 微信 朋友圈 字段修改 RN 和 iOS 原生的简单交互 复习 牛心怀 新需求没有做更改，重构文章详情页 黄春晓 订阅模块有无订阅和最新更新文章数各种情况的显示处理 Ykk 合集详情和全局一些修改，合集列表只加了colelctionView 2017、12、5 周少停 添加检查更新 集成二级列表 学习RN 牛心怀 文章详情页重构 导航条按钮类别封装， 工具类新增跳转登录封装 黄春晓 banner宽度适配，RN工具安装与基本语法学习 Ykk 研究Swift3 下的泛型，函数等，做笔记，写简单demo 2017、12、6 牛新怀 文章页代码剥离 文章页预处理判断。防止html出现空白 优化点击评论系统弹框延迟弹出问题 周少停 修改我的 页面 添加评论 分享页面 黄春晓 学习React Native入门部分 Props（属性）、State（状态）、样式、高度与宽度、使用FlexBox布局 Ykk Swift语法初步过一遍 Swift UI- btn label tableView 等控件挨个过 2017、12、7/8 牛新怀 文章页，对话详情，观点详情，界面点赞，分享UI修改 统一对话详情，观点详情，文章页系统弹框样式 swift学习基础 周少停 完成 二级列表 完成 观点 分享 统计次数 版本更新 逻辑完成 (UI没写) rn 完成 基本的视图混合 (上半部:iOS 下半部:rn) 黄春晓 banner适配调整。 推荐页我的订阅逻辑修改 ReactNative工具安装与基础语法学习 Ykk swift 语法+UI 增加网络监测+网速监测 2017、12、11 黄春晓 产品需求变化，我的订阅展示逻辑修改 升求职模块框架与UI完成，等待数据接入 牛新怀 解决自定义导航条在iOS低版本上出现问题，增加版本判断 周少停 我的 界面 二级职业 添加 分享界面 参数获取 Ykk Swift 表+mdoel+cell 书写，对几种访问控制研究 OC 内存监测方法优化 奔溃信息捕捉 堆栈信息解析等研究 修改合集详图 布局问题 2017、12、12 黄春晓 RN研究 牛新怀 文章页，轻读页增加自动释放池处理 周少停 红点 添加 (尚未自测) 2 UI修改 Ykk Swift简单实用tablview 2017、12、13 黄春晓 推荐页—&gt;iOS11中tableView新特性适配 ReactNative集成原生应用学习 牛新怀 增加tabbar阴影效果 统一给ViewWillAppear增加super方法 swift学习，今天主要用swift写了一个小框架，并且实现了类似项目中的tab点击动画效果 周少停 观点分享界面 修改 UI 我的界面 未登录界面修改UI Ykk 合集详情修改部分 Swift 表书写/方法归纳]]></content>
      <categories>
        <category>FF</category>
        <category>Beichoo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Code上架配置文档]]></title>
<url>../../../../../../../../2017/11/29/iOS-Code/iOS_Code_上架配置文档/</url>
    <content type="text"><![CDATA[#第三方服务平台对接 辈出设计登录，分享 ##阿里云(直播类一般需要，不需要跳过) -（https://www.aliyun.com购买一年只要10个月的费用，oss和 slb 是按流量收费，请保证账户有余额）500并发 一月 账号：xxxxx密码：xxxxx ##腾讯云(直播类一般需要，不需要跳过) 腾讯云请使用qq或qq邮箱注册（https://www.qcloud.com账户需充值）差认证账号：xxxxxx密码：xxxxxxSdkAppId ：1314xxxxaccountType ：1314xxxx 短信平台 iOS 只要注意短信可用即可 QQ登录的功能（open.qq.com） 登录的APP ID：xxxxAPP KEY：xxxxx app上的腾讯地图 app上的腾讯地图key信息（HYPERLINK “http://lbs.qq.com/index.html&quot;http://lbs.qq.com/index.html）您的腾讯地图的 key：xxxxx账号：xxxx密码：xxx App新浪微博登 App新浪微博登录信息（ HYPERLINK “http://open.weibo.com/development/mobile“ http://open.weibo.com/development/mobile）App Key： xxxx不要微博APP secret：xxxx账号： xxxx密码： xxxx 微信开放平台 HYPERLINK “https://open.weixin.qq.com/“ https://open.weixin.qq.com/您的微信的APP ID：xxxxxAPP secret：8xxxxx账号：xxx密码：xxxx 开通微信支付(Beichoo暂时不需要) 开通微信支付（直播需要文网文）：用于观众支付（具体操作步骤请参考售后文档-后台需要配置的地方-微信支付文档）并留意和保留相关邮箱，等交付后台后填写到后台的资金管理-支付接口列表-微信支付。 注：最后确认分享到朋友圈、发送给朋友、微信登录和微信支付（直播需要文网文）的接口都已经获得。 企业微信公众号的服务号信息 您的微信公众号名称：xxxxxx开通微信支付：用于主播提现（具体操作步骤请参考售后文档-后台需要配置的地方-微信提现文档）并留意和保留相关邮箱，等交付后台后填写到后台的资金管理-支付接口列表-微信提现。开通企业付款到用户 ##企业支付宝申请/签约及app支付申请（直播需要文网文） 企业支付宝申请、签约及app支付申请（直播需要文网文）您的支付宝账号： XXXXXX ##友盟账户信息 HYPERLINK “http://www.umeng.com“ http://www.umeng.com账号：xxxxxx密码: xxxxx #苹果开发者账号 苹果开发者账号：738816656@qq.com（具体找相关人要）密码：xxxxxxxx如有有内购银行卡卡号：6236 6818 2000 3886 174开户行： 中国建设银行持卡人姓名：岳克奎12位识别码（打电话问银行）：105391004150 app名称和BID app名国内发布APP，名字是中文 在项目info文件里边，把Bundle display name 填写一个中文名字，Localization native development regior 选择中国。如果刚才提到的两个都没有，自己手动添加即可 Bundle identifier 命名规范 命名规范，且具有唯一性，因为在发布时候，描述证书要匹配当前id。一般采用com/cn +公司名+项目名，例如com.jindong.jd注：在申请QQ、微信、地图、微博等第三方所需填写的包名均要与此包名统一，如果不统一就会导致各功能无法正常使用 Version 格式： 1.1.1 最好写3位 Build: 格式： 1 （写整数 1，2，3，4，5即可） Clean 通知全员提交代码 预先跑一边，自测，然后，clean工程，僵尸模式，断点统统清楚 Edit Scheme 必须改为 Release 开发环境 FFConfig.h服务器接口 #define APP_ENVIRONMENT_EDITION 0 0 上线 （不准Mac跑去测，必须打包TestFlight方式） 1 开发 2 测试 3 stage 服务器版本目前0.1版本 #define API_VERSION @&quot;/bc/0.1/&quot; Push Notification 务必打开 平时这个不要关了！！！ Applinks 开启H5跳转App App 信息 iTunesConnect:https://itunesconnect.apple.com/login iTunesConnect点击—&gt;登录 根据运营会给 多套 关键字，副标题，多种语言环境为了在构建版本里，多加几套关键字 构建版本截图 发布时 来传]]></content>
      <categories>
        <category>iOS</category>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git-基本使用]]></title>
<url>../../../../../../../../2017/11/29/Git/Git-基本使用/</url>
    <content type="text"><![CDATA[基本使用初始化仓库 创建普通仓库 $ git init 创建裸仓库，这里面许多git命令不能使用，切换分支都不可用，一般用来当远程仓库 $ git --bare init 别名 使用config alias.命令进行，添加–global参数后可以对全局git的config文件进行配置 $ git config --global alias.st status 一个很吊的配置，让你的git变得更好看，摘自 $ git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 本地的一些命令 配置信息 $ git config user.name &quot;名字&quot; git config user.email &quot;email&quot; branch分支相关命令 $ git branch -a //显示所有分支 git branch 分支名字 //如果该分支不存在，就会新建 git branch --delete 分支名字 //删除分支 add将本目录下的文件都添加到暂缓区，准备提交用 $ git add . commit 提交 $ git commit -m &quot;注释&quot; merge这个命令会将本分支merge别处的分支。 $ git merge merge过来的分支 远程命令 添加远程仓库 $ git remote add &lt;远程主机名&gt; url push，命令格式： &amp; git push 远程主机名 本地分支:远程分支 举个例子下面命令将本地分支a，push到远程主机origin的a_remote上，如果远程主机里面没有a_remote分支，那么就会创建一个这名字的分支。 $ git push origin a:a_remote 注意：如果没有远程分支的名字，那么将会在远程仓库建立一个同名的分支。如果没有本地名字，就像 :a_remote，这就相当于传了一个空的分支给远程， 那么会删除掉远程仓库的这个分支。 pull这个命令会将本地和远程分支进行merge，如果出现冲突，需要自己解决。 命令格式： $ git push 远程主机名 远程分支:本地分支 例子在此，将远程主机的 $ git pull orgin a_remote:a 发生冲突的时候，如果需要丢弃本地工作，那么使用 $ git reset --hard branch相关的远程命令将远程分支和本地分支相关联 git branch --track 本地分支 远程主机/远程分支 //在创建本地分支的时候指定它所关联的远程分支 git branch --set-upstream-to 远程主机/远程分支 //将当前分支关联远程分支 fetch这个命令将远程的分支fetch下来，然后可以将这些fetch下来的分支和本地分支进行合并 git fetch 主机名 git fetch -p 主机名 //fetch完成后，删除本地仍存在，但是远程不存在的分支关联 下面的命令将本地分支绑定远程分支，但好像并没什么用，push的时候如果不输入远程分支名字，那么还是会新建一个和本地分支同名的远程分支。 git branch --set-upstream-to origin/aa_remote stash在进行pull的时候，经常会遇到 error: Your local changes to the following files would be overwritten by merge: xxx/xxx/xxx.java Please, commit your changes or stash them before you can merge. Aborting 这里要么将你当前的工作commit一下，要么就可以使用stash命令。先用stash命令缓存当前工作，然后pull，pull后再用stash pop还原之前的工作 $ git pull ... file foobar not up to date, cannot merge. $ git stash $ git pull $ git stash pop 另外的情况就是：你在工作的时候，突然被老板要求去改别的东西，你也可以用stash把当前的工作缓存起来。改完别的东西后再回来继续工作。 其他 $... hack hack hack ... $ git stash $ edit emergency fix $ git commit -a -m &quot;Fix in a hurry&quot; $ git stash pop # ... continue hacking ... 最后一些坑 1、初始化的仓库要先commit一下才能新建分支 2、如果远程仓库在使用这个分支，那么不能提交到这个分支上去，除非建立bare仓库，但是bare仓库不能使用git命令。]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Classes/Structures类和结构体]]></title>
<url>../../../../../../../../2017/11/29/Swift-Grammar/Swift-Grammar-Classes-Structures类和结构体/</url>
    <content type="text"><![CDATA[类和结构体简叙述 Swift中，类和结构体是很相近的。所有下面类和结构体的实例都统称为实例。不再单独为类的实例称为对象。和C或OC，不同，swift的类只写在一个文件里面。这点和java一样。 类和结构体的共同点： 1、能定义属性用来存储值 2、能定义方法实现功能 3、能定义下标来得到值 4、具有初始化构造器初始化实例 5、能被扩展 6、能实现协议 类比结构体多出来的特点： 1、能被继承 2、能在运行时使用类型转换判断一个实例是否为某个类 3、具有析构器 4、引用计数可以大于1，使得可以有多个引用指向同一个类的实例（注明：结构体是值传递，所有没有引用计数） 下面定义一个类和结构体，这里先提一下，类的每个属性都给了默认值，除了可选类型之外。这个是swift要求的，以后文章会详细讲到。 struct CPU { var clockSpeed = 1.0 var coreNum = 4 } class Telephone { var cpu = CPU() // CPU()是CPU结构体的默认构造器。它生成一个CPU实例，以后构造器的文章详细讲这方面内容 var screenSize = 5.0 var price: Int? }然后定义他们的实例 var myTelephone = Telephone() var newCPU = CPU()注意结构体是值传递，而类是引用传递。下面的代码清楚说明了这个特点。 var myTelephone = Telephone()var newCPU = CPU() print(myTelephone.cpu.clockSpeed) //1.0 swift使用点语法来获得属性 newCPU.clockSpeed = 2.0 myTelephone.cpu = newCPU //给myTelephone一个新的CPU print(myTelephone.cpu.clockSpeed) //2.0 newCPU.clockSpeed = 2.2 print(myTelephone.cpu.clockSpeed) //2.0 赋值后修改newCPU并不影响myTelephone里面的CPU var cpu = myTelephone.cpu //取出一份CPU，但是是值传递 cpu.clockSpeed = 3.0 print(myTelephone.cpu.clockSpeed) //2.0 所以修改取出的cpu不影响myTelephone里面的 var yourTelephone = myTelephone // 定义一个yourTelephone，它指向myTelephone的同一个实例 yourTelephone.screenSize = 6.0 print(myTelephone.screenSize) //6.0 修改yourTelephone会影响myTelephoneArray，String，Dictionary都是值传递。这个和OC是不一样的。值得注意。 结构体自带一个遍历所有属性的构造器，但是类没有。 var cpu2 = CPU(clockSpeed: 3.3, coreNum: 8) 操作符 === 和 !=====用来判断两个变量是否指向同一个类的实例。如果是返回true。 !==反之。指向不同实例，返回true。 而 == 是判断两个实例是否“相等”，这个相等的条件可以有类的定义者自己决定。]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Garmmar-Enumerations枚举类]]></title>
<url>../../../../../../../../2017/11/29/520/</url>
    <content type="text"><![CDATA[枚举类 Swift中的枚举和C中的枚举不一样,枚举类而不是枚举类型,它是值传递在C中，枚举类型中的每一项都整形然而在Swift中，你不必为每一项赋值。定义的时候所用的名字就是用来枚举的。当然也可以为枚举成员赋值，这个赋值不单单是整形，可以是Charater，String，浮点数。 定义一个枚举类型注意首字母已经大写分行或一行，用逗号分隔 enum Nameset&#123;case LuGaygaycase LiaoliaoCase Ykk&#125;或 enum Nameset&#123;case LuGaygay, Liaoliao,Ykk &#125; 定义一个枚举变量var myName = Nameset.Ykk或myName = .Ykk Associated Value 用来给每一个枚举成员再定义一个补充值 品的条形码和二维码。条形码是由一串数字组成的，这个数字分为了4个部分。而二维码其实是用一串很长的字符来编码的。如果要把二位码和条形码封装成为一个枚举类型，为了更好地区别二者，我们可以加上associated value，定义如下 enum Barcode &#123; case UPCA(Int, Int, Int, Int) //条形码 case QRCode(String) //二维码 &#125; 定义Barcode变量，同是添加上associated value var productBarcode = Barcode.UPCA(8, 85909, 51226, 3) productBarcode = .QRCode("ABCDEFGHIJKLMNOP") 注意的一点是，如果你定义了associated value，那么在定义变量的时候就和前面的NameSet不太一样了。看下面的两句代码b1是Barcode类型b2是(String) -&gt; Barcode类型，一个函数类型 var b1 = Barcode.UPCA(8, 85909, 51226, 3) var b2 = Barcode.QRCode ``` &gt;以下戴拿 错误 不能将 Barcode类型是值赋给 (String)-&gt;Barcode.这里就可以看出了，其实Barcode.QRCode(String:)是一个构造函数，这里再次验证了swift中的枚举是一个类```swift b2 = Barcode.QRCode("fef") //error NameSet里面可以直接用.Tom之类来赋值,估计是定义associated value的时候，相当于把该枚举成员从一个值变为了构造方法。 switch语句来处理枚举类 用swift强大的switch语句来处理枚举类，除了一般的枚举成员之外，对于带associated value 的成员，我们还可以得到associated value enum NameSet &#123; //重新定义一个简单的枚举类 case Lucy case otherName(String) &#125; var myName = NameSet.Lucy myName = .otherName("Alexs") switch myName &#123; case .Lucy: print(myName) case .otherName(var inputName): //使用括号解包出associated value print(inputName) //只有这句会打印出 Alexs &#125; 修改一下上面的switch如下打印的是otherName switch myName &#123; case .Lucy: print(myName) case .otherName: print("otherName") case .otherName(var inputName): print(inputName) &#125; //打印的是otherName 里可以看出，switch里面的.otherName和声明枚举变量时候的不同，这里已经是值NameSet的值了。而且上面的Switch也会有警告说最后一个case永远不能执行。括号只是用来解包出associated value，而不是构造方法为了验证这一点，再改改上面代码 var myName = NameSet.Lucy switch myName &#123; case .Lucy(let name): print(name) case .otherName: print("otherName") case .otherName(var inputName): print(inputName) &#125; //打印你会发现这里打印了 ()，因为解包Lucy没有得到值 switch语句，之前说过只有穷尽枚举的时候才不需要default选项。上面的例子中因为把NameSet里面所有可能都枚举了，所以不需要default选项 Raw Value 这个就是对每一项枚举成员绑定一个值，好比是C里面的枚举成员都是一个整形如果需要Raw Value，必须在声明枚举类的时候加上raw value 的类型 enum ASCIIControlCharacter: Character &#123; case Tab = "\t" case LineFeed = "\n" case CarriageReturn = "\r" &#125; 和C有默认的raw value一样，swift的枚举类也有默认的raw value但是不是任何类型的raw value 都有默认值假如你raw value的类型是Character，那么就不存在默认raw value，每个枚举成员的默认值都必须由你自己定义如果类型是Int，那么默认值第一个是0，后面的一项都前一项加1.看下面例子就明白了 enum NameSet: Int&#123; case Lucy //0 case Tom = 3 //3 case Kate //4 case Angle = 66 //66 case Alex //67 &#125; 如果类型是String，那么默认值就是你的枚举成员的名字 enum NameSet: String&#123; case Lucy //Lucy case Tom = "T" //T case Kate //Kate &#125; 如果有raw value，就可以用raw value来定义枚举变量 var myName = NameSet(rawValue: "Lucy") //注意这里返回的是一个可选类型，因为这个构造方法是一个可失败的构造方法。具体看后面的类构造的文章。 print(myName!.rawValue) //这里我就没用if做判断了，直接强制解包 递归enum就是在enum的枚举成员的associated value声明为本枚举类,然后使用递归函数。在声明associated value为自己枚举类的时候，需要加上indirect关键字。这个关键字可以加在每个case的前面，也可以加在enum的前面。后一种方法对里面所有的case都起效。但是并不要求所有case都有本枚举类作为associated value indirect enum ArithmeticExpression &#123; //使用第二种indirect。定义了一个数学表达式。 case Number(Int) case Addition(ArithmeticExpression, ArithmeticExpression) case Multiplication(ArithmeticExpression, ArithmeticExpression) &#125; func evaluate(expression: ArithmeticExpression) -&gt; Int &#123; //这个函数运算表达式 switch expression &#123; case .Number(let value): return value case .Addition(let left, let right): return evaluate(left) + evaluate(right) case .Multiplication(let left, let right): return evaluate(left) * evaluate(right) &#125; &#125; // evaluate (5 + 4) * 2 let five = ArithmeticExpression.Number(5) let four = ArithmeticExpression.Number(4) let sum = ArithmeticExpression.Addition(five, four) let product = ArithmeticExpression.Multiplication(sum, ArithmeticExpression.Number(2)) print(evaluate(product)) // prints "18"]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Closures闭包]]></title>
<url>../../../../../../../../2017/11/27/Swift-Grammar/Swift-Grammar-Closures闭包/</url>
    <content type="text"><![CDATA[闭包 闭包可以看做是匿名的函数 回想一下函数作为参数的情况定义一个函数，它最后的参数是一个函数类型 func doMath(first: Int, second: Int, mathFunc: (Int, Int) -&gt; Int) &#123; print("mathFunc =",mathFunc(first,second))&#125; 定义一个函数，它有两个整形参数，并有一个整形返回值 func add(first: Int, _ second: Int) -&gt; Int&#123; return first + second 调用第一个函数，将第二个函数作为参数传入 doMath(1, second: 3, mathFunc: add) 打印 mathFunc = 4 如果我们想用doMath实现两个数相减的方法，那么必须再写定义一个sub函数，然后将其作为参数传入。这样在功能多了之后会显得很麻烦，一堆函数，而所以有了闭包这个概念 闭包的语法&#123; (参数列表) -&gt; 返回类型 in //闭包体&#125; 有了闭包，我们可以将上面的代码改为 定义一个函数，它最后的参数是一个函数类型 func doMath(f:Int,s:Int,mathFunc:(Int,Int)-&gt;)&#123; print("mathFunc = ",mathunc(first,second)) &#125; 调用 doMath(1, second: 3, mathFunc: &#123;(f: Int, s: Int) -&gt; Int in return f + s&#125;) 还是很麻烦是吧？ 别忘了 Swift有类型推断功能，所以我们可以继续简化上面的闭包部分代码 doMath(1, second: 3, mathFunc: &#123;f, s in return f + s&#125;) 对应只有一行代码的闭包，return关键字还可以省略 doMath(1, second: 3, mathFunc: &#123;f, s in f + s &#125;) 此外，闭包对参数提供了默认名字，依次为 $0,$1,$2….所以上面的闭包仍可以简化 doMath(1, second: 3, mathFunc: &#123;$0 + $1 &#125;) 对于闭包在参数列表最后一项的情况，可以将闭包写到小括号外部，并且可以省略掉外部参数名 doMath(1, second: 3)&#123; var f = $0 + 1 return f + $1&#125; Autoclosures 姑且叫自动打包吧。用大括号括起来就好，编译器自动判断这个大括号里面的是什么返回类型。但是有时候不准确，需要自己写。下面是这个概念的解释，其实也是一种定义闭包变量的方法 var t = &#123; return 1&#125;print(t()) 定义了一个Void-&gt;Void类型的闭包。因为没有参数，所以可以省略参数列表和in关键字。如果有参数的话，就不能省略in关键字。 var b: Void-&gt;Int = &#123; //定义了一个类型为 Void-&gt;Int的闭包 var i = 1 i++ print(i) return i&#125; 因为闭包其实就是函数，调用这个闭包就和调用函数一样。但是有区别的就是闭包都是没有外部外部参数名，调用的时候不要把内部参数名但做外部参数名使用。 有时候函数需要传递一个闭包的时候，可以在调用的时候使用大括号将一段代码生成为闭包 var b: Void-&gt;Int = &#123; var i = 1 return i&#125;func doClosures(c: Void-&gt;Void) &#123; c()&#125;doClosures(&#123;b()&#125;) //虽然b是一个Void-&gt;Int的闭包，但是其调用再封装之后变为了Void-&gt;Void的闭包doClosures(&#123; var i = 3 i++ print(i)&#125;) 此外，可以在函数参数列表里面使用@autoclosure关键字，这样就不用使用大括号封装了。但是对于多句的代码情况不行（上面的第二种），有时候自动封装也会出错，比如用上面的第一种情况，它把b()看做了Int，然后报错。需要将返回类型重新定义一下 var b: Void-&gt;Void = &#123; var i = 1 i++ print(i)// return i&#125;func doClosures(@autoclosure c: Void-&gt;Void) &#123; //或者不改b的类型，将这里的c的类型改为 Void-&gt;Int也可以 c()&#125;doClosures(b()) 如果想要自动封装的闭包可以在doClosures函数的作用域以外使用，那么加上escaping关键字。这个关键字只能用在@autoclosure后面 var b: Void-&gt;Void = &#123; var i = 1 i++ print(i)&#125;var t: (Void-&gt;Void)?func doClosures(@autoclosure(escaping) c: Void-&gt;Void) &#123; c() t = c //将自动封装的c赋值给外部变量t&#125;doClosures(b())t!() 闭包的值捕获在生成一个闭包的时候，闭包会将它用到的参数和变量都保存一份。提醒一下，其实闭包就是函数 func giveMeFunc2(step: Int) -&gt; (Void -&gt; Int)? &#123; var total = 0 func add() -&gt; Int &#123; total += step; return total &#125; return add&#125; 上面的函数里面生成了嵌套函数，通过输入不同的符号，返回不同的函数。这里有两个变量需要注意，一个是total，一个是step。当生成嵌套函数的时候，嵌套函数会将这两个变量都copy一份，然后保存起来。下面是对上面代码的一个使用 上面的函数里面生成了嵌套函数，通过输入不同的符号，返回不同的函数。这里有两个变量需要注意，一个是total，一个是step。当生成嵌套函数的时候，嵌套函数会将这两个变量都copy一份，然后保存起来。下面是对上面代码的一个使用 可以看到，f1和f2的total和step是不会相互干涉的。 再来看看这个值捕获的时间，看下面代码。这里可以看到，值捕获是发生在返回之前。这个和OC的block是一样的 func giveMeFunc2(step: Int) -&gt; (Void -&gt; Int)? &#123; var total = 0 func add() -&gt; Int &#123; total += step; return total &#125; print("before +100",add()) // total = 0 total += 100 print("after +100",add()) // total = 100 return add&#125;var f1 = giveMeFunc2(1)! //得到一个函数，它会将传入的参数累加，并且每次调用都会加上一次stepprint("f1=",f1()) // 103print("f1=",f1()) // 104 看到这里，可能大家会以为这个值捕获和OC的block差不多，但是其实差远了。这个值捕获的时间很有区别。这里明显的一点就是我们在函数内部改变外部变量total的时候，没有加任何修饰符，OC里面必须加上__block，要么就是对全局变量进行修改。 我们先看一段OC代码 int t =1;int(^b)() = ^() &#123; return t; &#125;;t = 3;NSLog(@"%d",b()); //输出1，理由就不多说了。假如我们把t改为__block。那么将会输出3。改为static同样的效果。__block int t =1;int(^b)() = ^() &#123; return t; &#125;;t = 3;NSLog(@"%d",b()); //3 来看OC和swift中两段很类似的代码 //OCtypedef int(^BLOCK)(void);BLOCK OCFunc (int step) &#123; __block int total = 0; BLOCK b = ^() &#123; total +=step; return total; &#125;; step = 100; NSLog(@&quot;before +100,%d&quot;,b()); //1 total +=100; NSLog(@&quot;after +100,%d&quot;,b()); //102 return b;&#125;//在main方法里面调用BLOCK b = OCFunc(1);NSLog(@&quot;%d&quot;,b()); // 103NSLog(@&quot;%d&quot;,b()); // 104 func swiftFunc(var step: Int) -&gt; Void -&gt; Int&#123; var total = 0 let b: Void -&gt; Int = &#123; Void in total += step; return total &#125; step = 100; print("before +100,",b()) // 100 total+=100 // total = 200 print("after +100,",b()) //300 return b&#125;let d = swiftFunc(1)print("d=",d()) //400print("d=",d()) //500 这里可以看到，OC中的step在block定义的时候就绑定了，后面在更改step的值也不影响block。但是在swift中，step仍然是可以改变的，直到step离开作用域后，闭包才将其捕获。 如果要OC中产生同样的效果，只需定义一个block变量，如下。可以这么看，Swift中的变量默认都是block的 //OCtypedef int(^BLOCK)(void);BLOCK OCFunc (int step) &#123; __block int total = 0; __block int step2 = step; BLOCK b = ^() &#123; total +=step2; return total; &#125;; step2 = 100; NSLog(@"before +100,%d",b()); //100 total +=100; NSLog(@"after +100,%d",b()); //300 return b;&#125;//在main方法里面调用BLOCK b = OCFunc(1);NSLog(@"%d",b()); //400NSLog(@"%d",b()); //500 这个值捕获和OC的block一样，也会产生循环引用问题。OC里面是使用__weak来解决，这里差不多，它可以在参数列表前面加上捕获列表，并且对捕获类别的参数进行权限控制，附上一个官方例子，以后写ARC的时候详细讲 lazy var someClosure: (Int, String) -&gt; String = &#123; [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in // closure body goes here&#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FF-Beichoo-有读1.1.0版本问题]]></title>
<url>../../../../../../../../2017/11/27/FF-Beichoo/FF-Beichoo-有读1.1.0版本问题/</url>
    <content type="text"><![CDATA[问题如下 个人中心数据加载 版本判断问题 轻读页卡顿 TabBarC样式撤换 首页推荐-猜你喜欢 个人中心数据加载 上拉加载更多，一直加载/加载白页 1.AFN限制15秒 sessionManager.requestSerializer.timeoutInterval = 15;2.缓存，从缓存里取数据，应该也要让刷新状态结束 refresh直接end 是否对新的数据请求有影响（不确定）3.scrovlview滑动影响，控制子viewC里的tabelview的滑动 2.版本判断问题 1.AppDelegate里 后台控制 1 == 后台控制 0 == 依赖Appstore 获取版本号2、苹果下发 可能是上个版本版本号 测试 版本Bug 步骤 1.后台字段 修改force_update = 1 – 依赖后台控制版本 2.App版本号修改为1.1.1(最新，高版本) (结果：不提示) 3.App版本号修改为 小于1.1.1(低版本) （结果提示更新） 4.后台字段 修改force_update = 0 – 不依赖后台控制版本 5.App版本号修改为1.1.1(最新，高版本) (结果：不提示) 6.App版本号修改为 小于1.1.1(低版本) （结果： 提示更新） 版本控制基本配置@discussion: 后台决定依赖 后台控制还是appstore 版本号来控制 - (void)show_configurationLaunchUserOption&#123; FFNetWorkTool *api = [FFNetWorkTool api]; api.config.isSign = NO; [api httpPost:@&quot;special/launch&quot; parameters:nil success:^(NSDictionary *dic) &#123; [self analyzeResponse:dic];&#125; failure:^(NSError *error) &#123;&#125;];&#125; 版本控制 数据解析@brief: 只有当 app_version = 1 才能 轻质跟新 -(void)analyzeResponse:(id)dic&#123; if ([[dic allKeys] containsObject:@&quot;code&quot;]) &#123; if ([dic[@&quot;code&quot;] integerValue] == 0 &amp;&amp; [[dic allKeys] containsObject:@&quot;data&quot;] &amp;&amp; [[dic[@&quot;data&quot;] allKeys] containsObject:@&quot;app_version&quot;] &amp;&amp; [[dic[@&quot;data&quot;] allKeys] containsObject:@&quot;force_update&quot;] &amp;&amp; [dic[@&quot;data&quot;][@&quot;force_update&quot;]integerValue] == 1 &amp;&amp; dic[@&quot;data&quot;][@&quot;app_version&quot;] ) &#123; [self checkVersionDic:@&#123;@&quot;version&quot;:dic[@&quot;data&quot;][@&quot;app_version&quot;]&#125;]; return; &#125;&#125;//app store 版本去控制[self appVersonUpdate];&#125; Appstore 方式控制版本更新 入口） - (void)appVersonUpdate&#123;//定义app地址 NSString *urld = [NSString stringWithFormat:@"http://itunes.apple.com/lookup?id=%d",1282222817]; NSURL *url = [NSURL URLWithString:urld]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:10]; [request setHTTPMethod:@"POST"]; NSOperationQueue *queue = [NSOperationQueue new]; [NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *error)&#123; NSMutableDictionary *receiveStatusDic=[[NSMutableDictionary alloc]init]; if (data) &#123; NSDictionary *receiveDic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil]; if ([[receiveDic valueForKey:@"resultCount"] intValue]&gt;0) &#123; [receiveStatusDic setValue:@"1" forKey:@"status"]; [receiveStatusDic setValue:[[[receiveDic valueForKey:@"results"] objectAtIndex:0] valueForKey:@"version"] forKey:@"version"]; &#125;else&#123; [receiveStatusDic setValue:@"-1" forKey:@"status"]; &#125; &#125;else&#123; [receiveStatusDic setValue:@"-1" forKey:@"status"]; &#125; [self performSelectorOnMainThread:@selector(receiveData:) withObject:receiveStatusDic waitUntilDone:NO];&#125;]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSMutableDictionary *receiveStatusDic = @&#123;&#125;.mutableCopy; if (data) &#123; NSDictionary *receiveDic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil]; if ([[receiveDic valueForKey:@"resultCount"] intValue] &gt; 0) &#123; [receiveStatusDic setObject:@"1" forKey:@"status"]; [receiveStatusDic setObject:[[[receiveDic valueForKey:@"results"] objectAtIndex:0] valueForKey:@"version"] forKey:@"version"]; [self performSelectorOnMainThread:@selector(receiveData:) withObject:receiveStatusDic waitUntilDone:NO]; &#125;else&#123; [receiveStatusDic setValue:@"1" forKey:@"status"]; &#125; &#125;else&#123; [receiveStatusDic setValue:@"-1" forKey:@"status"]; &#125; &#125;]; [task resume]; &#125; 获取APP自身版本号@discussion: 版本号 去电 点，然后扩展成为3位数，不足3位末尾加0 -(void)receiveData:(id)sender&#123;]//拿到App 线上 版本号 NSInteger newVersionInt; if([[sender allKeys] containsObject:@"version"]) &#123; NSString *newVersionStr = [sender[@"version"] stringByReplacingOccurrencesOfString:@"." withString:@""]; if ([newVersionStr length] == 1) &#123; newVersionStr = [NSString stringWithFormat:@"%@%@",newVersionStr,@"00"]; &#125; if([newVersionStr length] == 2) &#123; newVersionStr = [NSString stringWithFormat:@"%@%@",newVersionStr,@"0"]; &#125; newVersionInt =[newVersionStr integerValue]; &#125;else&#123; return; &#125; NSLog(@" 本地： %ld 线上 %ld",(long)localVersionInt,(long)newVersionInt); if (localVersionInt&lt; newVersionInt) &#123; [self updateVersion]; &#125;else&#123; return; &#125; &#125; 轻读页卡顿 简单检测，线上版本需要关闭 [self check_pingObserver]; TabBarC样式撤换 撤换地上那方点击，略微弹动动画 首页推荐-猜你喜欢 换一换，偏移量修改 轻读上拉数据偶尔没有 移动端暂未找到原因，后台报userid问题数据偶尔没有 目前测的结果，后台可能已经解决]]></content>
      <categories>
        <category>FF</category>
        <category>Beichoo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Function函数]]></title>
<url>../../../../../../../../2017/11/24/Swift-Grammar/Swift-Grammar-Function函数/</url>
    <content type="text"><![CDATA[函数定义 Swift的函数和C的函数定义方式有区别，Swift将返回类型写在函数的最后 func函数名 (参数列表) -&gt; 返回值 &#123; //函数体&#125; 函数输入一个字符串，然后打印出这个字符串，并且返回一个字符串 //函数定义func printYourName (name: String)-&gt;String &#123; print(name) return "Hello, " + name&#125;var s = printYourName(name: "Tom") //函数调用print(s) //打印 Hello, Tom 一个函数没有返回值，那么从 -&gt; 返回值 这个部分可以省略 //函数定义func printYourName (name: String) &#123; print(name)&#125; 有多个参数 func printTwoString(firstString: String, secondString: String) &#123; print(firstString,secondString)&#125;printTwoString(firstString: "hello", secondString: "Kate") Function Argument Labels and Parameter Names 在函数定义时候，参数列表中使用的fristString和secondString称为参数(Parameter).但是参数包含了两个东西 1是Argument Label，它是在方法调用的时候写在参数值前面的参数标记，比如下面调用中的firstString和secondString printTwoString(firstString: "hello", secondString: "Kate") 2是Parameter Names，它只的是在方法体里面使用到的参数标志 printTwoString方法体里面print种使用到的firstString,secondString 默认情况下，Argument Label和Parameter Names是一样的。但是你也可以自定义Argument Label，方法是在Parameter Names前面加上另外一个字符串，并用空格相隔，如下，begin是自定义的Argument Label，然后调用的时候就需要使用begin来指定参数 func printTwoString(begin firstString: String, secondString: String) &#123; print(firstString,secondString)&#125;printTwoString(begin: "hello", secondString: "Kate") 使用print的时候没有加上任何的Argument Label。如果你不想要Argument Label，那么在定义方法的时候，将Argument Label的字符串写为下划线 _ func printTwoString(firstString: String, _ secondString: String) &#123; print(firstString,secondString)&#125;printTwoString(firstString: "hello", "Kate") //忽略了第二参数的外部参数名之后，这里就不能加上外部参数名了 参数默认值 可以给参数赋值默认值。具有默认值的参数，在调用的时候，可以不用给它赋值。好比print方法，它的原型是 print(_:separator:terminator:) 但是一般使用的时候都只传了一个字符串，原因就在于它后面的两个参数都是具有默认值的。给参数设置默认值的方法是在方法定义的时候，在参数的后面用 = 加上默认值。如下代码。官方文档建议我们把带默认值的参数放在参数列表的末尾，这样在调用的时候不至于混淆。但是其实可以对每个参数都赋值默认值。比如下面的例子 func printTwoString(firstString: String = "hello", secondString: String = "Lucy", thirdString: String = "end") &#123; print(firstString,secondString,thirdString)&#125;printTwoString( secondString:"two") //使用外部参数名指定要赋值的参数，其他参数使用默认值，输出 hello two end 值得注意的是，如果没有默认值的参数在调用的时候也没有给其赋值，那么会在编译的时候报错。如果你又把参数列表的Argument Label都去掉的话，那么在调用的时候，你给的参数将会从头开始匹配。如果参数类型不匹配的话，就会报错。当然，不建议大家这样做，因为会导致程序的可读性变差 可变参数列表func printStrings(strings: String...) &#123; print(strings)&#125;printStrings("1","2","3") //输出 ["1", "2", "3"] 通过输出我们可以看到，可变参数在函数体内是以数组的类型存在的。这点在官方文档上有说明 In-Out 参数 在默认的情况下，参数传递给方法后都是常量，也就是说不能在函数体里面对参数进行修改。这个常量是个形参，不是之前的实参 func add(first: Int, _ second: Int) -&gt; Int&#123; first = 2 //这句报错 return first + second&#125; 有一种情况，我们希望在方法里面改变实参的值，所以有了inout关键字，这个关键字不能对可变参数添加，同时加上了这个keyword之后，不能再添加 var let，也不能有默认值。然后调用的时候，这个参数必须传递一个变量，而不能是常量，并且在变量前加&amp; func add(first: inout Int, _ second: Int) -&gt; Int&#123; first = 2 return first + second&#125;var a = 1print("result = \(add(first: &amp;a, 3)), a = \(a) " )//输出 result = 5, a = 2 关于In-Out，这个实现原理是先将实参copy，然后在方法体内处理，方法结束的时候，再把copy覆盖回原来的实参。所以如果你在方法体里面去改变实参（通过某些方法获得），那么在方法结束的时候，你对实参的改变会被形参覆盖。建议不要在方法体里面操作InOut参数的实参。 关于InOut参数的捕获问题请参见官方文档 函数类型 函数也是一种类型。函数类型由函数定义决定 func add(first: inout Int, _ second: Int) -&gt; Int&#123; first = 2; return first + second&#125; 它的函数类型为 (inout Int, Int) -&gt; Int如果没有参数也没有返回值的函数，函数类型为 () -&gt; void，也可以写为 () -&gt; ()函数类型可以和基本类型一样，用来定义变量。继续利用上面定义的add函数 var mathFunc : (inout Int, Int) -&gt; Int = addvar f = 1;var s = 2;let result = mathFunc(&amp;f,s) //使用函数类型 函数类型可以用做参数或返回值，利用上面定义的mathFunc变量，可以有 func add(first: inout Int, _ second: Int) -&gt; Int&#123; first = 2; return first + second&#125;var mathFunc : (inout Int, Int) -&gt; Int = addfunc doMath(mathFunc: (inout Int, Int) -&gt; Int, first: inout Int, second: Int) &#123; print("mathFunc = \(mathFunc(&amp;first,second))") print("first = \(first)")&#125;var f = 1;var s = 2;doMath(mathFunc: mathFunc, first: &amp;f, second: 2)print("f = \(f)")//输出//mathFunc = 4//first=2//f=2 嵌套函数 在函数里面再定义函数。这个嵌套函数可以在函数内部调用，也可以作为返回值返回，使得它可以在其他范围内进行使用。例子如下//定义了add 和 sub 两个嵌套函数，然后用于返回。如果输入的不是”+“或”-“，那么返回一个nil。注意giveMeFunc返回的是一个函数类型的可选类型 func giveMeFunc(opt: Character) -&gt; ((Int, Int) -&gt; Int)? &#123; var method : ((Int, Int) -&gt; Int)? switch opt &#123; case "+" : func add(one: Int, _ two: Int) -&gt; Int &#123; return one + two &#125; method = add case "-" : func sub(one: Int, _ two: Int) -&gt; Int &#123; return one - two &#125; method = sub default : method = nil &#125; return method&#125;if let m = giveMeFunc(opt:"-") &#123; print(m(1, 2)) // 打印 -1, 留意一下，这里没有Argument Label。&#125; 操作符方法（Operator Methods） swift和C++一样，可以定义操作符函数。操作符指的是+，-，/，%，+=等等。一般我们这些操作符是给数字类型使用的。但是有了操作符函数之后，我们可以自定义这类符号的运算规则。下面是官方的示例 struct Vector2D &#123; var x = 0.0, y = 0.0&#125;extension Vector2D &#123; static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x, y: left.y + right.y) &#125;&#125; 上面的例子定义了一个操作符函数 + ，这个操作符函数的参数列表里面有两个参数left和right。分别代表着+号左右两边的两个参数。通过这个函数，我们可以直接将两个Vector示例进行相加。如下： let vector = Vector2D(x: 3.0, y: 1.0)let anotherVector = Vector2D(x: 2.0, y: 4.0)let combinedVector = vector + anotherVector// combinedVector is a Vector2D instance with values of (5.0, 5.0) 除了这种要接受两个参数的操作符之外，还要一些只有一个参数的操作符，比如 -，++，–等等。但是这类操作符有两类：前缀（Prefix）和后缀（Postfix），比如–a，i++；这类操作符的定义要加上prefix或postfix关键字。语法如下 extension Vector2D &#123; static prefix func - (vector: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: -vector.x, y: -vector.y) &#125;&#125; 上面定义了一个前缀的 - 操作符函数。用来将一个向量取反。后置操作符的关键字是postfix，中间操作符的关键字是infix 另外还有一种计算并赋值的操作符，比如++，+=等等。这类的操作符会对其中的一个操作对象进行操作后的赋值。所以必须将参数设置为inout extension Vector2D &#123; static func += (left: inout Vector2D, right: Vector2D) &#123; left = left + right &#125;&#125; 除了Swift已经定义的操作符之外，还可以自己定义操作符。比如下面定义了一个+++操作符 prefix operator +++ 上面的只是定义，我们还需要实现这个操作符所做的 extension Vector2D &#123; static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D &#123; vector += vector return vector &#125;&#125; 但是这个自定义的操作符有一些规定。自定义的操作符可以由/, =, -, +, !, *, %, &lt;, &gt;, &amp;, |, ^, ?,~，和某些Unicode 字符开始，至于是哪些字符可以参考官网。点击网页，在网页最下面在这些字符之后，可以接上unicode字符。另外有一些禁止的规定：1.不能重写一个单单的 ? 号。（可以在字符里面加入?号）2.不能重写这些操作符 =, -&gt;, //, /, /, ., 但是可以重写两个或更多个点的操作符。 不能以这些字符开头 ?, &lt;， &amp;4.不能以这些字符结尾 ?， &gt;， ! 在定义的操作符的时候末尾的那对大括号是有用的。在数学上，加减乘除是有优先级和结合规则的。同样的，这里的操作符也是。我们可以在定义操作符的大括号里面定义这个操作符的优先级和结合规律 infix operator +-: AdditionPrecedenceextension Vector2D &#123; static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x, y: left.y - right.y) &#125;&#125; 上面例子定义的是一个中间的操作符，它的结合规则是向左结合。优先级是AdditionPrecedence组，这个参考下面的Precedence Group Declaration链接。前置操作符和后置操作符不能指定优先级，它们作用在同一个操作数，那么先执行后置操作符。 wen]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-流程控制语句]]></title>
<url>../../../../../../../../2017/11/24/Swift-Grammar/Swift-Grammar-流程控制语句/</url>
    <content type="text"><![CDATA[if else语句 if语句if语句和其他语言中的使用是一样的，只是语法稍有不同首先,是不用括号其次,是即使是if后面只有一条语句，也必须加上大括号 var array1 = ["a","b","c"]if array1.count &gt; 1 &#123; print("array1 is not empty") //这句会打印出来&#125; else &#123; print("array1 is empty")&#125; f语句可以用来检测可选类型是否为空 var str : String?if let s = str &#123; print("str is not nil")&#125; else &#123; print("str is nil") //这句会打印&#125; for 语句 已经移除 for var index = 0; index &lt; 3; index++ &#123; //已经移除 print(index)&#125; for-in 语句 尤其是用来遍历集合 for index in 1...3 &#123; print(index)&#125; 上面的只能是每次加1，但是现在可能有需求每次增加的不是1，所以现在有了这个 for tickMark in stride(from: 0, to: 60, by: 5) &#123; print(tickMark) // 打印 (0, 5, 10, 15 ... 45, 50, 55)&#125; while语句和 repeat-while语句 把括号去掉就行了 var index = 3while index &gt; 0 &#123; index-- print(index)&#125;index = 3repeat &#123; index-- print(index)&#125; while index &gt; 0 Break和continue这个用法和C差不多Switch语句 Swift里面的Switch语句不仅可以判断整形，而且还可以判断各种类型。注意的是执行了一个case后是不会继续往下面执行的，也就是不用添加break语句。相反如果你想要继续往下执行，你必须在这个case最后加上Fallthrough。另外就是default，对于不是枚举类型的变量，defalut必须加上。枚举类型的变量在完全枚举的时候才可以省略default var str = "a"switch str &#123; case "a": print("a") //这句会打印 fallthrough case "b": print("b") //这句会打印 case "c": print("c") //不会打印 default: print("nil") //不会打印&#125; switch里面一个case可以对应多个选项，每个选项之间用逗号分开。这个用法是用来实现c里面的某个选项里面没有执行代码的情况。Swift不允许某个选项里面没有可执行的代码 var str = "s"switch str &#123;case "a","s": print("a") //只打印这句default: print("nil")&#125; case里面也可以是一个范围，在每个case之间的范围有重叠的话，只会匹配第一个 var i = 2switch i &#123;case 1...10: print("1-10") //只打印这句case 9..&lt;20: print("10-20") //因为匹配了第一句，所以这句不会再匹配default: print("other")&#125; 对Tuple 的匹配你可以匹配Tuple的两个值，也可以只匹配一个值，还可以匹配范围 //下面case的条件都是可以匹配的，把前面的case注释掉的话就会匹配下一个case。var tuple = (2,1)switch tuple &#123;case (2,1): print("(2,1)") //因为自动添加break的机制，所以不会往下走case (let x,1): //可以用变量来自由化其中一个值，只需要另外一个值匹配了，就会匹配这个。如果你不关注x的值，你也可以把x换为_ print("x = \(x)")case (-1...3,0...4): print("(-1~3,0~4)")default : print("other")&#125; Where语句在switch中 where可以用来进一步对case添加约束 var tuple = (2,1)switch tuple &#123;case var (x,y) where x == y: //这里用var 和 let 区别在于能不能在case里面修改解包的x，y值。但是即使修改也不会影响原来的tuple print("x == y")case let (_,x) where x == 4: print("x == 4")case var (x,y) where x != y: //匹配了这个case print("x != y") //打印 x != y x = 1 print(x) //打印 1default : print("other")&#125;print(tuple) //打印 （2，1） Labeled Statements 这个labeled statements就像goto语句，但是跳转比较有限，只能用于循环里面。虽然switch也可以加上去，但是并没有用 var tuple = (2,1)second:for _ in 0... &#123; frist : switch tuple &#123; //这个first并没有什么用 case var (x,y) where x == y: //这里用var 和 let 区别在于能不能在case里面修改解包的x，y值。但是即使修改也不会影响原来的tuple print("x == y") break second case var (x,y) where x != y: //匹配了这个case print("x != y") //打印 x != y tuple = (1,1) continue second default : print("other") &#125;&#125;//上面的for循环依次打印了 x != y x == y//注意下面的second，虽然前面也定义了，但是不会冲突。循环内的跳转只能针对循环second:repeat &#123; //对于while也是可以用。 frist : switch tuple &#123; //这个first并没有什么用 case var (x,y) where x == y: //这里用var 和 let 区别在于能不能在case里面修改解包的x，y值。但是即使修改也不会影响原来的tuple print("x == y") break second case var (x,y) where x != y: //匹配了这个case print("x != y") //打印 x != y tuple = (1,1) continue second default : print("other") &#125;&#125; while true//while循环只打印了 x == y，因为Tuple已经被修改为(1,1) Assertion和Preconditionassert(_:_:file:line:) 判断一个情况是否为true，不为true直接停止程序 assertionFailure(_:file:line:) Swift现在多了一个Preconditions，区别文档上说的是开发时候用Assertions，生产用Preconditions。(Assertions help you find mistakes and incorrect assumptions during development, and preconditions help you detect issues in production. ) precondition(_:_:file:line:) preconditionFailure(_:file:line:) 文档上有两段话： If you compile in unchecked mode (-Ounchecked), preconditions are not checked. The compiler assumes that preconditions are always true, and it optimizes your code accordingly. However, the fatalError(:file:line:) function always halts execution, regardless of optimization settings.You can use the fatalError(:file:line:) function during prototyping and early development to create stubs for functionality that hasn’t been implemented yet, by writing fatalError(“Unimplemented”) as the stub implementation. Because fatal errors are never optimized out, unlike assertions or preconditions, you can be sure that execution always halts if it encounters a stub implementation.但是没找到这个-Ounchecked模式，到时有一个选项是disable_safty_checks。这个选项的关闭和Swift_OPTIMIZATION_LEVEL的模式有关系。如果你选择的是 -Onone，那么不管disable_safty_checks的值，都会检测precondition和assert。但是如果开启了优化，那么assert就再不检测，而precondition就会根据是否关闭安全检测来执行 guard语句 这个和assertions差不多，都是用来做判断的，不过这个要自己加上处理。用来在条件不满足的情况下跳出方法或循环 var i = 1while true &#123; guard i &gt; 1 else &#123; print("i &lt;= 1") break //else里面必须加上break或return &#125;&#125; available 用来判断是否可以使用某个版本API if #available (iOS 8, OSX 10.10, *) &#123; //括号里面表示的是最低的版本。这个*必须有，代表其他平台&#125; else &#123;&#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-集合类型]]></title>
<url>../../../../../../../../2017/11/24/Swift-Grammar/Swift-Grammar-集合类型/</url>
    <content type="text"><![CDATA[集合类型 集合类分为array、dictionary、set每个集合都有一个isEmpty属性来判断这个集合是否为空 Array 创建array的四种方法 var array1 = ["a","b","c"] //包含 a b c 三个字符串var array2 = Array&lt;Int&gt;() //空array，这里一定要指明元素类型var array3 = [String]() //空arrayvar array4 = Array(repeating:2.4, count:3) //包含3个double变量，值都为1.3var array5 = [Double](repeating:2.4, count:3) //包含3个double变量，值都为1.3 获取array的某个元素,直接用下标 var value = array1[9] 清空数组 array1.removeAll()array1 = []; 清空某个元素 remove(at:) 清空某个范围的元素 array.removeSubrange(1..&lt;arr.endIndex)// 这里会移除从1开始，但是不包括end的元素，但是endIndex是指向最后一个元素的后一个元素的，所以会从index为1的元素开始，删除后面全部。array[1...2] = [] //这里将范围1-2的元素都清空了,注意一点，如果数组越界的话，会产生运行时错误 向array添加元素 //使用append()方法array1.append("A") //向array1的末尾添加一个 A，现在只有一个 A 元素//使用运算符号array3 += ["d","e"] //array3从空数组变为包含 d e 两个字符串var array5 = array1 + array3 + ["last"] //array5包含 A d e last, 4个元素//使用insert方法array5.insert("first", at: 0) //array5包含 first A d e last, 5个元素 改变array元素 array5[0] = "newBe"array5[1...3] = ["1","2","3"] 遍历数组for item in array5 &#123; print(item)&#125;for (index,item) in array5.enumerated() &#123; print(index,item)&#125; Set Set 创建set里面的元素都必须实现hashable。因为区分set里面的元素的根本就是判断两个元素的hash值是否相等。swift基本类型都实现了hashable var emptySet = Set&lt;Character&gt;() //建立一个空set，必须指明内容的类型var nameSet : Set&lt;String&gt; = ["Tom","Lucy","Aaron"] //使用初始数据建立set 移除Set removeAll()，这个方法还可以传一个boolean参数，表示是否保持空间，传ture的话表示保持 移除一个元素有两种办法 var index = nameSet.index(of:"Tom")nameSet.remove(at:index!) //因为indexOf返回的是可选类型，所以这里要解包nameSet.remove("Tom") //这种和上面的是等价的 遍历Set for name in nameSet.sorted() &#123; //这里的sorted()可以不用，这里用来排序 print(name)&#125; 包含某个元素 Set和Array都有一个contains方法来判断 Set操作包括了求交集，并集，“减集”，“异或集”官方代码 let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]oddDigits.union(evenDigits).sort()// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]oddDigits.intersection(evenDigits).sort()// []oddDigits.subtracting(singleDigitPrimeNumbers).sort()// [1, 9]oddDigits.symmetricDifference(singleDigitPrimeNumbers).sort()// [1, 2, 9] Set关系 isSubset(of:) 判断一个set是否为另外一个set的子setisSuperset(of:) 判断一个set是否为另外一个set的父setisStrictSubset(of:) 和 isStrictSuperset(of:) 意思和上面的一样，只是这两个方法不能存在相等的情况。isDisjoint(with:) 判断两个set是否没有共同元素，没有的话返回true Dictionary 创建Dictionar var dict1 : [String:Int] = ["a":1,"b":2,"c":3]var dict = ["a":1,"b":2,"c":3, 3:"d"] as [AnyHashable : Any] //注意这个没声明类型的，因为key和value里面都有不同的类型，所以需要将二者都强转为AnyHashable，但是如果key（value）类型只有一种的话，那么就会转为那种类型。var dict2 = [Int:String]()var dict3 = Dictionary&lt;String,Int&gt;() 添加/修改/删除dictionarydictionary也提供了removeAll，removeAtIndex之类的方法使用和Set是一样的，就不写了。下面是dictionary特有的 dict[5] = "f" //添加一个键值对 5: "f"dict[5] = 5 //修改key为5的值为5dict[5] = nil //删除key为5的键值对dict[6] = nil //对不存在的键值对赋nil不会报错dict2 = [:] //清空所有 新增了一个更改和删除的方法，可以获得更新和删除前的旧值(可选类型)。如果这个值以前不存在，那么返回nil let oldValue = airports.updateValue("Dublin Airport", forKey: "DUB") let removedValue = airports.removeValue(forKey: "DUB") 遍历dictionary for (key,name) in dict &#123; print(key,name,separator:":")&#125;var keys = dict1.keys.sort();for key in keys &#123; print(key,dict[key]!)&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-String-Character]]></title>
<url>../../../../../../../../2017/11/24/Swift-Grammar/Swift-Grammar-String-字符串/</url>
    <content type="text"><![CDATA[StringString 的定义 字符串是有序的字符集合，或者叫文本String 是字符串类型。单个字，Character是字符类型2个字符串可以用 + 链接通过字符插值可以合成一个长字符串 public struct String &#123; public init() // An empty `String`&#125; 字符串创建和空判断 字符串字面量，包含双引号的值 var str = "Yue ke kui" 创建空串 var yue = ""或var yue = String() //结构体方式创建var ke = " "yue.isEmpty // 判断字符串是否为空ke.isEmpty // 不为空。有空格 使用三个引号来创建一段话的string开始的三个引号的第一行后面的空格都会忽略，但是第二行的空格不会 let quotation = """The White Rabbit put on his spectacles. "Where shall I begin,please your Majesty?" he asked."Begin at the beginning," the King said gravely, "and go ontill you come to the end; then stop."""" 可修改字符串 Swift 3.0 用 var 和 let 来判断字符串是否可以被修改(类似OC可变字符串)let修饰 不可变字符串 不能拼接追加等var修饰 可变字符串var variableString = "Hello"variableString += "Swift 3.0";print(variableString);//打印HelloSwift 3.0 Character 字符 创建一个Character，必须显式声明类型 var c1:Character = "c" //注意是 双引号var c2 = "c" //c2被认为是String类型var c3 = 'c' //编译错误// Character可以赋值为Unicodelet eAcute: Character = "\u&#123;E9&#125;" // é// 挨个 取 字符let string = "Swift";var arrays = string.characters;for charactor in arrays&#123; print(charactor);&#125;//一次打印 S w i f t 字符串是值类型 改变String，这个语法和java一样的，不过内存管理层面已经是不同的对象字符串是值类型: 创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能 var str:String = "first"var c1:Character = "c" //注意是双引号var c2 = "c" //c2被认为是String类型str += "sceond" //str变为firstsceond,此时的str和之前的str内存地址不同str += c2 //str变为firstc,此时的str和之前的str内存地址不同str.appendContentsOf("second") // 和使用+=是一样的str.appendContentsOf(c2) //和使用+=是一样的str.append(c1); //添加Character的方法 遍历String字符var str:String = "first"for c in str.characters &#123; print(c)&#125; ------ 或for index in str.characters.indices &#123; print(str[index])&#125; 获取String长度var s = "dfe"print(s.count) //3 swift里面有extended grapheme clusters(An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.) 也就是几个Unicode字符组合成一个人类可以识别的字符。 当string里面添加了characters后，count不一定会增加。string的count不一定和NSString的length一致。(The length of an NSString is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.) 运算符+其他方式，赋值 符附字符尾部 append // 通过加法运算符（+）相加在一起（或称“连接”）创建一个新的字符串 let string1 = "chen"; let string2 = "jian"; let string3 = string1 + string2; print("string3 is \(string3)"); // chen jian//通过加法赋值运算符 (+=) 将一个字符串添加到一个已经存在字符串变量上var variablestring = "da shen chen jian";variablestring += string2;print("variablestring is \(variablestring)");// da shen chen jianjian // 用append()方法将一个字符附加到一个字符串变量的尾部 variablestring.append(" !"); print("variablestring is \(variablestring)"); // da shen chen jianjian ! String的Index 不像java里面的Index直接就是一个数字 String的Index是在不同的extension中定义的。 获得String里面的某个字符的过程let greeting = "Guten Tag!"greeting[greeting.startIndex]// Ggreeting[greeting.index(before: greeting.endIndex)]// !greeting[greeting.index(after: greeting.startIndex)]// ulet index = greeting.index(greeting.startIndex, offsetBy: 7)greeting[index]// a 插入和移除字符var welcome = "hello"welcome.insert("!", at: welcome.endIndex)// welcome now equals "hello!"welcome.insert(contentsOf: " there", at: welcome.index(before: welcome.endIndex))// welcome now equals "hello there!"welcome.remove(at: welcome.index(before: welcome.endIndex))// welcome now equals "hello there"let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndexwelcome.removeSubrange(range)// welcome now equals "hello" 截串 Swift引入了一个SubString类，用来截串 let greeting = "Hello, world!"let index = greeting.index(of: ",") ?? greeting.endIndexlet beginning = greeting[..&lt;index]// beginning is "Hello"但是注意SubString可能会用到原来string的内存。官方建议是短时间使用，如果想要长时间保持，需要转为String// Convert the result to a String for long-term storage.let newString = String(beginning) 将String转换为NSString，然后调用NSString的截串方法 var str = "123456789"var ns = (str as NSString).substringWithRange(NSMakeRange(1, 4))print(ns) //输出 2345 xtension来扩展String(最简单)mport Foundationextension String &#123; //获取部分字符串，如果不在范围内，返回nil.如果end大于字符串长度，那么截取到最后 subscript (start: Int, end: Int) -&gt; String? &#123; if start &gt; self.count || start &lt; 0 || start &gt; end &#123; return nil &#125; let begin = self.index(self.startIndex, offsetBy: start) var terminal: Index if end &gt;= length &#123; terminal = self.index(self.startIndex, offsetBy: count) &#125; else &#123; terminal = self.index(self.startIndex, offsetBy: end + 1) &#125; let range = (begin ..&lt; terminal) return self.substring(with: range) &#125; //获取某个字符，如果不在范围内，返回nil subscript (index: Int) -&gt; Character? &#123; if index &gt; self.count - 1 || index &lt; 0 &#123; return nil &#125; return self[self.index(self.startIndex, offsetBy: index)] &#125;&#125; 计算字符数量 如果想要获得一个字符串中Character值的数量，可以使用字符串的characters属性的count属性 let calculstring = "chenjian"; print("calculstring has \(calculstring.characters.count) charactor");//输出结果 calculstring has 8 charactor 访问字符串 let visitString = "Hello Swift";//获取第一个字符print("visitString 的第一个字符 :\(visitString[visitString.startIndex])");// 这里输出 visitString 的第一个字符 :H//获取最后一个字符print("visitString 的最后一个字符 :\(visitString[visitString.index(before: visitString.endIndex)])");// 这里输出 visitString 的最后一个字符 :t//获取下第二个字符print("visitString 的第二个字符 : \(visitString[visitString.index(after: visitString.startIndex)])")// 这里输出 visitString 的第二个字符 : e// 通过偏移量获取索引 第一个字符 往后偏移 4个单位(不包括起始位置) （备注： 如果你把字符串当数组来理解，你会发现 0 就在数组的自四个位置）let index = visitString.index(visitString.startIndex, offsetBy: 4);print("\(visitString[index])");// 这里输出 o// 使用 characters 属性的 indices 属性会创建一个包含全部索引的范围(Range)，用来在一个字符串中访问单个字符for index in visitString.characters.indices&#123; print("通过下标得到每一个字符:\(visitString[index])");&#125;// 这里输出/*通过下标得到每一个字符:H通过下标得到每一个字符:e通过下标得到每一个字符:l通过下标得到每一个字符:l通过下标得到每一个字符:o通过下标得到每一个字符: 通过下标得到每一个字符:S通过下标得到每一个字符:w通过下标得到每一个字符:i通过下标得到每一个字符:f通过下标得到每一个字符:t*/ 大小写转化let changeString = "hello";print("\(changeString.uppercased())") //转化成大写print("\(changeString.lowercased())") // 转化成小写 插入 调用 insert(_:at:) 方法可以在一个字符串的指定索引插入一个字符，调用 insert(contentsOf:at:) 方法可以在一个字符串的指定索引插入一个段字符串 //插入单个字符var welocome = "hello";welocome.insert("!", at: welocome.endIndex);print("welocome = \(welocome)");//welocome = hello!//插入一段字符串到某个位置 contentsOf ： "字符串".characters 固定语法welocome.insert(contentsOf: "there".characters, at: welocome.index(before: welocome.endIndex));print("welocome = \(welocome)");//welocome = hello there! 删除 调用 remove(at:) 方法可以在一个字符串的指定索引删除一个字符 welocome.remove(at: welocome.index(before: welocome.endIndex));print("welocome = \(welocome)");//welocome = hello there// 调用 removeSubrange(_:) 方法可以在一个字符串的指定索引删除一个子字符串。let range = welocome.index(welocome.startIndex,offsetBy:6)..&lt;welocome.endIndex;welocome.removeSubrange(range);print("welocome = \(welocome)");// welocome = hello//指定位置删除welocome.remove(at: welocome.index(before: welocome.endIndex));print(welocome);//hello 比较字符串 字符串/字符可以用等于操作符(==)和不等于操作符(!=) let quotation = "We're a lot alike, you and I."let sameQuotation = "We're a lot alike, you and I."if quotation == sameQuotation&#123; print("相等");&#125;// 前缀相等let preString01 = "date";if preString01.hasPrefix("da")&#123; print("preString01 前缀有da");&#125;// 后缀相等if preString01.hasSuffix("te")&#123; print("preString01 后缀有te");&#125; 注意 不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符 特殊字符 字符串字面量可以包含以下特殊字符：转义字符\0(空字符)、(反斜线)、\t(水平制表符)、\n(换行符)、\r(回车符)、\”(双引号)、\’(单引号)]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
        <category>String</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-嵌套类型&类型转换]]></title>
<url>../../../../../../../../2017/11/24/Swift-Grammar/Swift-Grammar-嵌套类型&类型转换/</url>
    <content type="text"><![CDATA[嵌套类型(Nested Types) 这个概念就是把一个类（结构体、枚举类）的定义放到一个类类（结构体、枚举类）的里面。这个嵌套可以随便嵌套。可以在结构体里面定义类，类里面定义枚举类，枚举类里面定义结构体等等。随便一个没意思的例子，访问方法也给出来了。使用点语法就可以了 enum A &#123; struct B &#123; var num = 1 class Q &#123; &#125; class C &#123; var cc = 2 enum AA &#123; case d,e &#125; class CCC &#123; &#125; &#125; &#125; &#125; print(A.B.C.AA.d) //d print(A.B.C().cc) //2 类型判断符 is 用is可以用来判断一个实例是否是某个类或是某个类是子类。返回一个Bool值。十分简单，看例子 class Fruit &#123; &#125; class Apple : Fruit&#123; func eatApple() &#123; print("ear apple") &#125; &#125; class Pear: Fruit &#123; func eatPear() &#123; print("eat pear") &#125; &#125; var array = [Fruit(),Apple(),Pear()] for item in array &#123; print(item is Apple) &#125; //打印 //false //true //false var f = Fruit() var a = Apple() var p = Pear() print(a is Apple) //警告说 肯定返回 true print(a is Fruit) //警告说 肯定返回 true print(p is Apple) //警告说 肯定返回 false print(f is Apple) //打印false 类型下转换符as? 和 as! ，下转换判断符as 这as? as! 两个运算符可以将一个实例尝试转换为另外一个类的实例。一般是用在将一个父类变量的转换为一个子类变量。比如下面代码 var fruit: Fruit = Pear() 先来开开这句代码，我们把一个变量声明为了Fruit类型，但是赋值的时候给的却是Fruit的子类Pear。这个时候并不会报错。这种用一个父类类型的变量指向一个子类的做法称为多态。多态在面向对象编程里面有很重要的作用。这里不展开讲。因为fruit变量声明为了Fruit类型，即使它实际引用的实例是Pear类，但是现在还是不能通过它来调用Pear类引入的属性或方法。尽管这个实例确实是拥有这些属性和方法。为了去访问这些存在的属性和方法，我们就要采用类型下转换，将这个fruit的变量转换为一个pear的变量。 var pear = fruit as? Pear 上面的代码使用as?，尝试将这个fruit转为一个Pear类型的变量。这里因为fruit引用的实例就是Pear，所以是可以转换成功。成功后返回了一个Pear的可选类型给变量pear。但是如果转换失败，返回的是一个nil。比如你尝试将一个Apple实例转换为一个Pear，或者将一个Fruit实例转换为它的子类都会失败。 补充一点，如果对上面的fruit变量使用is判断是否是Pear类，返回的是true。as!和as?的区别就是强制解包了。学了那么多，应该可以猜到。最后在介绍这个比较诡异的as之前，看看Any和AnyObject这两个类型。 Any代表任何类型的实例，包括了函数类型。 AnyObject代表任何类的实例。 现在介绍as的用法，现在只发现as能用在switch中，用来判断变量是否是某个类型 func f1() -&gt; Int&#123; return 1 &#125; var b = &#123;var i=0; i++&#125; var array: [Any] = [f1,b,fruit,Fruit(), Apple(), Pear(), Animal(), (2,3), (4,5)] for (index, item) in array.enumerate() &#123; switch item &#123; case let item2 as Apple : print("index\(index) is \(item2)") case is Pear: print("index\(index) is pear") case let (2,y) as (Int, Int) where y &gt; 2: print("index\(index) is tuple y =",y) case is (Int,Int): print("index\(index) is (Int,Int) ",item) case let f as Void-&gt;Void: print("index\(index) is Void-&gt;Void ",item) default: print("index\(index) is default",item) &#125; &#125; //打印 //index0 is default (Function) //index1 is Void-&gt;Void (Function) //index2 is pear //index3 is default SwiftTest.Fruit //index4 is SwiftTest.Apple //index5 is pear //index6 is default SwiftTest.Animal //index7 is tuple y = 3 //index8 is (Int,Int) (4, 5) 你会发现其实，is 和 as 的效果是一样的。as比is多的就是将一个tuple可以再次解包出元素，并且再次匹配元素，同时还可以加上where做判断。比如上面的第三个case语句。会判断这个item是否是(Int,Inte)类型，然后解包tuple，判断第一个元素是否为2，如果是2，还会判断第二个元素是否大于2.只有这三个条件都符合才会匹配这个case]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Protocol协议]]></title>
<url>../../../../../../../../2017/11/24/Swift-Grammar/Swift-Grammar-Protocol协议/</url>
    <content type="text"><![CDATA[ProtocolPOP 面向协议的编程 面向协议的编程的核心是抽象（Abstraction）和简化（Simplicity）协议的高级使用是协议的延展协议(protocol) + 结构体(struct) &gt; 类(class) 面向对象与面向协议比较 面向对象是一个很古老的软件开发模式，通过类来实现 面向协议是苹果在 swift 中主推的，通过协议和结构体，可以代替类 Swift 中的很多对象都改成了结构体和协议 并不是所有的类都可以被协议+结构体替代，但大多数是可以被替换的 面向协议使代码更加灵活，类似于组件化开发，符合工厂方法模式实例比较：给一个类添加额外的方法 通过继承 创建一个继承类的子类，在子类中添加方法，以后使用子类即可获取这个方法通过协议 为这个方法定义一个协议，哪个类需要实现这个方法，协议即可 使用继承的缺点 通过继承添加的方法，不一定每个子类都会使用，使代码冗余 拥有太多的子类，使类冗余 对于父类的方法太过依赖，当父类的方法更改后，影响子类的重载方法 协议 协议 规定了用来实现某一特定功能所必须的 方法和 属性。用于统一方法和属性的名称，而不实现任何功能任意能够满足协议要求的类型被称为遵循(conform)这个协议。类，结构体、枚举类型(协议的遵守者) 都可以遵循协议，并提供具体实现来完成协议定义的方法和功能 协议的语法格式 协议的高级使用是协议的延展以及和结构体配合 为议添加属性, 属性为可读或可写 protocol SomeProtocol &#123; // 协议内容 var name: String &#123;get set&#125; var age: Int &#123; set get &#125;&#125; 定义一个接受协议的结构体 struct SomeModel: SomeProtocol&#123; var name:String = "" var age: Int = 0 var isYue: Bool = false init(with dict:[String:Any])&#123; self.name = (dict["name"]as?String)??"" self.age = (dict["age"]as?Int)??0 self.isYue = (dict["isYue"]as?Bool)??false &#125; &#125; 对协议进行延展 extension SomeProtocol&#123; mutating func test ()&#123; self.name = "Hello Jianjian !" &#125;&#125; 协议的协议 protocol oneProtocol: SomeProtocol &#123; var date: Date &#123; set get &#125;&#125; 遵循某(多)个协议 要使类遵循某个协议，需要在类型名称后加上协议名称，中间以冒号:分隔，作为类型定义的一部分遵循多个协议时，各协议之间用逗号,分隔 struct SomeStructure: FirstProtocol, AnotherProtocol &#123; // 结构体内容&#125; 如果类在遵循协议的同时拥有父类，应该将 父类名 放在 协议名 之前，以逗号分隔 class OneClass: OneSuperClass, OneProtocol, TwoProtocol &#123; // 类的内容&#125; 对属性的规定 协议 用于指定特定的实例属性或类属性 协议能够要求其遵守者必须含有一些特定名称和类型的实例属性(instance property)或类属性 (type property)，也能够要求属性的(设置权限)settable 和(访问权限)gettable，还必须指明是只读的还是可读可写的但它不要求属性是存储型属性(stored property)还是计算型属性(calculate property)协议中的通常用var来声明变量属性，在类型声明后加上{ set get }来表示属性是可读可写的，只读属性则用{ get }来表示。 protocol SomeProtocol &#123; var age : Int &#123; get set &#125; var money: Int &#123; get &#125;&#125; 用类来实现协议时，使用class关键字来表示该属性为类成员用结构体或枚举实现协议时，则使用static关键字来表示 protocol SomeProtocol &#123; class var someTypeProperty: Int &#123; get set &#125;&#125; SomeProtocol协议含有fullName属性。因此其遵循者必须含有一个名为oneName，类型为String的可读属性Person结构体含有一个名为oneName的存储型属性，完整的遵循了协议。(若协议未被完整遵循，编译时则会报错) protocol SomeProtocol &#123;var oneName: String &#123; get &#125;&#125; struct Person: SomeProtocol&#123; var oneName: String &#125; let john = Person(oneName: “Chen jianjian”) //john. oneName 为 “Chen jianjian” Startship类遵循了SomeProtocol协议Starship类将oneName实现为可读的计算型属性它的每一个实例都有一个名为name的必备属性和一个名为prefix的可选属性当prefix存在时，将prefix插入到name之前来为Starship构建oneName class Starship: SomeProtocol &#123; var prefix: String? var name: String init(name: String, prefix: String? = nil ) &#123; self.anme = name self.prefix = prefix&#125;var oneName: String &#123; return (prefix ? prefix ! + ” ” : ” “) + name&#125;&#125;var ncc1701 = Starship(name: “Enterprise”, prefix: “USS”)// ncc1701. oneName == “USS Enterprise” protocol classa &#123; var marks: Int &#123; get set &#125; var result: Bool &#123; get &#125; func attendance() -&gt; String func markssecured() -&gt; String&#125;protocol classb: classa &#123; var present: Bool &#123; get set &#125; var subject: String &#123; get set &#125; var stname: String &#123; get set &#125;&#125;class classc: classb &#123; var marks = 96 let result = true var present = false var subject = "Swift 协议" var stname = "Protocols" func attendance() -&gt; String &#123; return "The \(stname) has secured 99% attendance" &#125; func markssecured() -&gt; String &#123; return "\(stname) has scored \(marks)" &#125;&#125;let studdet = classc()studdet.stname = "Swift"studdet.marks = 98studdet.markssecured()print(studdet.marks)print(studdet.result)print(studdet.present)print(studdet.subject)print(studdet.stname)以上程序执行输出结果为98truefalseSwift 协议Swift 对 Mutating 方法的规定 有时需要在方法中改变它的实例。例如：值类型（结构体，枚举）的实例方法中，将mutating关键字作为函数的前缀，写在func之前，表示可以在该方法中修改它所属的实例及其实例属性的值 protocol daysofaweek &#123; mutating func show()&#125;enum days: daysofaweek &#123; case sun, mon, tue, wed, thurs, fri, sat mutating func show() &#123; switch self &#123; case .sun: self = .sun print("Sunday") case .mon: self = .mon print("Monday") case .tue: self = .tue print("Tuesday") case .wed: self = .wed print("Wednesday") case .thurs: self = .thurs print("Wednesday") case .fri: self = .fri print("Wednesday") case .sat: self = .sat print("Saturday") default: print("NO Such Day") &#125; &#125;&#125;var res = days.wedres.show()程序执行输出结果为：Wednesday 对构造器的规定 协议可以要求它的遵循者实现指定的构造器。像书写普通的构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体，语法如下： protocol SomeProtocol &#123; init(someParameter: Int)&#125; 实例 protocol tcpprotocol &#123; init(aprot: Int)&#125; 协议构造器规定在类中的实现 你可以在遵循该协议的类中实现构造器，并指定其为类的指定构造器或者便利构造器。在这两种情况下，你都必须给构造器实现标上”required”修饰符： class SomeClass: SomeProtocol &#123; required init(someParameter: Int) &#123; // 构造器实现 &#125;&#125;protocol tcpprotocol &#123; init(aprot: Int)&#125;class tcpClass: tcpprotocol &#123; required init(aprot: Int) &#123; &#125;&#125; 施用required修饰符可以保证：所有的遵循该协议的子类，同样能为构造器规定提供一个显式的实现或继承实现。如果一个子类重写了父类的指定构造器，并且该构造器遵循了某个协议的规定，那么该构造器的实现需要被同时标示required和override修饰符： protocol tcpprotocol &#123; init(no1: Int)&#125;class mainClass &#123; var no1: Int // 局部变量 init(no1: Int) &#123; self.no1 = no1 // 初始化 &#125;&#125;class subClass: mainClass, tcpprotocol &#123; var no2: Int init(no1: Int, no2 : Int) &#123; self.no2 = no2 super.init(no1:no1) &#125; // 因为遵循协议，需要加上"required"; 因为继承自父类，需要加上"override" required override convenience init(no1: Int) &#123; self.init(no1:no1, no2:0) &#125;&#125;let res = mainClass(no1: 20)let show = subClass(no1: 30, no2: 50)print("res is: \(res.no1)")print("res is: \(show.no1)")print("res is: \(show.no2)")以上程序执行输出结果为：res is: 20res is: 30res is: 50 协议类型 尽管协议本身并不实现任何功能，但是协议可以被当做类型来使用协议可以像其他普通类型一样使用，使用场景: 作为函数、方法或构造器中的参数类型或返回值类型 作为常量、变量或属性的类型 作为数组、字典或其他容器中的元素类型 实例 protocol Generator &#123; associatedtype members func next() -&gt; members?&#125;var items = [10,20,30].makeIterator()while let x = items.next() &#123; print(x)&#125;for lists in [1,2,3].map( &#123;i in i*5&#125;) &#123; print(lists)&#125;print([100,200,300])print([1,2,3].map(&#123;i in i*10&#125;))以上程序执行输出结果为：10203051015[100, 200, 300][10, 20, 30] 在扩展中添加协议成员 可以通过扩展来扩充已存在类型( 类，结构体，枚举等)。扩展可以为已存在的类型添加属性，方法，下标脚本，协议等成员。 protocol AgeClasificationProtocol &#123; var age: Int &#123; get &#125; func agetype() -&gt; String&#125;class Person &#123; let firstname: String let lastname: String var age: Int init(firstname: String, lastname: String) &#123; self.firstname = firstname self.lastname = lastname self.age = 10 &#125;&#125;extension Person : AgeClasificationProtocol &#123; func fullname() -&gt; String &#123; var c: String c = firstname + " " + lastname return c &#125; func agetype() -&gt; String &#123; switch age &#123; case 0...2: return "Baby" case 2...12: return "Child" case 13...19: return "Teenager" case let x where x &gt; 65: return "Elderly" default: return "Normal" &#125; &#125;&#125; 协议的继承协议能够继承一个或多个其他协议，可以在继承的协议基础上增加新的内容要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔： protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123; // 协议定义&#125; 实例 protocol Classa &#123; var no1: Int &#123; get set &#125; func calc(sum: Int)&#125;protocol Result &#123; func print(target: Classa)&#125;class Student2: Result &#123; func print(target: Classa) &#123; target.calc(1) &#125;&#125;class Classb: Result &#123; func print(target: Classa) &#123; target.calc(5) &#125;&#125;class Student: Classa &#123; var no1: Int = 10 func calc(sum: Int) &#123; no1 -= sum print("学生尝试 \(sum) 次通过") if no1 &lt;= 0 &#123; print("学生缺席考试") &#125; &#125;&#125;class Player &#123; var stmark: Result! init(stmark: Result) &#123; self.stmark = stmark &#125; func print(target: Classa) &#123; stmark.print(target) &#125;&#125;var marks = Player(stmark: Student2())var marksec = Student()marks.print(marksec)marks.print(marksec)marks.print(marksec)marks.stmark = Classb()marks.print(marksec)marks.print(marksec)marks.print(marksec)以上程序执行输出结果为：学生尝试 1 次通过学生尝试 1 次通过学生尝试 1 次通过学生尝试 5 次通过学生尝试 5 次通过学生缺席考试学生尝试 5 次通过学生缺席考试 类专属协议你可以在协议的继承列表中,通过添加class关键字,限制协议只能适配到类（class）类型。该class关键字必须是第一个出现在协议的继承列表中，其后，才是其他继承协议。格式如下： protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123; // 协议定义&#125; 实例 protocol TcpProtocol &#123; init(no1: Int)&#125;class MainClass &#123; var no1: Int // 局部变量 init(no1: Int) &#123; self.no1 = no1 // 初始化 &#125;&#125;class SubClass: MainClass, TcpProtocol &#123; var no2: Int init(no1: Int, no2 : Int) &#123; self.no2 = no2 super.init(no1:no1) &#125; // 因为遵循协议，需要加上"required"; 因为继承自父类，需要加上"override" required override convenience init(no1: Int) &#123; self.init(no1:no1, no2:0) &#125;&#125;let res = MainClass(no1: 20)let show = SubClass(no1: 30, no2: 50)print("res is: \(res.no1)")print("res is: \(show.no1)")print("res is: \(show.no2)")以上程序执行输出结果为：res is: 20res is: 30res is: 50 九、协议合成Swift 支持合成多个协议，这在我们需要同时遵循多个协议时非常有用。语法格式如下： protocol Stname &#123; var name: String &#123; get &#125;&#125;protocol Stage &#123; var age: Int &#123; get &#125;&#125;struct Person: Stname, Stage &#123; var name: String var age: Int&#125;func show(celebrator: Stname &amp; Stage) &#123; print(&quot;\(celebrator.name) is \(celebrator.age) years old&quot;)&#125;let studname = Person(name: &quot;Priya&quot;, age: 21)print(studname)let stud = Person(name: &quot;Rehan&quot;, age: 29)print(stud)let student = Person(name: &quot;Roshan&quot;, age: 19)print(student)以上程序执行输出结果为：Person(name: &quot;Priya&quot;, age: 21)Person(name: &quot;Rehan&quot;, age: 29)Person(name: &quot;Roshan&quot;, age: 19) 检验协议的一致性 使用is和as操作符来检查是否遵循某一协议或强制转化为某一类型。 is操作符用来检查实例是否遵循了某个协议。 as?返回一个可选值，当实例遵循协议时，返回该协议类型;否则返回nil。 as用以强制向下转型，如果强转失败，会引起运行时错误。 实例 下面的例子定义了一个 HasArea 的协议，要求有一个Double类型可读的 area： protocol HasArea &#123; var area: Double &#123; get &#125;&#125;// 定义了Circle类，都遵循了HasArea协议class Circle: HasArea &#123; let pi = 3.1415927 var radius: Double var area: Double &#123; return pi * radius * radius &#125; init(radius: Double) &#123; self.radius = radius &#125;&#125;// 定义了Country类，都遵循了HasArea协议class Country: HasArea &#123; var area: Double init(area: Double) &#123; self.area = area &#125;&#125;// Animal是一个没有实现HasArea协议的类class Animal &#123; var legs: Int init(legs: Int) &#123; self.legs = legs &#125;&#125;let objects: [AnyObject] = [ Circle(radius: 2.0), Country(area: 243_610), Animal(legs: 4)]for object in objects &#123; // 对迭代出的每一个元素进行检查，看它是否遵循了HasArea协议 if let objectWithArea = object as? HasArea &#123; print("面积为 \(objectWithArea.area)") &#125; else &#123; print("没有面积") &#125;&#125;以上程序执行输出结果为：面积为 12.5663708面积为 243610.0没有面积 Demo]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Document-Develpe-文档]]></title>
<url>../../../../../../../../2017/11/23/1/</url>
    <content type="text"><![CDATA[swift4苹果开发者中心 swift 语法基础 Swift学习 Swift部分资料 第三方 第三方02 这个人博客整理的很好 swift框架大全]]></content>
      <categories>
        <category>Swift</category>
        <category>Document</category>
        <category>Develpe</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Lib-YYKit-YYmodel]]></title>
<url>../../../../../../../../2017/11/23/iOS-Lib/iOS-Lib-YYKit-YYmodel/</url>
    <content type="text"></content>
      <categories>
        <category>iOS</category>
        <category>Lib</category>
        <category>YYKit</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Tool-FastLane自动化发布工具+上传Bugly]]></title>
<url>../../../../../../../../2017/11/23/iOS-Garmmar/iOS-Tool-FastLane自动化发布工具+上传Bugly/</url>
    <content type="text"><![CDATA[打包的流程 修改测试版本号 修改Build版本号 执行Archive 选择Adhoc导出IPA安装包文件 上传Bugly测试平台 分享测试链接二维码FastlaneFastlane本身包含两大模块，内核部分+ActionActionAction是Fastlane自动化流程中的最小执行单元，直观上来讲就是Fastfile脚本中的一个个命令，比如：git_pull，deliver，pod_install等等，而这些命令背后都对应其实是一个用Ruby编写的脚本 Fastlane 是一套用 Ruby 编写的 iOS 命令行工具集（后来也支持了 Android），主要组件包括： match / cert / sigh 协助管理代码签名 pem 自动生成 APNs 证书 scan 自动化测试 gym 自动化编译并打包生成签名的 .ipa 文件 snapshot / frameit 协助处理 iOS 屏幕快照 pilot 上传和管理 TestFlight deliver 将应用及其它信息上传到 App Store 而正是这些颗粒度极小的Action，根据自己需求组合成一个自动化的链条 安装 首先确保Xcode命令行工具是最新版本的 $ xcode-select --install 安装Fastlane: $ sudo gem install fastlane -NV 找到工程文件目录下执行 $ fastlane init 在执行“Your Apple ID” 这一步输入苹果开发者账号，fastlane 会自动获取工程文件名，目录等其他数据。这一步“Please confirm the above values”，确认信息，没问题则输入 y。然后，fastlane 会进行一系列的初始化操作，包括下载 App Store 上的元数据和截屏文件。等待初始化完成之后，工程目录下就多了一个 fastlane目录： $ cd fastlane &amp;&amp; lsAppfile Fastfile metadata report.xmlDeliverfile README.md screenshots 文件目录 metadata目录下存放整个元数据文件，包括关键词、版本更新日志、图标等. screenshots目录下存放应用截图 Appfile文件记录App的 bundle ID、Apple ID、Team ID三种信息. Fastfile脚本的核心执行文件.有几个默认的选项，可直接使用. report文件时每次执行fastlane时生成报告 安装fastlane成功后，首先拆解我们需要自动化的两个流程: 自动打包成Adhoc的安装包ipa文件 通过fastlane自动上传到bugly 自动化打包 自动化打包使用最多就是Fastlane中gym这个Action, 转为打包而生, 安装gym这个组件: $ sudo gem install gym cd项目根目录, 创建自动打包脚本: $ vim gym.sh 输入脚本内容: #!/bin/bash#计时SECONDS=0#假设脚本放置在与项目相同的路径下project_path=$(pwd)#取当前时间字符串添加到文件结尾now=$(date +"%Y_%m_%d_%H_%M_%S")#指定项目的scheme名称scheme="Xitu"#指定要打包的配置名configuration="Adhoc"#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数export_method='ad-hoc'#指定项目地址workspace_path="$project_path/Xitu.xcworkspace"#指定输出路径output_path="project_path/APP"#指定输出归档文件地址archive_path="$output_path/Xitu$&#123;now&#125;.xcarchive"#指定输出ipa地址ipa_path="$output_path/Xitu$&#123;now&#125;.ipa"#指定输出ipa名称ipa_name="Xitu$&#123;now&#125;.ipa"#获取执行命令时的commit messagecommit_msg="$1"#输出设定的变量值echo "===workspace path: $&#123;workspace_path&#125;==="echo "===archive path: $&#123;archive_path&#125;==="echo "===ipa path: $&#123;ipa_path&#125;==="echo "===export method: $&#123;export_method&#125;==="echo "===commit msg: $1==="#先清空前一次buildgym --workspace $&#123;workspace_path&#125; --scheme $&#123;scheme&#125; --clean --configuration $&#123;configuration&#125; --archive_path $&#123;archive_path&#125; --export_method $&#123;export_method&#125; --output_directory $&#123;output_path&#125; --output_name $&#123;ipa_name&#125;#输出总用时echo "===Finished. Total time: $&#123;SECONDS&#125;s===" 把如上脚本中Xitu改成你的项目名称即可. 为脚本执行提升权限 $ chmod +x gym.sh 执行一下脚本看一下打包效果: $ ./gym.sh 经过572s，Adhoc版本的ipa文件打包成功，我们在项目根目录下找到App目录： =========================================== #上传Bugly fastlane中定义action$ fastlane new_action 这时命令行会要求你输入自定义action名字，直接以bugly上传文件命名 $ upload_app_to_bugly wei wan]]></content>
      <categories>
        <category>iOS</category>
        <category>Tool</category>
        <category>FastLane</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Blog-配置]]></title>
<url>../../../../../../../../2017/11/23/Blog/Blog-配置/</url>
    <content type="text"><![CDATA[博客配置01博客配置02]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Code-优化项目]]></title>
<url>../../../../../../../../2017/11/23/iOS-Code/iOS-Code-优化项目/</url>
    <content type="text"><![CDATA[优化项目 结构与架构1.1 结构 这里说的结构大概有两点：1.文件目录分类 2.第三方库管理1.1.1 文件目录分类 为了方便管理，最好将Xcode中的项目展示目录与实际的存储目录保持一致此外，一般按业务模块分类,一级目录可以按照MVC格式，也可以按照业务模块划分用最普遍的Model View Controller架构举例]]></content>
      <categories>
        <category>iOS</category>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-Bug管理工具]]></title>
<url>../../../../../../../../2017/11/22/iOS-Func/iOS-Func-Bug管理工具/</url>
    <content type="text"><![CDATA[#功能 非Crash Bug 在App内可截图添加描述并发送 Crash Bug 在App第二次启动时提取Crash log添加描述并发送 实现解释分析 bug 非Crash的Bug：字体不对、颜色不对、数据不对、布局不对 Crash Bug：系统Crash、处理signal场景交互 场景交互：发现非Crash Bug时候摇一摇手机，弹出邮件，图片带入邮件，点击发送即可。有Crash Bug的时候第二次启动App，弹出邮件，Crash log带入邮件，点击发送即可 使用 需要用到NSSetUncaughtExceptionHandler，MFMailComposeViewController，沙盒，NSFileManager实现截图的功能，考虑到并不是所有的页面都需要使用所以写在了分类里。需要用的时候直接引入头文件即可这三个方法分别在摇一摇的时候回调用，开始，需要，结束。他们的父类是UIResponsder在UIKit中 -(void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event&#123;&#125;-(void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event&#123;&#125;-(void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event&#123; [self screenShot];&#125;-(void)screenShot&#123; UIWindow *screen = [[UIApplication sharedApplication] keyWindow]; UIGraphicsBeginImageContext(screen.frame.size); [screen.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsGetCurrentContext(); NSData *screenData = UIImagePNGRepresentation(image); [screenData writeToFile:[NSHomeDirectory() stringByAppendingPathComponent:@"Library/Caches"] atomically:YES]; &#125; 发送邮件的功能 发送邮件的功能，也写在了分类里面，需要用的时候引入即可 @interface UIViewController (send)&lt;MFMailComposeViewControllerDelegate&gt;//发送邮件的方法，传入标题，描述信息，data, 接收人-(void)sendMail:(MFMailComposeViewController*)mf andSubject:(NSString*)subject andMessageBody:(NSString*)message andData:(NSData*)data andRecipients:(NSArray*)recipients&#123; if([MFMailComposeViewController canSendMail])&#123; mf.mailComposeDelegate = self; [mf setSubject:subject]; [mf setToRecipients:recipients]; [mf addAttachmentData:data mimeType:@"image/jpeg" fileName:@"error"]; [mf setMessageBody:message isHTML:YES]; [self presentViewController:mf animated:YES completion:nil]; &#125;else&#123; [self alertView:@"不能调用邮箱" andDesc:@"请尝试下载App原生邮箱，并配置"]; &#125;&#125; MFMailComposeViewControllerDelegate的代理方法，可以在这个方法里面写一些回调-(void)mailComposeController:(MFMailComposeViewController *)controller didFinishWithResult:(MFMailComposeResult)result error:(NSError *)error&#123; switch (result) &#123; case MFMailComposeResultSent: [self alertView:@"发送成功" andDesc:nil]; self.success(); break; case MFMailComposeResultSaved: [self alertView:@"保存成功" andDesc:nil]; break; case MFMailComposeResultFailed: self.faild(); [self alertView:error.domain andDesc:[NSString stringWithFormat:@"%@",error.userInfo]]; break; case MFMailComposeResultCancelled: [self alertView:@"取消发送" andDesc:nil]; break; default: [self alertView:@"为什么不发送" andDesc:nil]; break; &#125; [self dismissViewControllerAnimated:YES completion:nil];&#125; 异常捕获这两个为函数方法，导入类名，直接可调用不用初始化void CrashExceptionHandler(void)&#123; NSSetUncaughtExceptionHandler(&amp;ExceptionLog);&#125;void ExceptionLog(NSException *exception)&#123; NSDate *date_current = [NSDate date]; NSDictionary *dictInfo = [[NSBundle mainBundle]infoDictionary]; NSString *name_App = [dictInfo objectForKey:@"CFBundleDisplayName"]; NSString *verson_App = [dictInfo objectForKey:@"CFBundleShortVersionString"]; NSString *build_App = [dictInfo objectForKey:@"CFBundleVersion"]; NSArray *ecp = exception.callStackSymbols; NSString *reason = [exception reason]; NSString *name = [exception name]; NSString *exceptionInfo = [NSString stringWithFormat: @"\n\n ******************************异常日志****************************** \n时间:%@\nApp名称:%@\nApp版本:%@\nBuild版本:%@\n异常名称:%@\n异常原因:%@\n堆栈信息:%@",date_current,name_App,verson_App,build_App,name,reason,ecp]; [CrashHandler saveLog:exceptionInfo andDate:date_current];#ifdef DEBUG NSLog(@"%@",exceptionInfo);#else#endif&#125;@implementation CrashHandler+(void)saveLog:(NSString *)crashLog andDate:(NSDate *)date&#123; NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)objectAtIndex:0] stringByAppendingString:@"/Crash"]; if(![[NSFileManager defaultManager]fileExistsAtPath:path]) &#123; [[NSFileManager defaultManager]createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:nil]; &#125; NSString *logPath = [path stringByAppendingFormat:@"/%@.log",date]; [crashLog writeToFile:logPath atomically:YES encoding:NSUTF8StringEncoding error:nil];&#125;@end 检测Crash log 功能在App打开的第一个页面去调用就好-(void)crashLog { NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)objectAtIndex:0] stringByAppendingString:@"/Crash"]; NSFileManager *mf = [NSFileManager defaultManager]; if(![mf fileExistsAtPath:path]) { return; } NSArray *array = [mf contentsOfDirectoryAtPath:path error:nil]; } Bug管理工具]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Crash日志]]></title>
<url>../../../../../../../../2017/11/22/iOS-Code/iOS-Code-Crash日志/</url>
    <content type="text"><![CDATA[获得crash日志产生/保存 程序崩溃时，系统会创建一份crash日志保存在设备上。 这份crash日志记录着应用程序崩溃时的信息，包含每个执行线程的栈调用信息（低内存闪退日志例外），对定位问题很有帮助 连接设备获取 可以连接设备，打开Xcode - Window - Organizer， 在左侧面板中选择Device Logs（可以选择具体设备的Device Logs或者Library下所有设备的Device Logs） 然后根据时间排序查看设备上的crash日志 已发布app通过iTunes Connect获取 可以通过iTunes Connect（Manage Your Applications - View Details - Crash Reports）获取用户的crash日志 不过这并不是100%有效的，而且大多数开发者并不依赖于此，因为这需要用户设备同意上传相关信息，详情可参见iOS: Providing Apple with diagnostics and usage information摘要 接入现有的crash收集工具获取通常接入现有的crash收集工具，或者自己编写一个进行自动化收集、解析和统计汇总 解析crash日志符号化解析 当获得一份crash日志时，需要将初始展示的十六进制地址等原始信息映射为源代码级别的方法名称和代码行数，使其对开发人员可读这个过程称为符号化解析。要成功地符号化解析一份crash日志，我们需要有对应的应用程序二进制文件以及符号（.dSYM）文件 -如果处于开发调试阶段，通常Xcode都能匹配到crash日志对应的二进制文件和符号文件，所以能够帮我们自动解析。 如果处于测试阶段，测试人员已经安装了不同的版本（比如alpha、beta版本），那么需要保存好对应版本的二进制文件和符号文件，以便在应用程序崩溃时对crash日志进行解析。对于这种场景下产生的crash日志，只需要将.crash文件、.app文件和.dSYM文件三者放在同一个目录下，然后将.crash文件拖放到Xcode - Window - Organizer中左侧面板Library下的Device Logs中，即可进行解析。 如果要提交发布，那么我们通常会先执行Clean，再Build，最后通过Product - Archive来打包。这样，Xcode会将二进制文件和符号文件归档在一起，可以通过Organizer中的Archives进行浏览 关于如何解析crash日志的讨论 分析crash日志 在分析一份crash日志之前，如果开发人员对于常见的错误类型有所了解，那定是极好的。 crash日志的产生来源于两种问题：违反iOS策略被干掉，以及自身的代码bug iOS策略低内存闪退 低内存闪退日志 前面提到大多数crash日志都包含着执行线程的栈调用信息 但是低内存闪退日志除外，这里就先看看低内存闪退日志是什么样的我们使用Xcode 5和iOS 7的设备模拟一次低内存闪退，然后通过Organizer查看产生的crash日志，可以发现Process和Type都为Unknown： 具体的日志内容如下 第一部分是崩溃信息，包括识别标识、软硬件信息和时间信息等。 第二部分是内存页分配信息，以及当前占用内存最多的进程，上图中为crashTypeDemo。 第三部分是具体的进程列表，描述着每个进程使用内存的情况以及当前状态。在较早的版本中可以在某些进程后面看到“jettisoned”字样，表明这些进程使用过多内存被终止了，而现在我们看到的是“vm-pageshortage”字样。 当iOS检测到内存过低时，它（的VM系统）会发出低内存警告通知，尝试回收一些内存；如果情况没有得到足够的改善，iOS会终止后台应用以回收更多内存；最后，如果内存还是不足，那么正在运行的应用可能会被终止掉。 所以，我们的应用应该合理地响应系统抛出来的低内存警告通知，对一些缓存数据和可重新创建的对象进行释放，同时要避免出现内存泄露等问题。 低内存闪退是由iOS策略决定终止应用程序运行的，同样基于iOS策略的还有Watchdog超时和用户强制退出 Watchdog超时 Apple的iOS Developer Library网站上，QA1693文档中描述了Watchdog机制，包括生效场景和表现。如果我们的应用程序对一些特定的UI事件（比如启动、挂起、恢复、结束）响应不及时，Watchdog会把我们的应用程序干掉，并生成一份响应的crash报告 这份crash报告的有趣之处在于异常代码：“0x8badf00d”，即“ate bad food” 如果说特定的UI事件比较抽象，那么用代码来直接描述的话，对应的就是（创建一个工程时Xcode自动生成的）UIApplicationDelegate的几个方法： 所以当遇到Watchdog日志时，可以检查下上图几个方法是否有比较重的阻塞UI的动作 QA1693举的例子是在主线程进行同步网络请求。如果我们是在公司的Wifi环境下使用则一切顺利，但当应用程序发布出去面向很大范围的用户，在各种网络环境下运行，则不可避免地会出现一片Watchdog超时报告。另一种可能出现问题的场景就是数据量比较大的情况下进行的数据库版本迁移（同样是在主线程上），这也是促使我写这篇总结的一个直接因素。 用户强制退出 一看到“用户强制退出”，首先可能想到的双击Home键，然后关闭应用程序。不过这种场景是不会产生crash日志的，因为双击Home键后，所有的应用程序都处于后台状态，而iOS随时都有可能关闭后台进程，所以这种场景没有crash日志。 另一种场景是用户同时按住电源键和Home键，让iPhone重启。这种场景会产生日志（仅验证过一次），但并不针对特定应用程序。 这里指的“用户强制退出”场景，是稍微比较复杂点的操作：先按住电源键，直到出现“滑动关机”的界面时，再按住Home键，这时候当前应用程序会被终止掉，并且产生一份相应事件的crash日志 通常，用户应该是遇到应用程序卡死，并且影响到了iOS响应，才会进行这样的操作——不过感觉这操作好高级，所以这样的crash日志应该比较少见 常见错误标识Exception codes上面“用户强制退出”的crash日志中的Exception Codes是“0xdeadfa11”，再上面“Watchdog超时”的crash日志中的Exception Codes是“0x8badf00d”，这些都是特有的Exception codes。根据官方文档描述，至少有以下几种特定异常代码： 0x8badf00d错误码：Watchdog超时，意为“ate bad food”。 0xdeadfa11错误码：用户强制退出，意为“dead fall”。 0xbaaaaaad错误码：用户按住Home键和音量键，获取当前内存状态，不代表崩溃。0xbad22222错误码：VoIP应用（因为太频繁？）被iOS干掉。 0xc00010ff错误码：因为太烫了被干掉，意为“cool off”。 0xdead10cc错误码：因为在后台时仍然占据系统资源（比如通讯录）被干掉，意为“dead lock” Exception types查看我们的crash分析报告邮件，会发现最经常遇到的错误类型是SEGV（Segmentation Violation，段违例），表明内存操作不当，比如访问一个没有权限的内存地址。当我们收到SIGSEGV信号时，可以往以下几个方面考虑：访问无效内存地址，比如访问Zombie对象；尝试往只读区域写数据；解引用空指针；使用未初始化的指针；栈溢出；此外，还有其它常见信号：SIGABRT：收到Abort信号，可能自身调用abort()或者收到外部发送过来的信号；SIGBUS：总线错误。与SIGSEGV不同的是，SIGSEGV访问的是无效地址（比如虚存映射不到物理内存），而SIGBUS访问的是有效地址，但总线访问异常（比如地址对齐问题）；SIGILL：尝试执行非法的指令，可能不被识别或者没有权限；SIGFPE：Floating Point Error，数学计算相关问题（可能不限于浮点计算），比如除零操作；SIGPIPE：管道另一端没有进程接手数据 代码bug此外，比较常见的崩溃基本都源于代码bug，比如数组越界、插空、多线程安全性、访问野指针、发送未实现的selector等。如果引入Core Data，则又有另外一些常见问题，不过这是另一个话题了。 遇到这些bug时，都有比较清楚的错误原因说明，比如“index 0 beyond bounds for empty array”等。需要稍微注意点的是多线程问题，当一时找不到解决思路时，不妨往多线程方面考虑下 iOS应用的crash日志的分析基础]]></content>
      <categories>
        <category>iOS</category>
        <category>Crash</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-检测主线程卡顿的问题]]></title>
<url>../../../../../../../../2017/11/22/iOS-Func/iOS-Func-检测主线程卡顿的问题/</url>
    <content type="text"><![CDATA[runloop - 检测方案 原文文档 CFRunLoopRunCFRunLoopRun源代码 核心方法CFRunLoopRun简化后的主要逻辑大概是这样的:NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿 int32_t __CFRunLoopRun()&#123; //通知即将进入runloop __CFRunLoopDoObservers(KCFRunLoopEntry); do &#123; // 通知将要处理timer和source __CFRunLoopDoObservers(kCFRunLoopBeforeTimers); __CFRunLoopDoObservers(kCFRunLoopBeforeSources); __CFRunLoopDoBlocks(); //处理非延迟的主线程调用 __CFRunLoopDoSource0(); //处理UIEvent事件 //GCD dispatch main queue CheckIfExistMessagesInMainDispatchQueue(); // 即将进入休眠 __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting); // 等待内核mach_msg事件 mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts(); // Zzz... // 从等待中醒来 __CFRunLoopDoObservers(kCFRunLoopAfterWaiting); // 处理因timer的唤醒 if (wakeUpPort == timerPort) __CFRunLoopDoTimers(); // 处理异步方法唤醒,如dispatch_async else if (wakeUpPort == mainDispatchQueuePort) __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() // UI刷新,动画显示 else __CFRunLoopDoSource1(); // 再次确保是否有同步的方法需要调用 __CFRunLoopDoBlocks(); &#125; while (!stop &amp;&amp; !timeout); //通知即将退出runloop __CFRunLoopDoObservers(CFRunLoopExit);&#125; runloop 的状态typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 耗时进行判断 利用 kCFRunLoopBeforeSources 和 *kCFRunLoopAfterWaiting 这两个状态之间的耗时 进行判断:是否有太多事件处理导致出现了卡顿 AppDelegate+AppService 监听runloop的状态而写的回调函数 static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; PingConfig *object = (__bridge PingConfig*)info; // 记录状态值 object-&gt;activity = activity; // 发送信号 dispatch_semaphore_t semaphore = object-&gt;semaphore; dispatch_semaphore_signal(semaphore);&#125; AppDelegate 注册监听 PingConfig: 一个用来存储runloop的状态和信号量的自定义类，其中的结构如下 APP启动时我可以进入 registerObserver 方法，其中首先我创建一个记录信息的类PingConfig实例，然后创建一个信号，并且保存在这个PingConfig实例中(其实只是为了方便拿到 创建了一个观察者监测主线程的runloop,它会在主线程runloop状态切换时进行回调 开启一个子线程，并且在里面进行一个 while 循环，在 循环的开始处 wait 一个信号量，并且设置超时为 50毫秒，失败后会返回一个非0数，成功将会返回0，这时候线程会阻塞住等待一个信号的发出 如果runloop状态正常切换，那么就会进入回调函数，在回调函数中我们发出一个信号，并且记录当前状态到PingConfig实例中，下面的判断语句中发现为0，timeoutCount自动置为0，一切正常 当主线程出现卡顿，while循环中的信号量再次等待，但是回调函数没有触发，从而导致等待超时，返回一个非0数，进入判断句后，我们再次判断状态是否处于 kCFRunLoopBeforeSources 或 kCFRunLoopAfterWaiting，如果成立，timeoutCount+1 持续五次runloop不切换状态，说明runloop正在处理某个棘手的事件无法休息且不更新状态，这样while循环中的信号量超时会一直发生，超过5次后我们将断定主线程的卡顿并上传堆栈信息 - (void)registerObserver&#123; PingConfig *config = [PingConfig new]; // 创建信号 dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); config-&gt;semaphore = semaphore; CFRunLoopObserverContext context = &#123;0,(__bridge void*)config,NULL,NULL&#125;; CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes); __block uint8_t timeoutCount = 0; // 在子线程监控时长 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (YES) &#123; // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms) long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC)); if (st != 0) &#123;// NSLog(@"循环中--%ld",config-&gt;activity); if (config-&gt;activity==kCFRunLoopBeforeSources || config-&gt;activity==kCFRunLoopAfterWaiting) &#123; if (++timeoutCount &lt; 5)&#123; continue; &#125;else&#123; NSLog(@"卡顿了"); &#125; &#125; &#125; timeoutCount = 0; &#125; &#125;);&#125; PingConfig@interface PingConfig : NSObject&#123; @public CFRunLoopActivity activity; dispatch_semaphore_t semaphore;&#125;@end Other情况主线程卡顿主线程卡在界面尚未完全显示前 当主线程卡在界面尚未完全显示前，这个方案就检测不出来卡顿了，比如我将下面的代码放在B控制器中 dispatch_semaphore_t t = dispatch_semaphore_create(0); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@"----"); dispatch_semaphore_signal(t); &#125;); dispatch_semaphore_wait(t, DISPATCH_TIME_FOREVER); 上面是一段有问题的代码，将导致主线程的持续堵塞，如果我们在这段代码放在B控制器的ViewDidLoad方法中(ViewWillAppear同样) 运行后，当你希望push到B控制器时，项目将在上一个界面完全卡住，并且无法用上面的方案检测到，而且CPU及内存都显示正常 原因分析 由于runloop在处理完source0或者source1后，比如界面的跳转也是执行了方法，具体有没有用到source0这不重要，但是后面会紧接着进入准备睡眠(kCFRunLoopBeforeWaiting)的状态，然而此时线程的阻塞导致runloop的状态也被卡住无法切换，这样也就导致在那段检测代码中无法进入条件，从而检测不出来。 但是话说回来，APP在静止状态(保持休眠)和刚刚那种卡死状态都会使runloop维持在 kCFRunLoopBeforeWaiting状态，这样我们就无法在那段代码中增加判断来修复，因为无法知道到底是真的静止没有操作还是被阻塞住，我也没找到线程的阻塞状态属性，如果你发现这个属性，那么就可以使用那个属性来判断 检测方案dispatch_queue_t serialQueue = dispatch_queue_create("serial", DISPATCH_QUEUE_SERIAL); self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, serialQueue); dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 0.25 * NSEC_PER_SEC, 0); __block int8_t chokeCount = 0; dispatch_semaphore_t t2 = dispatch_semaphore_create(0); dispatch_source_set_event_handler(self.timer, ^&#123; if (config-&gt;activity == kCFRunLoopBeforeWaiting) &#123; static BOOL ex = YES; if (ex == NO) &#123; chokeCount ++; if (chokeCount &gt; 40) &#123; NSLog(@"差不多卡死了"); dispatch_suspend(self.timer); return ; &#125; NSLog(@"卡顿了"); return ; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; ex = YES; dispatch_semaphore_signal(t2); &#125;); BOOL su = dispatch_semaphore_wait(t2, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC)); if (su != 0) &#123; ex = NO; &#125;; &#125; &#125;); dispatch_resume(self.timer); 方案解释 开启一个异步队列，并且创建一个定时器，时间我设置的是0.25秒，具体时间随你自己，这个时间是用来检测卡死的持续时间 在定时器外面我也同样创建了一个用来同步的信号量，这个不解释了，不会的就去看一下信号量的使用方式。进入定时器的回调后，我设置了一个静态变量来记录主队列是否执行完成。 我们判断当前runloop的状态是否为kCFRunLoopBeforeWaiting，所以这个方案是用来弥补前面那个方案，如果主线程此时没有阻塞住，我们在这里向main Queue抛一个block，看它是否能够成功执行，如果成功执行，说明主线程没有阻塞住，如果已经被阻塞住，那我抛过去的block是肯定不会被执行的。 下面的代码就是一些辅助操作，当信号量超过50毫秒，抛给主线程的block没有执行，那么说明此时就有一些阻塞了，返回一个非0数，并设置 ex为NO，从而在下一次定时器回调到来时进行上报]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit-Layer-Shadow阴影]]></title>
<url>../../../../../../../../2017/11/22/iOS-UIKit/iOS-UIKit-Shadow阴影/</url>
    <content type="text"><![CDATA[shadowColor:阴影颜色,可设置透明度等. shadowOffset:偏移量.,xy表示view左上角,width表示阴影与x的偏移量,height表示阴影与y值的偏移量 shadowOpacity = 0.4//阴影透明度,默认为0则看不到阴影.因此要看到阴影这个值必须大于0,shadowColor的透明度也要大于0 shadowRadius:5.模糊计算的半径,取平均值的半径,设置为0的话则为一个矩形块. 模糊度的解释:每一个像素取平均值,分母的取值范围,越大越模糊.感觉这篇文章讲的比较容易懂(http://www.dongcoder.com/detail-22914.html). 注意:如果clipsToBounds设置为YES,则阴影效果消失 let layer = view.layer layer.shadowColor = UIColor.black.cgColor//阴影颜色 layer.shadowOffset = CGSize(width: 10, height: 10)//width表示阴影与x的便宜量,height表示阴影与y值的偏移量 layer.shadowOpacity = 0.4//阴影透明度,默认为0则看不到阴影 layer.shadowRadius = 5; Go!]]></content>
      <categories>
        <category>iOS</category>
        <category>UIKit</category>
        <category>Layer</category>
      </categories>
      <tags>
        <tag>UIKit</tag>
        <tag>iOS</tag>
        <tag>Layer</tag>
        <tag>Shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit-Autoreleasepool]]></title>
<url>../../../../../../../../2017/11/22/iOS-UIKit/iOS-UIKit-Autoreleasepool/</url>
    <content type="text"><![CDATA[Autoreleasepool释放时机 每个个Runloop已经默认会创建一个Autoreleasepool 新增对Runloop的Observer, 及时获取Runloop的状态变化确认释放时机 添加一个监听者 创建监听者 - (void)addRunLoopObserver &#123; CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; switch (activity) &#123; case kCFRunLoopEntry: NSLog(@&quot;进入RunLoop&quot;); break; case kCFRunLoopBeforeTimers: NSLog(@&quot;即将处理Timer事件&quot;); break; case kCFRunLoopBeforeSources: NSLog(@&quot;即将处理Source事件&quot;); break; case kCFRunLoopBeforeWaiting: NSLog(@&quot;即将休眠&quot;); break; case kCFRunLoopAfterWaiting: NSLog(@&quot;被唤醒&quot;); break; case kCFRunLoopExit: NSLog(@&quot;退出RunLoop&quot;); break; default: break; &#125; &#125;); 添加监听者 CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);&#125; 测试 不手动添加autoreleasepool 方法运行连续运行两次, 不手动添加autoreleasepool - (void)test1 &#123; NSLog(@&quot;test1 begin!&quot;); for (int i = 0; i &lt; 10e5 * 2; i++) &#123; //@autoreleasepool &#123; NSString *str = [NSString stringWithFormat:@&quot;hi + %d&quot;, i]; //&#125; &#125; NSLog(@&quot;test1 finished!&quot;);&#125;- (void)test2 &#123; NSLog(@&quot;test2 begin!&quot;); for (int i = 0; i &lt; 10e5 * 2; i++) &#123; //@autoreleasepool &#123; NSString *str = [NSString stringWithFormat:@&quot;hi + %d&quot;, i]; //&#125; &#125; NSLog(@&quot;test2 finished!&quot;);&#125; Runloop没有完成一次循环之前所有内存都未释放, 即使局部变量出了作用域也必须等待Runloop循环完成 手动添加autoreleasepool观察释放时机 for{@autoreleasepool{}} 效果好于 @autoreleasepool{for…}@autoreleasepool{} @autoreleasepool&#123;&#125; 等价于 void *context = objc_autoreleasePoolPush();// &#123;&#125;中的代码objc_autoreleasePoolPop(context); 每次出了{}时objc_autoreleasePoolPop()就被调用, 所以直接释放掉了. 当然, 系统自动创建的autoreleasepool也是一样, 只是调用的时机不同: 线程与Runloop是一一对应, Runloop与系统创建的autoreleasepool也是一一对应, 所以不论是Runloop完成了一次循环还是线程被关闭时, autoreleasepool都会释放, 当然手动添加的也会被管理 主要就是一个类:AutoreleasePoolPage 两个函数: objc_autoreleasePoolPush()、objc_autoreleasePoolPop() 运作方式: autoreleasepool由若干个autoreleasePoolPage类以双向链表的形式组合而成 当程序运行到@autoreleasepool{时, objc_autoreleasePoolPush()将被调用, runtime会向当前的AutoreleasePoolPage中添加一个nil对象作为哨兵,在{}中创建的对象会被依次记录到AutoreleasePoolPage的栈顶指针,当运行完@autoreleasepool{}时, objc_autoreleasePoolPop(哨兵)将被调用, runtime就会向AutoreleasePoolPage中记录的对象发送release消息直到哨兵的位置, 即完成了一次完整的运作. 主线程中的自动释放池是自动创建的, 文档中说子线程中的自动释放池是需要手动创建的, 但实测, 其实我们常用的多线程管理方式(GCD, NSOprationQueue, NSThread)都已经帮我们处理好了, 其中NSThread在iOS7之后才自动创建线程中的AutoreleasePool 我们常用的for循环, 以及enumerate其实跟autoreleasepool也有关, for循环是不自动创建autoreleasepool的, 而enumerate中已经自动创建了autoreleasepool, 值得注意的是高并发enumerate常常会出一些意外的问题, 例如对象被提前释放, 所以建议高并发情况下使用for循环(性能高于enumerate), 再手动添加autoreleasepool.]]></content>
      <categories>
        <category>iOS</category>
        <category>UIKit</category>
      </categories>
      <tags>
        <tag>UIKit</tag>
        <tag>iOS</tag>
        <tag>Autoreleasepool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-RunTime-方法交换/拦截基础使用]]></title>
<url>../../../../../../../../2017/11/22/iOS-Garmmar/iOS-RunTime-方法交换-拦截基础使用/</url>
    <content type="text"><![CDATA[RunTime的消息机制参考链接 Objective-C的方法调用是属于消息传送的机制每个类都有一个isa的结构体指针在这个结构体里, 得到指定类的所有属性, 所有方法的列表, 也可以知父类是什么… 新建RTMsgModel RTMsgModel.h @interface RTMsgModel : NSObject- (void)ff_post;- (void)ff_getWithCount:(NSInteger)count; RTMsgModel.m - (void)ff_post&#123; NSLog(@&quot;被调用了: %@, 当前对象为: %@&quot;, NSStringFromClass([self class]), self);&#125;- (void)ff_getWithCount:(NSInteger)count&#123; NSLog(@&quot;被%ld人调用了&quot;, count);&#125; 测试消息机制//// ViewController.m// Runtime方法交换拦截//// Created by RN on 17/11/22.// Copyright © 2017年 YueKekui. All rights reserved.//#import &quot;ViewController.h&quot;#import &quot;RTMsgModel.h&quot;#import &lt;objc/message.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self show_runTimeMsg];&#125;#pragma mark - RunTime的消息机制/** * @brief: RunTime的消息机制 * * * * @attention： Xcode 会自动屏蔽通过objc_msgSend创建对象, 我们可以去到工程里设置 * Build Setting -&gt; Enable Strict Checking of objc_msgSend Calls 改成No */- (void)show_runTimeMsg&#123; //1.objc_getClass Class getClass = objc_getClass(&quot;RTMsgModel&quot;); NSLog(@&quot;Get The Class is: %@&quot;, getClass); //2.objc_msgSend RTMsgModel *messageModel = objc_msgSend(getClass, @selector(alloc)); NSLog(@&quot;alloc Object: %@&quot;, messageModel); // 在不调用init方法, 可以通过发消息调用想用的方法, 这里调用没有在.h文件里声明的方法会警告该方法没有声明 objc_msgSend(messageModel, @selector(ff_post)); messageModel = objc_msgSend(messageModel, @selector(init)); NSLog(@&quot;init Object: %@&quot;, messageModel); objc_msgSend(messageModel, @selector(ff_post)); // 还有另外一种写法, 就是把所有东西都集合在一起, 也就是我们常用的[[NSObject alloc] init];的原型 RTMsgModel *messageModelTwo = objc_msgSend(objc_msgSend(objc_getClass(&quot;RTMsgModel&quot;), @selector(alloc)), @selector(init)); objc_msgSend(messageModelTwo, @selector(ff_getWithCount:), 5);&#125;@end 打印2017-11-22 12:36:16.232 Runtime方法交换拦截[21927:3962074] Get The Class is: RTMsgModel2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] alloc Object: &lt;RTMsgModel: 0x600000003680&gt;2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] 被调用了: RTMsgModel, 当前对象为: &lt;RTMsgModel: 0x600000003680&gt;2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] init Object: &lt;RTMsgModel: 0x600000003680&gt;2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] 被调用了: RTMsgModel, 当前对象为: &lt;RTMsgModel: 0x600000003680&gt;2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] 被5人调用了 RunTime方法交换 建一个类RunTimeMethodModel.h #import &lt;Foundation/Foundation.h&gt;@interface RunTimeMethodModel : NSObject@property (nonatomic, copy) NSString *cl_height;@property (nonatomic, copy) NSString *cl_weight;- (NSString *)cl_height;- (NSString *)cl_weight;@end RunTimeMethodModel.m - (NSString *)cl_height &#123; return @&quot;我身高180&quot;;&#125;- (NSString *)cl_weight &#123; return @&quot;我体重280&quot;; &#125; 测试交换方法 执行方法交换 RunTimeMethodModel *methodModel = [[RunTimeMethodModel alloc] init]; NSLog(@&quot;身高: %@&quot;, methodModel.cl_height); NSLog(@&quot;体重: %@&quot;, methodModel.cl_weight); Method methodOne = class_getInstanceMethod([methodModel class], @selector(cl_height)); Method methodTwo = class_getInstanceMethod([methodModel class], @selector(cl_weight)); method_exchangeImplementations(methodOne, methodTwo); NSLog(@&quot;打印的内容: %@&quot;, [methodModel cl_height]); 打印身高: 我身高180体重: 我体重280 打印的内容: 我体重280 注意一点注意一点, 由于这里的ViewController会销毁, 但method_exchangeImplementations会一直存在, 再次进来的时候, 就会再次根据上次交换过的顺序再次交换 +load交换方法 +load交换方法+ (void)load &#123; Method methodOne = class_getInstanceMethod(self, @selector(cl_height)); Method methodTwo = class_getInstanceMethod(self, @selector(cl_weight)); method_exchangeImplementations(methodOne, methodTwo);&#125;- (NSString *)cl_height &#123; return @&quot;我身高180&quot;;&#125;- (NSString *)cl_weight &#123; return @&quot;我体重280&quot;;&#125; 打印 身高: 我体重280体重: 我身高180身高: 我体重280体重: 我身高180 +initialize交换方法 +load这个方法里的确是可以保证方法交换只有一次, 但这里有一个弊端, 就是当程序一运行就会执行这个方法交换了+load: 程序一开始就会去执行, 只执行一次.+initialize: 当类被初始化的时候会才会去执行, 该类只会执行一次. initializeclass_getInstanceMethod 获取实例方法method_exchangeImplementations 方法交换 + (void)initialize + &#123; Method methodOne = class_getInstanceMethod(self, @selector(cl_height)); Method methodTwo = class_getInstanceMethod(self, @selector(cl_weight)); method_exchangeImplementations(methodOne, methodTwo);&#125;- (NSString *)cl_height &#123; return @&quot;我身高180&quot;;&#125;- (NSString *)cl_weight &#123; return @&quot;我体重280&quot;;&#125; RunTime方法拦截 从刚刚我们就知道, 可以使用method_exchangeImplementations交换两个方法, 但只应用在本类, 现在我们来看看别的应 @implementation BaseModel- (void)cl_logBaseModel &#123; NSLog(@&quot;Base Model Log&quot;);&#125;@end@implementation InterceptModel- (void)cl_logInterceptModel &#123; NSLog(@&quot;Intercept You Method &quot;);&#125;@end 最终的实现 + (void)initialize &#123; Method mehtodOne = class_getInstanceMethod([BaseModel class], @selector(cl_logBaseModel)); Method mehtodTwo = class_getInstanceMethod([InterceptModel class], @selector(cl_logInterceptModel)); method_exchangeImplementations(mehtodOne, mehtodTwo);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; BaseModel *baseModel = [[BaseModel alloc] init]; [baseModel cl_logBaseModel];&#125;。 打印结果发现方法是被InterceptModel这个类拦截, 并且替换了InterceptModel的方法 [InterceptModel cl_logInterceptModel] 第15行 Intercept You Method 类方法也可以交换和拦截 新增类方法 #import &quot;BaseModel.h&quot;@implementation BaseModel- (void)cl_logBaseModel &#123; NSLog(@&quot;Base Model Log&quot;);&#125;+ (void)cl_logBaseModelClass &#123; NSLog(@&quot;Base Model Class Log&quot;);&#125;@end-----------------------------------------------@implementation InterceptModel- (void)cl_logInterceptModel &#123; NSLog(@&quot;Intercept You Method &quot;);&#125;+ (void)cl_logInterceptModelClass &#123; NSLog(@&quot;Intercept Class You Method &quot;);&#125;@end 最终实现class_getInstanceMethod 获取类方法method_exchangeImplementations initialize class_getInstanceMethod 实例方法 class_getClassMethod 类方法 method_exchangeImplementations 交换方法 + (void)initialize &#123; // 拦截实例方法 Method mehtodOne = class_getInstanceMethod([BaseModel class], @selector(cl_logBaseModel)); Method mehtodTwo = class_getInstanceMethod([InterceptModel class], @selector(cl_logInterceptModel)); method_exchangeImplementations(mehtodOne, mehtodTwo); // 拦截类方法 Method classMehtodOne = class_getClassMethod([BaseModel class], @selector(cl_logBaseModelClass)); Method classMehtodTwo = class_getClassMethod([InterceptModel class], @selector(cl_logInterceptModelClass)); method_exchangeImplementations(classMehtodOne, classMehtodTwo);&#125; 执行 self.view.backgroundColor = [UIColor whiteColor];BaseModel *baseModel = [[BaseModel alloc] init];[baseModel cl_logBaseModel];[BaseModel cl_logBaseModelClass]; 打印 Intercept You Method Intercept Class You Method]]></content>
      <categories>
        <category>iOS</category>
        <category>RunTime</category>
      </categories>
      <tags>
        <tag>RunTime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit-UIScrollView基础用法]]></title>
<url>../../../../../../../../2017/11/22/iOS-UIKit/iOS-UIKit-UIScrollView基础用法/</url>
    <content type="text"><![CDATA[属性- (void)viewDidLoad &#123; [super viewDidLoad]; _scrollView.backgroundColor = [UIColor redColor]; //设置contentSize（必须设置） _scrollView.contentSize = CGSizeMake(400, 667); //偏移量 _scrollView.contentOffset = CGPointMake(100, 0); //contentInset(在原有的基础上调整内容滚动区域的大小) //_scrollView.contentInset = UIEdgeInsetsMake(-100, 0, 0, 0); //锁定方向(当系统识别滚动方向的时候，会把另外一个方向锁定，如果识别不了，就不锁定方向) _scrollView.directionalLockEnabled = YES; //反弹效果(默认为yes) _scrollView.bounces = YES; //默认是no，假如是yes并且bounces是yes,甚至如果内容大小小于bounds的时候，允许垂直拖动 _scrollView.alwaysBounceVertical = YES; //分页（默认no） _scrollView.pagingEnabled = YES; //滚动(默认yes允许滚动) _scrollView.scrollEnabled = YES; //滚动条 //showsHorizontalScrollIndicator默认yes 显示 _scrollView.showsHorizontalScrollIndicator = NO; //滚动条滚动的范围(垂直滚动条滚动范围上下各缩小50) _scrollView.scrollIndicatorInsets = UIEdgeInsetsMake(50, 0, 50, 0); //样式 _scrollView.indicatorStyle = UIScrollViewIndicatorStyleWhite; // Do any additional setup after loading the view, typically from a nib.&#125; 方法- (void)viewDidLoad &#123; [super viewDidLoad]; //创建并添加scrollView UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(100, 200, 200, 300)]; [self.view addSubview:scrollView]; scrollView.backgroundColor = [UIColor redColor]; //设置内容视图的大小 scrollView.contentSize = CGSizeMake(375, 667); //设置内容视图 UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 375, 667)]; imageView.image = [UIImage imageNamed:@&quot;new_feature_1&quot;]; [scrollView addSubview:imageView]; _imageView = imageView; //设置代理 scrollView.delegate = self; //[self performSelector:@selector(changeScrollViewContentOffSet:) withObject:scrollView afterDelay:3]; //设置缩放内容视图的缩放比例范围 scrollView.minimumZoomScale = 0.5; scrollView.maximumZoomScale = 1.5; //当缩放比例超出范围之后，是否有反弹效果（no:不会超出范围，yes:超出范围之后反弹） scrollView.bouncesZoom = YES; //属性设置滚动至顶部 //scrollView.scrollsToTop = YES; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)changeScrollViewContentOffSet:(UIScrollView *)scrollView&#123; [scrollView setContentOffset:CGPointMake(0, 300) animated:YES];&#125;#if 0#pragma mark -UIScrollViewDelegate 滚动//当scrollView滚动的时候，不停调用（可以监听scrollView的contentOffset）- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; //NSLog(@&quot;%@&quot;,NSStringFromCGPoint(scrollView.contentOffset)); //NSLog(@&quot;decelerating：%d&quot;,scrollView.decelerating); //NSLog(@&quot;dragging：%d&quot;,scrollView.dragging); //NSLog(@&quot;tracking:%d&quot;,scrollView.tracking); NSLog(@&quot;%s&quot;,__func__);&#125;//开始拖动的时候调用- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123; //NSLog(@&quot;tracking:%d&quot;,scrollView.tracking); NSLog(@&quot;%s&quot;,__func__);&#125;// called on finger up if the user dragged. velocity is in points/millisecond. targetContentOffset may be changed to adjust where the scroll view comes to rest//将要结束拖动- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset &#123;// NSLog(@&quot;velocity:%@&quot;,NSStringFromCGPoint(velocity));// NSLog(@&quot;targetContentOffset:%@&quot;,NSStringFromCGPoint(*targetContentOffset)); //强制设置scrollView的偏移量 //*targetContentOffset = CGPointMake(0, 200); NSLog(@&quot;%s&quot;,__func__);&#125;// 已经结束拖动- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; //NSLog(@&quot;dragging：%d&quot;,scrollView.dragging); NSLog(@&quot;%s&quot;,__func__);&#125;//将要开始减速- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView&#123; //NSLog(@&quot;decelerating：%d&quot;,scrollView.decelerating); NSLog(@&quot;%s&quot;,__func__);&#125;//减速完成（停止）- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; //NSLog(@&quot;contentOffset:%@&quot;,NSStringFromCGPoint(scrollView.contentOffset)); NSLog(@&quot;%s&quot;,__func__);&#125;// called when setContentOffset/scrollRectVisible:animated: finishes. not called if not animating- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView&#123; NSLog(@&quot;%s&quot;,__func__);&#125;#endif#pragma mark -UIScrollViewDelegate(缩放)//指定缩放视图- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView&#123; NSLog(@&quot;%s,zooming:%d&quot;,__func__,scrollView.zooming); return _imageView;&#125;//缩放之前调用- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view &#123; NSLog(@&quot;%s,zooming:%d&quot;,__func__,scrollView.zooming);&#125;//完成缩放- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view atScale:(CGFloat)scale&#123; NSLog(@&quot;%s,zooming:%d&quot;,__func__,scrollView.zooming);&#125;//缩放时调用- (void)scrollViewDidZoom:(UIScrollView *)scrollView&#123; NSLog(@&quot;%s,zooming:%d&quot;,__func__,scrollView.zooming);&#125;#pragma mark -UIScrollViewDelegate(滚动至顶部)//允许滚动至顶部- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView&#123; return YES;&#125;//已经滚动至顶部- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView&#123; NSLog(@&quot;加载新数据，刷新界面&quot;);&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>UIKit</category>
        <category>UIScrollView</category>
      </categories>
      <tags>
        <tag>UIKit</tag>
        <tag>UIScrollView</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS_App跳转设置]]></title>
<url>../../../../../../../../2017/11/21/iOS-Func/iOS-Func-App跳转设置/</url>
    <content type="text"><![CDATA[跳到更多设置界面除了跳到WiFi设置界面，能不能跳到其他的设置界面呢？比如：定位服务、FaceTime、音乐等等。都是可以的，一起来看看如何实现的 跳到这些界面的参数配置： ##定位服务 用户关闭了定位,APP里面提示打开定位服务点击到设置界面设置，直接跳到定位服务设置界面= //定位服务设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=LOCATION_SERVICES&quot;];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; FaceTim//FaceTime设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=FACETIME&quot;];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; 音乐//音乐设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=MUSIC&quot;];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; 蓝牙设置界面//蓝牙设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=Bluetooth&quot;];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; iCloud设置界面//iCloud设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=CASTLE&quot;];if ([[UIApplication sharedApplication] canOpenURL:url]&#123; [[UIApplication sharedApplication] openURL:url];&#125; other设置界面只需要prefs:root=后面的值即可可以跳到这些界面的参数配置：r About — prefs:root=General&amp;path=AboutAccessibility — prefs:root=General&amp;path=ACCESSIBILITYAirplane Mode On — prefs:root=AIRPLANE_MODEAuto-Lock — prefs:root=General&amp;path=AUTOLOCKBrightness — prefs:root=BrightnessBluetooth — prefs:root=General&amp;path=BluetoothDate &amp; Time — prefs:root=General&amp;path=DATE_AND_TIMEFaceTime — prefs:root=FACETIMEGeneral — prefs:root=GeneralKeyboard — prefs:root=General&amp;path=KeyboardiCloud — prefs:root=CASTLEiCloud Storage &amp; Backup — prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUPInternational — prefs:root=General&amp;path=INTERNATIONALLocation Services — prefs:root=LOCATION_SERVICESMusic — prefs:root=MUSICMusic Equalizer — prefs:root=MUSIC&amp;path=EQMusic Volume Limit — prefs:root=MUSIC&amp;path=VolumeLimitNetwork — prefs:root=General&amp;path=NetworkNike + iPod — prefs:root=NIKE_PLUS_IPODNotes — prefs:root=NOTESNotification — prefs:root=NOTIFICATIONS_IDPhone — prefs:root=PhonePhotos — prefs:root=PhotosProfile — prefs:root=General&amp;path=ManagedConfigurationListReset — prefs:root=General&amp;path=ResetSafari — prefs:root=SafariSiri — prefs:root=General&amp;path=AssistantSounds — prefs:root=SoundsSoftware Update — prefs:root=General&amp;path=SOFTWARE_UPDATE_LINKStore — prefs:root=STORETwitter — prefs:root=TWITTERUsage — prefs:root=General&amp;path=USAGEVPN — prefs:root=General&amp;path=Network/VPNWallpaper — prefs:root=WallpaperWi-Fi — prefs:root=WIFI]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS_Safari跳转App]]></title>
<url>../../../../../../../../2017/11/21/iOS-Garmmar/iOS-Safari-跳转App/</url>
    <content type="text"><![CDATA[Safari跳转到App##App中定义一个URL协议 TARGETS -&gt; info -&gt; URL Types -&gt; 添加一个URL协议 URL Schemes字段就是你这个APP的特殊标示，indentifier:这个URL协议的标示。一个APP可以拥有多个URL协议下面的两个字段可为空。最后再运行一下你的APP。 浏览里访问打开Safari浏览器，在输入在地址栏输入：myapp://然后回车 Safari跳回到APP时传一些参数比如在Safari浏览器的地址了输入：myapp://myappTest，用下面的方法获取到该参数之后就看自己的操作了 在appdelegate.m文件中写下如下方法如果iOS版本低于9.0，会在下面方法接受到在地址栏输入的字符串- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; [[[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@&quot;sourceApplication-&gt;%@&quot;, [url absoluteString]] message:nil delegate:nil cancelButtonTitle:@&quot;ok&quot; otherButtonTitles:nil] show]; return YES;&#125;如果iOS版本是9.0及以上的，会在下面方法接受到在地址栏输入的字符串- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options&#123; [[[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@&quot;openURL-&gt;%@&quot;, [url absoluteString]] message:nil delegate:nil cancelButtonTitle:@&quot;ok&quot; otherButtonTitles:nil] show]; return YES;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
      <tags>
        <tag>Func</tag>
        <tag>跳转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func- Universal Links通用链接]]></title>
<url>../../../../../../../../2017/11/21/iOS-Func/iOS-Func- Universal Links通用链接/</url>
    <content type="text"><![CDATA[Universal Links简介 iOS9之前 iOS9之前,对于从各种从浏览器,Safari、UIWebView或者 WKWebView中唤醒APP的需求,我们通常只能使用scheme.首先是app中注册某个scheme 在iOS 9以后 通过Universal Link，将App 与网页端建立连接桥，可以从Safari 或者其他前端浏览器来识别并唤醒App，甚至是微信环境下也可以冲破障碍 官方的说明文档–&gt; Universal Link的优点 唯一性: 不像自定义的scheme,因为它使用标准的http/https链接到你的web站点,所以它不会被其它的app所声明.另外,Custom URL scheme 因为是自定义的协议，所以在没有安装 app 的情况下是无法直接打开的，而 universal links 本身是一个 HTTP/HTTPS 链接，所以有更好的兼容性 安全: 当用户的手机上安装了你的app,那么iOS将去你的网站上去下载你上传上去的说明文件(这个说明文件声明了你的app可以打开哪些类型的http链接).因为只有你自己才能上传文件到你网站的根目录,所以你的网站和你的app之间的关联是安全的. 可变: 当用户手机上没有安装你的app的时候,Universal Links也能够工作.如果你愿意,在没有安装你的app的时候,用户点击链接,会在safari中展示你网站的内容. 简单: 一个URL链接,可以同时作用于网站和ap 私有 其它app可以在不需要知道你的app是否安装了的情况下和你的app相互通信 需求 分享页面中，我们经常会看到在页面的顶端或者底部遇到有【打开App】或者【下载App】这样的按钮。 比较友好的产品，会做设备识别，以及检测APP是否安装，来做打开或者下载App 的需求但是在微信中，这方面做的比较恶心，微信下面几乎是全面屏蔽了唤起原生App 的功能 Universal Link 实现条件 域名 有一个域名,且这个域名的网站需要支持https,然后拥有网站的上传到根目录的权限(这个权限是为了上传一个apple指定的文件) 支持Universal Links(通用链接) 创建一个json格式的命名为apple-app-site-association文件 注意这个文件必须没有后缀名,文件名必须为: apple-app-site-association &#123; "applinks": &#123; "apps": [], "details": [ &#123; "appID": "Prefix +点 +BundleID", "paths": [ "/html/1/*", "/*"], &#125;, ] &#125;&#125; Prefix 和 BundleID paths:根据 paths 键设定一个你的app支持的路径列表,只有这些指定的路径的链接,才能被app所处理,举个例子:如果你的网站是www.XXXX.com,你的path写的是”/support/“,那么当用户点击www.yohunl.com/support/myDoucument,就可以进入你的app了,相反www.yohunl.com/other 就不会.path是大小写敏感的! 号表示任意路径. 服务器服务器配置 准备独立域名一级域名，二级域名均可。SSL 证书 为服务器配置HTTPS 用的SSL 证书上传签名好的JSON 配置文件 新建JSON文件新建一个JSON文件，不需要后缀名，内容输入以下代码： appID:相关内容可以在Developer 中心找到相关的内容。如图，前半部分为Prefix 后半部分为ID，即你的App 的bundle id，两者通过.相连paths:用来唤醒App 所需要指定的JSON文件在服务器中的路径。用”/* “ 是根目录，而/html 则是指html目录下的注意：这里的AppID中前半部分，在App 转让主体后会改变，需重新更新填好后保存为apple-app-site-association 名，上传到域名指向的服务器根目录。 &#123; "applinks": &#123; "apps": [], "details": [ &#123; "appID": "5B5Q4xxxx.com.xxxx.xxxx", "paths": [ "/html/1/*", "/*"] &#125;, ] &#125;&#125; 上传传该文件apple-app-site-association 上传传该文件apple-app-site-association到你的域名所对应的网站的根目录下(其实也不一定是根目录,例如ghost博客站点,就没有根目录一说,它就需要放在相应的主题目录下) 这一步是为了苹果能从https://你的域名/apple-app-site-associationxh获取到你上传的apple-app-site-association文件.上传完后,自己先访问一下,看看是否能够获取到,用我的做例子,https://yohunl.com/apple-app-site-association ,当你点击这个链接,应该是下载apple-app-site-association文件.验证该文件是否合法,苹果为了方便开发者,提供了一个网页来验证我们编写的这个apple-app-site-association是否合法有效,验证网址,进入网站进行验证 App配置工程文件配置 在工程文件中，找到Targets - Capabilities - Associated Domains 将开关选为On，并添加你的域名， 格式为 applinks: + 后台给的域名.com applinks: + www.后台给的域名.com iOS移动端的代码- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler&#123; if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb]) &#123; NSString *url = userActivity.webpageURL.description; // 这里可以通过拆分url 来传入参数，达到跳转原生页面的功能，如跳转某商品页 [UIApplication sharedApplication] openURL:webpageURL]; &#125; return YES;&#125; h5网页配置 h5网页中对需要唤起App 的按钮或者控件添加点击事件，事件的函数代码如下: function wakeUpApp()&#123; if (navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) &#123; var loadDateTime = new Date(); window.setTimeout(function() &#123; var timeOutDateTime = new Date(); if (timeOutDateTime - loadDateTime &lt; 5000) &#123; window.location.href = "http://a.app.qq.com/o/simple.jsp?pkgname=你的应用宝BundleID"; &#125; else &#123; window.close(); &#125; &#125;, 25); window.location.href = "https://yourdomainname.com/"; &#125; else if (navigator.userAgent.match(/android/i)) &#123; var state = null; try &#123; state = window.open("apps custom url schemes ", '_blank'); &#125; catch(e) &#123;&#125; if (state) &#123; window.close(); &#125; else &#123; window.location.href = "要跳转的页面URL"; &#125; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MarkDomn语法]]></title>
<url>../../../../../../../../2017/11/21/MarkDown/MarkDown-语法/</url>
    <content type="text"><![CDATA[目录效果生成目录* [1.语法示例](#1)* [1.1图片](#1.1) * [1.2换行](#1.2)* [1.3强调](#1.3) * 字体h1&gt;h2&gt;h3.... &lt;h2 id=&quot;1&quot;&gt;目录标题&lt;/h2&gt; 效果 1.h2比h1字体小 1.1图片 1.2换行 1.3强调 页面内跳转锚 放在 目的地定义一个锚(id)： 跳转markdown语法[点击跳转--&gt;](#index)]]></content>
      <categories>
        <category>Tool</category>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDomn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS_App_代码规范]]></title>
<url>../../../../../../../../2017/11/20/iOS-Code/iOS-Code-代码规范/</url>
    <content type="text"><![CDATA[iOS编码规范#命名 变量命名 首字母小写，驼峰法则UI控件（描述+控件类型） priceLabel或priceLab 注释也要写 最好对齐 @property (nonatomic, strong) UIButton *collectsImgView; //合集 - 图标@property (nonatomic, strong) UILabel *collectsThemeLab; //合集 - 主题@property (nonatomic, strong) UILabel *collectsAuthorLab; //合集 - 作者 方法命名 首字母小写，驼峰法则 public method 规则： 方法用途单词_方法 一般的方法 - (void)show_editBtnOnOneViewC:(OneViewC *)oneViewC editBtn:(UIButton *)editBtn.....跳转 push_更新数据 update_collectList删除数据 delete_collectList private method 规则：不加下划线 不需要and： nameStr:(NSstring)nameStr - (void)pushOnewViewC:(OnewViewC *)onewViewC - nameStr:(NSstring)nameStr &#123;&#125; 扩展或封装方法 规则：以FF或ff开头 FanFan简写 - (void)ff_editOnOneViewC:(oneViewC)oneViewC isOpen:(BOOL) isOpen 少用#define预处理指令，多用类型常量 预处理指令命名 （字母全大写，以”_”分割） #define NSString * APP_ROOT_DIR @"xxx" 常量命名 （字母全大写，”k”开头） static NSString * const kAPPROOTDIR = @"xxx"; 资源文件中变量命名 全小写，”“分割模块： 开发功能模块外 nav tab login refresh share hud common(公有)格式：“模块类别状态描述” 状态可不要目前版本我们以模块作为文件夹 ，后面的按照这个4个 personal_btn_un_select.pngpersonal_btn_name_pngnav_btn_left.pngnav_imgView_lright.pngtab_item_un_select.pngtab_item_select.png 能用糖衣语法的尽量用糖衣语法，使用时注意nil报错。NSMutableArray = @[].mutableCopy;NSString *name = dic[@"name"];NSArray *array= @[item1, item2]; 用前缀避免命名空间冲突。大多数的自定制，都需要用前缀比如创建有读界面 Have (文件夹) ViewC(文件夹) HaveReadViewC.h View HaveReadView.h Model HaveReadModel.h Cell HaveReadCell.h 委托Delegate的定义和使用放在对应类的.h文件中，命名为该类名+Delegate，//定义代理HaveReadViewCDelegate ==&gt;HaveReadViewC + DelegateHaveReadCellDelegate ==&gt; HaveReadCell + Delegate//声明@property (nonatomic, weak) id &lt;ArticleHeadTableUrlDelegate&gt; delegate;//必须加判断！！！if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(push_safariWithUrl:)]) &#123; [_delegate pushSafariWithUrl:XXXXX]; &#125; 注释使用清晰而协调的命名方式+适当注释/** * @beif: 执行push操作 （ 简单明了就可以） * * @prama: namestr 名称 * @prama: isOpen 是否打开 0 = 关闭 1= 打开 * * @discussion: 注意这个方法子啊使用时候XXXXXXXX 等等 * **/ viewC里区块划分 h文件顶部:类的作用 类的注意一些内容 /** 订阅合集 分2种 我的订阅 xxxx 他的订阅 xxx */ 代理 @protocol XXXXXDelegate &lt;NSObject&gt;@required@optional- (void)delete_nameOnOne:(类 *)one nameStr:(NSString *) nameStr .... 代码结构 //#pragma ------------------ LifeCycle生命周期 -----------------//#pragma ------------------ Setter- (void)setNameLab:(UILable *)nameLab &#123; _nameLab = nameLab; &#125;//#pragma ------------------ Getter- (UIButton *)nameBtn:(UIButton *) nameBtn&#123; if(!_ nameBtn)&#123; nameBtn = ... [self addSubView: nameBtn]; &#125; return nameBtn;&#125;//#pragma ------------------ Layout ------------------//#pragma - nameBtn//#pragma - nameBtn - action //布局- (void)layoutSubviews;//#pragma ------------------ Plubic Method ------------------- (void)update_newViewC....- (BOOL)delete_editBtn.....//#pragma ------------------ private Method ------------------- (void)updateNewViewC....- (BOOL)deleteEditBtn.....//#pragma mark ------------- API ------------------//#pragma mark ------------- 代理//#pragma ------------------ Cell ------------------/** * @brief: 设置cell * * @prama: tableView * @prama: model * @prama: indexPath * */+( PersonalSubscribeCell *)show_cellOfTableView:(UITableView *)tableView model:(PersonalSubscribeModel *)model indexPath:(NSIndexPath *)indexPath 编程习惯 一个原则：能不做的事情，尽量不做，尽量少唤醒CPU，绝不能在UI线程中做耗时操作（如网络请求，数据库读写，文件读写等） Copy、mutableCopy要注意其关联的元素是否支持for循环 不要在循环中创建引用类型变量for循环中，用局部变量替代“array.count” @autoreleasepool@autoreleasepool&#123; for（）&#123; @autoreleasepool&#123;&#125; &#125;&#125; 引用变量声明放在循环外面，可以避免在栈内存中创建过多引用变量UserInfo userInfo;// 避免循环中每次都要调用userList.count取值int size = userList.count;for (int i = 0; i &lt; size; i++) &#123; userInfo = userList[i]; // do something...&#125;// 推荐for (int i = 0, max = userList.count; i &lt; max; i++) &#123; userInfo = userList[i]; // do something...&#125; NSString 在不需要外部任意修改的情况下，全部用Copy Block Block内部需要使用外部类变量的时候,防止循环引用切忌在block体中使用_name这样的变量，请使用self.name otehr 由于Objective-C是类型不安全的，注意加强类型判断、数据越界判断等等原则上不建议拷贝代码，同一段代码拷贝3次，必须抽离出一个方法，统一调用所有的系统的宏，都不得在任意地方乱定义，统一在FFConfig文件夹下的头文件中定义，并写好注释ViewController中的代码要分结构，多用#pragma mark - Life Circle对代码进行分区，ViewController中的代码分区可分为Life Circle、Request、Private、Delegate、Lazy等等ViewController中的代码尽量不要超过500行，注意优化 API 一级界面，API考虑离线缓存如果你用一句话无法将一个方法的内容表述清楚的话，这往往就意味着API的名字需要改进了；例如：removeAtPoint:就会比remove要清晰很多 提交代码规范提交代码时的描述必须写，且简明扼要就可以 我们的目标是让每一位小伙伴都能欣赏我们的代码]]></content>
      <categories>
        <category>iOS</category>
        <category>Code</category>
      </categories>
      <tags>
        <tag>iOS编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImag加载高分辨率图问题]]></title>
<url>../../../../../../../../2017/11/20/iOS-Lib/iOS-Lib-SDWebImag加载高分辨率图问题/</url>
    <content type="text"><![CDATA[SDWebImage_图片分辨率过高内存过高问题#高分辨率多图问题： 高分辨率图，导致内存飙升，卡顿，设置闪退,提示： Restore the connection to &quot;“XXX”的 iPod&quot; and run &quot;XXX&quot; again, or if &quot;XXX&quot; is still running, you can attach to it by selecting Debug &gt; Attach to Process &gt; XXX. 由于应用程序突然消耗了大量内存，然后再分配调度内存的时候，出现错误，致使系统将APP进程关闭。能够去查看一下是不是载入了大量的图片等等，或者哪里有消耗内存的地方改动一下。 分析SDWebimage， 1.判断本地是否有这张图2.二有的时候直接从本地取图片3.没有的时候去网络下载 if(imgStr.length&gt;0)&#123; [[SDImageCache sharedImageCache] queryDiskCacheForKey:imgStr done:^(UIImage *image, SDImageCacheType cacheType) &#123; if (image) &#123; [_oneImage setImage:image]; &#125;else&#123; [_oneImage sd_setImageWithURL:kNSUrl(imgStr) placeholderImage:IMGNAMED(@&quot;defaultAvatar2&quot;) options:SDWebImageRefreshCached completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123; if (image) &#123; [[SDImageCache sharedImageCache] storeImage:image forKey:imgStr toDisk:YES]; &#125; &#125;]; &#125; &#125;];&#125; 内部会调用下面这个方法- (UIImage *)diskImageForKey:(NSString *)key &#123; NSData *data = [self diskImageDataBySearchingAllPathsForKey:key]; if (data) &#123; UIImage *image = [UIImage sd_imageWithData:data]; image = [self scaledImageForKey:key image:image]; image = [UIImage decodedImageWithImage:image]; return image; &#125; else &#123; return nil; &#125; &#125; UIImage *image = [UIImage sd_imageWithData:data];图片取出来的时候就已经巨大无比，占用了很大的内存，导致内存来不及释放就崩溃 解决UIImage+MultiFormat这个类里面添加如下压缩方法，+(UIImage *)compressImageWith:(UIImage *)image &#123; float imageWidth = image.size.width; float imageHeight = image.size.height; float width = 640; float height = image.size.height/(image.size.width/width); float widthScale = imageWidth /width; float heightScale = imageHeight /height; // 创建一个bitmap的context // 并把它设置成为当前正在使用的context UIGraphicsBeginImageContext(CGSizeMake(width, height)); if (widthScale &gt; heightScale) &#123; [image drawInRect:CGRectMake(0, 0, imageWidth /heightScale , height)]; &#125; else &#123; [image drawInRect:CGRectMake(0, 0, width , imageHeight /widthScale)]; &#125; // 从当前context中创建一个改变大小后的图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); // 使当前的context出堆栈 UIGraphicsEndImageContext(); return newImage; &#125; 修改第三方方法#ifdef SD_WEBP else if ([imageContentType isEqualToString:@&quot;image/webp&quot;]) &#123; image = [UIImage sd_imageWithWebPData:data]; &#125; #endif else &#123; image = [[UIImage alloc] initWithData:data]; if (data.length/1024 &gt; 128) &#123; image = [self compressImageWith:image]; &#125; UIImageOrientation orientation = [self sd_imageOrientationFromImageData:data]; if (orientation != UIImageOrientationUp) &#123; image = [UIImage imageWithCGImage:image.CGImage scale:image.scale orientation:orientation]; &#125; 设置加载在SDWebImageDownloaderOperation的connectionDidFinishLoading方法里面的 UIImage *image = [UIImage sd_imageWithData:self.imageData]; //将等比压缩过的image在赋在转成data赋给self.imageData NSData *data = UIImageJPEGRepresentation(image, 1); self.imageData = [NSMutableData dataWithData:data]; 再配合 [[SDImageCache sharedImageCache] setValue:nil forKey:@&quot;memCache&quot;];（图片加载后使用）大功告成，亲测内存基本变化不大，自动释放也来得及]]></content>
      <categories>
        <category>iOS</category>
        <category>Lib</category>
        <category>SDWebImage</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-Lib-UM-UMAnalytics友盟统计]]></title>
<url>../../../../../../../../2017/11/20/iOS-Lib/iOS-Lib-UM-UMAnalytics友盟统计/</url>
    <content type="text"><![CDATA[UMAnalytics友盟统计埋点官方 配置 文档—&gt; Go! 配置集成Appkey不同平台的应用禁止使用相同的Appkey，需要分开注册友盟后台的应用名与实际应用名和包名无关，建议命名为“应用名+平台（IOS/Android)” 使用 Cocoapods 安装 SDK //标准SDK，含IDFA pod &apos;UMengAnalytics&apos; 无IDFA版SDK（请根据需要选择其中一个） pod &apos;UMengAnalytics-NO-IDFA&apos; 基本功能集成配置 AppDelegate.m 主要包括填写Appkey，设置发送策略和填写渠道id三部分UMConfigInstance为SDK参数配置的实例类，只需要将其成员中标注为required的参数赋值，optional的为可选项。appKey: 统计分析-&gt;设置-&gt;应用信息ChannelId: 应用的渠道标识。默认为 @”App Store” 头文件：&quot;UMMobClick/MobClick.h&quot;- (BOOL])application:(UIApplication] *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; UMConfigInstance.appKey = @&quot;xxxxxxxxxxxxxx...&quot;; UMConfigInstance.ChannelId = @&quot;App Store&quot;; //仅适用于游戏场景，应用统计不用设置 UMConfigInstance.eSType = E_UM_GAME; //配置以上参数后调用此方法初始化SDK！ [MobClick startWithConfigure:UMConfigInstance];&#125; 页面的统计 runtime写交换方法不太好基础类可增加 - (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [MobClick beginLogPageView:@&quot;PageOne&quot;];//(&quot;PageOne&quot;为页面名称，可自定义) &#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [MobClick endLogPageView:@&quot;PageOne&quot;]; &#125; 自定义事件的统计 计数事件+计算事件 计数事件统计发生次数 某个事件发生的次数 [MobClick event:(NSString *)eventId]; 统计点击行为各属性被触发的次数[MobClick event:(NSString *)eventId attributes:(NSDictionary *)attributes];NSDictionary *dict = @&#123;@&quot;type&quot; : @&quot;book&quot;, @&quot;quantity&quot; : @&quot;3&quot;&#125;;[MobClick event:@&quot;purchase&quot; attributes:dict]; 计算事件 使用计算事件需要在后台添加事件时选择“计算事件” 统计数值型变量的值的分布 统计一个数值类型的连续变量（该变量必须为整数），用户每次触发的数值的分布情况，如事件持续时间、每次付款金额等，可以调用如下方法: +[MobClick event:(NSString *)eventId attributes:(NSDictionary *)attributes counter:(int)number]; 示例：购买《Swift Fundamentals》这本书，花了110元 [MobClick event:@&quot;pay&quot; attributes:@&#123;@&quot;book&quot; : @&quot;Swift Fundamentals&quot;&#125; counter:110]; 如果您使用的是V3.1.2以下版本的SDK，请使用下面的方法： -(void)umengEvent:(NSString *)eventId attributes:(NSDictionary *)attributes number:(NSNumber *)number&#123; NSString *numberKey = @&quot;__ct__&quot;; NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:attributes]; [mutableDictionary setObject:[number stringValue] forKey:numberKey]; [MobClick event:eventId attributes:mutableDictionary]; &#125; 示例：购买《Swift Fundamentals》这本书，花了110元 [self umengEvent:@&quot;pay&quot; attributes:@&#123;@&quot;book&quot; : @&quot;Swift Fundamentals&quot;&#125; number:@(110)];]]></content>
      <categories>
        <category>iOS</category>
        <category>Lib</category>
        <category>UM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS -Lib-JSBadgeView数字角标]]></title>
<url>../../../../../../../../2017/11/14/iOS-Lib/iOS-Lib-JSBadgeView数字角标/</url>
    <content type="text"><![CDATA[使用方法//在父控件上显示，//显示的位置TopRight self.badgeView = [[JSBadgeView alloc]initWithParentView:parentView alignment:JSBadgeViewAlignmentTopRight]; //位置 self.badgeView.badgePositionAdjustment = CGPointMake(-15, 10);//设置tag要辨别 self.badgeView.tag = 10086;//背景色self.badgeView.badgeBackgroundColor = [UIColor redColor]; //没有反光面self.badgeView.badgeOverlayColor = [UIColor clearColor]; //外圈的颜色，默认是白色 self.badgeView.badgeStrokeColor = [UIColor redColor]; 设置数字//1、用字符self.badgeView.badgeText = @&quot;1&quot;; //2、如果不显示就设置为空self.badgeView.badgeText = nil; //当更新数字时，最好刷新，不然由于frame固定的，数字为2位时，红圈变形 [self.badgeView setNeedsLayout];]]></content>
      <categories>
        <category>iOS</category>
        <category>Lib</category>
        <category>JSBadgeView</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UI</tag>
        <tag>Lib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit-UILaebl_Shadow文字阴影]]></title>
<url>../../../../../../../../2017/11/14/iOS-UIKit/iOS-UIKit-UILabel-Shadow文字阴影/</url>
    <content type="text"><![CDATA[#方法1 设置UILabel中的shadowColor和shadowOffset属性 问题:阴影没有模糊效果，并且无法设置阴影的宽度等等，比较具有局限性 #方法2 NSShadow *shadow = [[NSShadow alloc]init]; shadow.shadowBlurRadius = 1; shadow.shadowOffset = CGSizeMake(0,1); shadow.shadowColor = [UIColor colorWithWhite:0 alpha:0.6]; NSAttributedString *attText = [[NSAttributedString alloc]initWithString:[NSString stringWithFormat:@&quot;%@浏览过&quot;,!model.read_num?@&quot;0&quot;:model.read_num] attributes:@&#123;NSShadowAttributeName:shadow&#125;]; cell.skimLab.attributedText = attText;]]></content>
      <categories>
        <category>iOS</category>
        <category>UIKit</category>
        <category>UILabel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Runtime实践:占位图]]></title>
<url>../../../../../../../../2017/11/13/iOS-Garmmar/iOS-RunTime-占位图/</url>
    <content type="text"><![CDATA[辈出有读 里代码]]></content>
      <categories>
        <category>iOS</category>
        <category>RunTime</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-内存检测工具Analyze]]></title>
<url>../../../../../../../../2017/11/13/iOS-Func/iOS-Func-内存检测工具Analyze/</url>
    <content type="text"><![CDATA[内存检测工具Analyze开启Analyzexcode----product-----Analyze(快捷键:Shift + Cmd + B) iOS的分析工具可以发现编译中的warning，内存泄漏隐患，甚至还可以检查出logic上的问题在自测阶段一定要解决Analyze发现的问题，可以避免出现严重的bug 常见问题 内存泄漏隐患提示 Potential Leak of an object allocated on line …… 数据赋值隐患提示 The left operand of …… is a garbage value 对象引用隐患提示 Reference-Counted object is used after it is released 具体问题重写UIViewController的生命周期方法没有调用父类的方法eg: The ‘viewWillAppear:’ instance method in UIViewController subclass ‘YourViewController’ is missing a [super viewWillAppear:] call &gt; -(void)viewWillAppear:(BOOL)animated&#123; [superviewWillAppear:YES]; //your code...&#125; 初始化的变量并没有被使用eg: value stored to ‘YourVariable’ is never read 变量多次初始化，其中的某些初始化的变量并没有使用过eg: value stored to ‘YourVariable’during its initialization is never read 重新父类的初始化方法时没有调用父类的初始化方法 错误代码示例： -(instancetype)initWithFrame:(CGRect)frame&#123; if(self== [superinitWithFrame:frame])&#123; &#125; return self;&#125; 先调用父类的初始化方法，再自定义处理 -(instancetype)initWithFrame:(CGRect)frame&#123; self = [superinitWithFrame:frame]; if (self) &#123; &#125; return self;&#125; 属性标明错误(strong,retain,assign)potential leak of an object 变量未初始化就使用The left operand of ‘+’ is a garbage value]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
      <tags>
        <tag>Func</tag>
        <tag>iOS</tag>
        <tag>Analyze</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-异常捕获-堆栈信息的解析]]></title>
<url>../../../../../../../../2017/11/11/iOS-Func/iOS-Func-异常捕获-堆栈信息的解析/</url>
    <content type="text"><![CDATA[堆栈信息的解析 最使用NSSetUncaughtExceptionHandler和signal方法捕获异常，并传到服务器，用来追踪线上app的异常信息捕获到的都是堆栈信息： 如何利用这些堆栈信息查看报错方法名和行数？ 异常信息 异常信息有三种类型 ①已标记错误位置的:信息已经很明确了，不用解析test 0x000000010bfddd8c -[ViewController viewDidLoad] + 8588 ②有模块地址的情况二进制库名（test）调用方法的地址（0x00000001018157dc）模块地址（0x100064000）+偏移地址（24844252） test 0x00000001018157dc 0x100064000 + 24844252 ③无模块地址的情况： test 0x00000001018157dc test + 24844252 dSYM符号表获取 xcode-&gt;window-&gt;organizer-&gt;右键你的应用 show finder-&gt;右键.xcarchive 显示包内容-&gt;dSYMs-&gt;test.app.dYSM atos命令 atos命令来符号化某个特定模块加载地址 $ atos [-arch 架构名] [-o 符号表] [-l 模块地址] [方法地址] 解析 使用终端，进到test.app.dYSM所在目录 ①如果是有模块地址的情况，运行： $ atos -arch arm64 -o test.app.dSYM/Contents/Resources/DWARF/test -l 0x100064000 0x00000001018157dc ②.如果是无模块地址的情况 ❶先将偏移地址转为16进制： 24844252 = 0x17B17DC ❷然后用方法的地址-偏移地址，得到的就是模块地址 0x00000001018157dc - 0x17B17DC = 0x100064000 ❸最后运行 $ atos -arch arm64 -o test.app.dSYM/Contents/Resources/DWARF/test -l 0x100064000 0x00000001018157dc iOS崩溃堆栈符号化http://blog.csdn.net/tencent_bugly/article/details/46275773 http://blog.csdn.net/reylen/article/details/50568440 https://www.cnblogs.com/1oo1/p/4462649.html]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar--基本类型与运算]]></title>
<url>../../../../../../../../2016/11/24/Swift-Grammar/Swift-Grammar-基本类型与运算/</url>
    <content type="text"><![CDATA[基本类型 多出来的是 Tuple*8 和 可选类型** 常量定义 let 常量名 常量名可以死任意文字，文字长度 给常量一个值，叫赋值 形式： let 常量名 = 值 变量 可主动变更或可预期时间内自耦东有规律或无规律的量 c常量和变量的关系 变化才是永恒不变的，无论如何，总有规律可循 变量与常量在一定条件下可以相互转换 常量局势变量的一种 数字类型 Int 在32位机器上是Int32 在64位机器上是Int64 除了Int之外，还有Int，Int8，Int16，Int32，Int64. var yue = 66或var yue: Int = 66 类型可以不写，swift有类型推算功能 UInt 在32位机器上是UInt32 在64位机器上是UInt64. 除了UInt之外，还有UInt8，UInt16，UInt32，UInt64. Double swift 默认 浮点型是 Double（双精度） 64位浮点数 var yue = 3.5或var yue : Double = 3.5 Float 32位浮点数 Swift不支持数字类型之间的自动转换。必须显式手动转换 var i: Int = 2_000 //这个表示2000 var d: Double = 5.3 var e = d * Double(i) 布尔 Bool 表示逻辑上的真假： true、falseSwift和java一样，对boolean类型是强要求的，不能在if里面传一个整形用于判断 不同进制的前缀十进制 没有二进制 0b八进制 0o十六进制 0x科学计数1.25e2 代表 1.25乘上10的2次方0xFp2 代表 15乘上2的2次方typealias 关键字，用来个类型起别名 typealias ii = Int8 var mm = ii.min //这里的ii代表了Int8 元组（Tuple） Tuple:定义变量组合其实就是一群数据组合，可以将其解出来输出注意的是tuple不只是两个元素，你可以自己扩展成多个元素 var x= 1 var y = 2 var z = 3 var 向量 = （1，2，3）print (向量.0 ,向量.1 ,向量.2)var (x,y,z) = (1,2,3)print (x,y,z)// 值前加前缀var 课程 = (day:100,unit:&quot;天&quot;,lanage:&quot;swift&quot;,version:&quot;3.0&quot;);print课程. day) var menu = ("apple", 20) //定义一个Tuple var menu2 = (name: "banana", price:10) //可以在定义的时候指定元素名字 let (name,price) = menu //解Tuple，如果某个元素不想要的话，用 _ 代替 print(name, price) //输出 apple 20 print(menu.0,menu.1) //不解Tuple直接输出 print(menu2.name,menu2.price) //利用元素名字解Tuple 可选类型（Optionals) 当一个方法可以返回一个对象的时候，它有可能返回一个空值比如将字符串转换为数字的方法。为了处理这种情况，有了可选类型。可选类型表示一个数据，它可能有值，也可能为空。基本语法是在类型的后面加上问号 ？ 定义形式 形式: var 变量：类型?,默认无值（nil） var addressStr:String print(addressStr) //这里报错说str没初始化 var addressStr:String?addressStr = &quot;杭州&quot; 但是如果将str改为可选类型，那么这就可以输出 var str:String? print(str) //输出 nil 可选类型转换为对应的类型 –&gt;对可选类型解包强制解包有个注意点，就是如果这个可选类型是nil的话，那么强制解包的语句会在运行时报错 var str:String? = "fe" var s = str! //将str解包为s，但是如果str没有赋值的话，那么这句会在运行时报错 print(s) 解决强制解包的时候，可选类型可能为nil的问题。if语句里面多了一个 Optional Binding 的概念。就是将可选类型解包后判断是否为nil，然后执行不同的分支代码 //因为没给str赋值，所以输出 str为空 var str:String? if let s = str &#123; print("str有值") &#125; else &#123; print("str为空") &#125; 在编程中，我们可以确保可选类型一定不为nil的，那么每次要将可选类型解包都要加个 !，很麻烦。所以有了隐式可选类型，它是用 ! 代替了 ? 号。然后在需要将可选类型转换为对应类型的时候就不用加 ! 了 var str:String! = "string" var s = str 基本运算一些和C完全一样的基本运算 加减乘除，负号，自增（++）自减（–），+=等， 判断大小之类（==，!=，&gt;=…），三元运算符，逻辑运算（!，&amp;&amp;，||） 不一样的运算符取模% 在C中，只能对整形进行运算Swift中可以对浮点数进行运算。结果就是多出来的那部分 比如 7.1%2.5 得到2.1，因为7.1可以最多减去2个2.5，然后剩下2.1 范围运算符 … 和 ..&lt;两个运算符可以用在for里面 //输出 1 2 3 包含最后一个元素3 for i in 1...3 &#123; print(i) &#125; //输出 1 2 不包含最后一个元素3 for i in 1..&lt;3 &#123; print(i) &#125; 单范围运算符 对于下标运算可以这样用 let names = ["Anna", "Alex", "Brian", "Jack"] for name in names[2...] &#123; print(name) &#125; // Brian // Jack for name in names[...2] &#123; print(name) &#125; // Anna // Alex // Brian for name in names[..&lt;2] &#123; print(name) &#125; // Anna // Alex 几元操作符 操作几个对象 ，被称之为几元操作符 一元运算符 操作一个目标，是一元操作符 -6 // 符号 紧跟 6，是一元运算符let b = -a 二元运算符 3 + 4 //两个目标之间，操作2个对象，习惯左右留空格a ?? b它的意思是：如果可选类型a不是nil，那么解包a并返回解包值，如果a为nil，那么返回b相当于 a != nil ? a! : b 赋值操作符 let yue = 3 // 用等号右边的值来更新左边变量的值yue = 5 数学操作符(+ - * /) 类型安全变量（包含let）一旦定义，其类型不可改变，不能给一个变量一个类型不同的值 var 电费 = 3.5点费 = 5 print (电费) 打印：5.0电费 = “五” Error]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS]]></title>
<url>../../../../../../../../2016/11/23/iOS-Garmmar/iOS/</url>
    <content type="text"><![CDATA[iOS多线程的锁]]></content>
      <categories>
        <category>iOS</category>
        <category>Refer</category>
      </categories>
  </entry>
</search>
