<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS-APP-Code上架配置文档]]></title>
<url>../../../../../../../../2017/11/29/iOS_APP_Code_上架配置文档/</url>
    <content type="text"><![CDATA[#第三方服务平台对接 辈出设计登录，分享 ##阿里云(直播类一般需要，不需要跳过) -（https://www.aliyun.com购买一年只要10个月的费用，oss和 slb 是按流量收费，请保证账户有余额）500并发 一月 账号：xxxxx密码：xxxxx ##腾讯云(直播类一般需要，不需要跳过) 腾讯云请使用qq或qq邮箱注册（https://www.qcloud.com账户需充值）差认证账号：xxxxxx密码：xxxxxxSdkAppId ：1314xxxxaccountType ：1314xxxx 短信平台 iOS 只要注意短信可用即可 QQ登录的功能（open.qq.com） 登录的APP ID：xxxxAPP KEY：xxxxx app上的腾讯地图 app上的腾讯地图key信息（HYPERLINK “http://lbs.qq.com/index.html&quot;http://lbs.qq.com/index.html）您的腾讯地图的 key：xxxxx账号：xxxx密码：xxx App新浪微博登 App新浪微博登录信息（ HYPERLINK “http://open.weibo.com/development/mobile“ http://open.weibo.com/development/mobile）App Key： xxxx不要微博APP secret：xxxx账号： xxxx密码： xxxx 微信开放平台 HYPERLINK “https://open.weixin.qq.com/“ https://open.weixin.qq.com/您的微信的APP ID：xxxxxAPP secret：8xxxxx账号：xxx密码：xxxx 开通微信支付(Beichoo暂时不需要) 开通微信支付（直播需要文网文）：用于观众支付（具体操作步骤请参考售后文档-后台需要配置的地方-微信支付文档）并留意和保留相关邮箱，等交付后台后填写到后台的资金管理-支付接口列表-微信支付。 注：最后确认分享到朋友圈、发送给朋友、微信登录和微信支付（直播需要文网文）的接口都已经获得。 app名称和BID app名国内发布APP，名字是中文 在项目info文件里边，把Bundle display name 填写一个中文名字，Localization native development regior 选择中国。如果刚才提到的两个都没有，自己手动添加即可 Bundle identifier 命名规范 命名规范，且具有唯一性，因为在发布时候，描述证书要匹配当前id。一般采用com/cn +公司名+项目名，例如com.jindong.jd注：在申请QQ、微信、地图、微博等第三方所需填写的包名均要与此包名统一，如果不统一就会导致各功能无法正常使用 Version 格式： 1.1.1 最好写3位 Build: 格式： 1 （写整数 1，2，3，4，5即可） Clean 通知全员提交代码 预先跑一边，自测，然后，clean工程，僵尸模式，断点统统清楚 Edit Scheme 必须改为 Release 开发环境 FFConfig.h服务器接口 #define APP_ENVIRONMENT_EDITION 0 0 上线 （不准Mac跑去测，必须打包TestFlight方式） 1 开发 2 测试 3 stage 服务器版本目前0.1版本 #define API_VERSION @&quot;/bc/0.1/&quot; Push Notification 务必打开 平时这个不要关了！！！ Applinks 开启H5跳转App App 信息 iTunesConnect:https://itunesconnect.apple.com/login iTunesConnect点击—&gt;登录 根据运营会给 多套 关键字，副标题，多种语言环境为了在构建版本里，多加几套关键字 构建版本截图 发布时 来传]]></content>
      <categories>
        <category>iOS</category>
        <category>App</category>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git-基本使用]]></title>
<url>../../../../../../../../2017/11/29/Git-基本使用/</url>
    <content type="text"><![CDATA[基本使用初始化仓库 创建普通仓库 $ git init 创建裸仓库，这里面许多git命令不能使用，切换分支都不可用，一般用来当远程仓库 $ git --bare init 别名 使用config alias.命令进行，添加–global参数后可以对全局git的config文件进行配置 $ git config --global alias.st status 一个很吊的配置，让你的git变得更好看，摘自 $ git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 本地的一些命令 配置信息 $ git config user.name &quot;名字&quot; git config user.email &quot;email&quot; branch分支相关命令 $ git branch -a //显示所有分支 git branch 分支名字 //如果该分支不存在，就会新建 git branch --delete 分支名字 //删除分支 add将本目录下的文件都添加到暂缓区，准备提交用 $ git add . commit 提交 $ git commit -m &quot;注释&quot; merge这个命令会将本分支merge别处的分支。 $ git merge merge过来的分支 远程命令 添加远程仓库 $ git remote add &lt;远程主机名&gt; url push，命令格式： &amp; git push 远程主机名 本地分支:远程分支 举个例子下面命令将本地分支a，push到远程主机origin的a_remote上，如果远程主机里面没有a_remote分支，那么就会创建一个这名字的分支。 $ git push origin a:a_remote 注意：如果没有远程分支的名字，那么将会在远程仓库建立一个同名的分支。如果没有本地名字，就像 :a_remote，这就相当于传了一个空的分支给远程， 那么会删除掉远程仓库的这个分支。 pull这个命令会将本地和远程分支进行merge，如果出现冲突，需要自己解决。 命令格式： $ git push 远程主机名 远程分支:本地分支 例子在此，将远程主机的 $ git pull orgin a_remote:a 发生冲突的时候，如果需要丢弃本地工作，那么使用 $ git reset --hard branch相关的远程命令将远程分支和本地分支相关联 git branch --track 本地分支 远程主机/远程分支 //在创建本地分支的时候指定它所关联的远程分支 git branch --set-upstream-to 远程主机/远程分支 //将当前分支关联远程分支 fetch这个命令将远程的分支fetch下来，然后可以将这些fetch下来的分支和本地分支进行合并 git fetch 主机名 git fetch -p 主机名 //fetch完成后，删除本地仍存在，但是远程不存在的分支关联 下面的命令将本地分支绑定远程分支，但好像并没什么用，push的时候如果不输入远程分支名字，那么还是会新建一个和本地分支同名的远程分支。 git branch --set-upstream-to origin/aa_remote stash在进行pull的时候，经常会遇到 error: Your local changes to the following files would be overwritten by merge: xxx/xxx/xxx.java Please, commit your changes or stash them before you can merge. Aborting 这里要么将你当前的工作commit一下，要么就可以使用stash命令。先用stash命令缓存当前工作，然后pull，pull后再用stash pop还原之前的工作 $ git pull ... file foobar not up to date, cannot merge. $ git stash $ git pull $ git stash pop 另外的情况就是：你在工作的时候，突然被老板要求去改别的东西，你也可以用stash把当前的工作缓存起来。改完别的东西后再回来继续工作。 其他 $... hack hack hack ... $ git stash $ edit emergency fix $ git commit -a -m &quot;Fix in a hurry&quot; $ git stash pop # ... continue hacking ... 最后一些坑 1、初始化的仓库要先commit一下才能新建分支 2、如果远程仓库在使用这个分支，那么不能提交到这个分支上去，除非建立bare仓库，但是bare仓库不能使用git命令。]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Classes/Structures类和结构体]]></title>
<url>../../../../../../../../2017/11/29/Swift-Grammar-Classes-Structures类和结构体/</url>
    <content type="text"><![CDATA[类和结构体简叙述 Swift中，类和结构体是很相近的。所有下面类和结构体的实例都统称为实例。不再单独为类的实例称为对象。和C或OC，不同，swift的类只写在一个文件里面。这点和java一样。 类和结构体的共同点： 1、能定义属性用来存储值 2、能定义方法实现功能 3、能定义下标来得到值 4、具有初始化构造器初始化实例 5、能被扩展 6、能实现协议 类比结构体多出来的特点： 1、能被继承 2、能在运行时使用类型转换判断一个实例是否为某个类 3、具有析构器 4、引用计数可以大于1，使得可以有多个引用指向同一个类的实例（注明：结构体是值传递，所有没有引用计数） 下面定义一个类和结构体，这里先提一下，类的每个属性都给了默认值，除了可选类型之外。这个是swift要求的，以后文章会详细讲到。 struct CPU { var clockSpeed = 1.0 var coreNum = 4 } class Telephone { var cpu = CPU() // CPU()是CPU结构体的默认构造器。它生成一个CPU实例，以后构造器的文章详细讲这方面内容 var screenSize = 5.0 var price: Int? }然后定义他们的实例 var myTelephone = Telephone() var newCPU = CPU()注意结构体是值传递，而类是引用传递。下面的代码清楚说明了这个特点。 var myTelephone = Telephone()var newCPU = CPU() print(myTelephone.cpu.clockSpeed) //1.0 swift使用点语法来获得属性 newCPU.clockSpeed = 2.0 myTelephone.cpu = newCPU //给myTelephone一个新的CPU print(myTelephone.cpu.clockSpeed) //2.0 newCPU.clockSpeed = 2.2 print(myTelephone.cpu.clockSpeed) //2.0 赋值后修改newCPU并不影响myTelephone里面的CPU var cpu = myTelephone.cpu //取出一份CPU，但是是值传递 cpu.clockSpeed = 3.0 print(myTelephone.cpu.clockSpeed) //2.0 所以修改取出的cpu不影响myTelephone里面的 var yourTelephone = myTelephone // 定义一个yourTelephone，它指向myTelephone的同一个实例 yourTelephone.screenSize = 6.0 print(myTelephone.screenSize) //6.0 修改yourTelephone会影响myTelephoneArray，String，Dictionary都是值传递。这个和OC是不一样的。值得注意。 结构体自带一个遍历所有属性的构造器，但是类没有。 var cpu2 = CPU(clockSpeed: 3.3, coreNum: 8) 操作符 === 和 !=====用来判断两个变量是否指向同一个类的实例。如果是返回true。 !==反之。指向不同实例，返回true。 而 == 是判断两个实例是否“相等”，这个相等的条件可以有类的定义者自己决定。]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Garmmar-Enumerations枚举类]]></title>
<url>../../../../../../../../2017/11/29/520/</url>
    <content type="text"><![CDATA[枚举类 Swift中的枚举和C中的枚举不一样,枚举类而不是枚举类型,它是值传递在C中，枚举类型中的每一项都整形然而在Swift中，你不必为每一项赋值。定义的时候所用的名字就是用来枚举的。当然也可以为枚举成员赋值，这个赋值不单单是整形，可以是Charater，String，浮点数。 定义一个枚举类型注意首字母已经大写分行或一行，用逗号分隔 enum Nameset&#123;case LuGaygaycase LiaoliaoCase Ykk&#125;或 enum Nameset&#123;case LuGaygay, Liaoliao,Ykk &#125; 定义一个枚举变量var myName = Nameset.Ykk或myName = .Ykk Associated Value 用来给每一个枚举成员再定义一个补充值 品的条形码和二维码。条形码是由一串数字组成的，这个数字分为了4个部分。而二维码其实是用一串很长的字符来编码的。如果要把二位码和条形码封装成为一个枚举类型，为了更好地区别二者，我们可以加上associated value，定义如下 enum Barcode &#123; case UPCA(Int, Int, Int, Int) //条形码 case QRCode(String) //二维码 &#125; 定义Barcode变量，同是添加上associated value var productBarcode = Barcode.UPCA(8, 85909, 51226, 3) productBarcode = .QRCode("ABCDEFGHIJKLMNOP") 注意的一点是，如果你定义了associated value，那么在定义变量的时候就和前面的NameSet不太一样了。看下面的两句代码b1是Barcode类型b2是(String) -&gt; Barcode类型，一个函数类型 var b1 = Barcode.UPCA(8, 85909, 51226, 3) var b2 = Barcode.QRCode ``` &gt;以下戴拿 错误 不能将 Barcode类型是值赋给 (String)-&gt;Barcode.这里就可以看出了，其实Barcode.QRCode(String:)是一个构造函数，这里再次验证了swift中的枚举是一个类```swift b2 = Barcode.QRCode("fef") //error NameSet里面可以直接用.Tom之类来赋值,估计是定义associated value的时候，相当于把该枚举成员从一个值变为了构造方法。 switch语句来处理枚举类 用swift强大的switch语句来处理枚举类，除了一般的枚举成员之外，对于带associated value 的成员，我们还可以得到associated value enum NameSet &#123; //重新定义一个简单的枚举类 case Lucy case otherName(String) &#125; var myName = NameSet.Lucy myName = .otherName("Alexs") switch myName &#123; case .Lucy: print(myName) case .otherName(var inputName): //使用括号解包出associated value print(inputName) //只有这句会打印出 Alexs &#125; 修改一下上面的switch如下打印的是otherName switch myName &#123; case .Lucy: print(myName) case .otherName: print("otherName") case .otherName(var inputName): print(inputName) &#125; //打印的是otherName 里可以看出，switch里面的.otherName和声明枚举变量时候的不同，这里已经是值NameSet的值了。而且上面的Switch也会有警告说最后一个case永远不能执行。括号只是用来解包出associated value，而不是构造方法为了验证这一点，再改改上面代码 var myName = NameSet.Lucy switch myName &#123; case .Lucy(let name): print(name) case .otherName: print("otherName") case .otherName(var inputName): print(inputName) &#125; //打印你会发现这里打印了 ()，因为解包Lucy没有得到值 switch语句，之前说过只有穷尽枚举的时候才不需要default选项。上面的例子中因为把NameSet里面所有可能都枚举了，所以不需要default选项 Raw Value 这个就是对每一项枚举成员绑定一个值，好比是C里面的枚举成员都是一个整形如果需要Raw Value，必须在声明枚举类的时候加上raw value 的类型 enum ASCIIControlCharacter: Character &#123; case Tab = "\t" case LineFeed = "\n" case CarriageReturn = "\r" &#125; 和C有默认的raw value一样，swift的枚举类也有默认的raw value但是不是任何类型的raw value 都有默认值假如你raw value的类型是Character，那么就不存在默认raw value，每个枚举成员的默认值都必须由你自己定义如果类型是Int，那么默认值第一个是0，后面的一项都前一项加1.看下面例子就明白了 enum NameSet: Int&#123; case Lucy //0 case Tom = 3 //3 case Kate //4 case Angle = 66 //66 case Alex //67 &#125; 如果类型是String，那么默认值就是你的枚举成员的名字 enum NameSet: String&#123; case Lucy //Lucy case Tom = "T" //T case Kate //Kate &#125; 如果有raw value，就可以用raw value来定义枚举变量 var myName = NameSet(rawValue: "Lucy") //注意这里返回的是一个可选类型，因为这个构造方法是一个可失败的构造方法。具体看后面的类构造的文章。 print(myName!.rawValue) //这里我就没用if做判断了，直接强制解包 递归enum就是在enum的枚举成员的associated value声明为本枚举类,然后使用递归函数。在声明associated value为自己枚举类的时候，需要加上indirect关键字。这个关键字可以加在每个case的前面，也可以加在enum的前面。后一种方法对里面所有的case都起效。但是并不要求所有case都有本枚举类作为associated value indirect enum ArithmeticExpression &#123; //使用第二种indirect。定义了一个数学表达式。 case Number(Int) case Addition(ArithmeticExpression, ArithmeticExpression) case Multiplication(ArithmeticExpression, ArithmeticExpression) &#125; func evaluate(expression: ArithmeticExpression) -&gt; Int &#123; //这个函数运算表达式 switch expression &#123; case .Number(let value): return value case .Addition(let left, let right): return evaluate(left) + evaluate(right) case .Multiplication(let left, let right): return evaluate(left) * evaluate(right) &#125; &#125; // evaluate (5 + 4) * 2 let five = ArithmeticExpression.Number(5) let four = ArithmeticExpression.Number(4) let sum = ArithmeticExpression.Addition(five, four) let product = ArithmeticExpression.Multiplication(sum, ArithmeticExpression.Number(2)) print(evaluate(product)) // prints "18"]]></content>
      <categories>
        <category>iOS</category>
        <category>Enumerations</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Closures闭包]]></title>
<url>../../../../../../../../2017/11/27/Swift-Grammar-Closures闭包/</url>
    <content type="text"><![CDATA[闭包 闭包可以看做是匿名的函数 回想一下函数作为参数的情况定义一个函数，它最后的参数是一个函数类型 func doMath(first: Int, second: Int, mathFunc: (Int, Int) -&gt; Int) &#123; print("mathFunc =",mathFunc(first,second))&#125; 定义一个函数，它有两个整形参数，并有一个整形返回值 func add(first: Int, _ second: Int) -&gt; Int&#123; return first + second 调用第一个函数，将第二个函数作为参数传入 doMath(1, second: 3, mathFunc: add) 打印 mathFunc = 4 如果我们想用doMath实现两个数相减的方法，那么必须再写定义一个sub函数，然后将其作为参数传入。这样在功能多了之后会显得很麻烦，一堆函数，而所以有了闭包这个概念 闭包的语法&#123; (参数列表) -&gt; 返回类型 in //闭包体&#125; 有了闭包，我们可以将上面的代码改为 定义一个函数，它最后的参数是一个函数类型 func doMath(f:Int,s:Int,mathFunc:(Int,Int)-&gt;)&#123; print("mathFunc = ",mathunc(first,second)) &#125; 调用 doMath(1, second: 3, mathFunc: &#123;(f: Int, s: Int) -&gt; Int in return f + s&#125;) 还是很麻烦是吧？ 别忘了 Swift有类型推断功能，所以我们可以继续简化上面的闭包部分代码 doMath(1, second: 3, mathFunc: &#123;f, s in return f + s&#125;) 对应只有一行代码的闭包，return关键字还可以省略 doMath(1, second: 3, mathFunc: &#123;f, s in f + s &#125;) 此外，闭包对参数提供了默认名字，依次为 $0,$1,$2….所以上面的闭包仍可以简化 doMath(1, second: 3, mathFunc: &#123;$0 + $1 &#125;) 对于闭包在参数列表最后一项的情况，可以将闭包写到小括号外部，并且可以省略掉外部参数名 doMath(1, second: 3)&#123; var f = $0 + 1 return f + $1&#125; Autoclosures 姑且叫自动打包吧。用大括号括起来就好，编译器自动判断这个大括号里面的是什么返回类型。但是有时候不准确，需要自己写。下面是这个概念的解释，其实也是一种定义闭包变量的方法 var t = &#123; return 1&#125;print(t()) 定义了一个Void-&gt;Void类型的闭包。因为没有参数，所以可以省略参数列表和in关键字。如果有参数的话，就不能省略in关键字。 var b: Void-&gt;Int = &#123; //定义了一个类型为 Void-&gt;Int的闭包 var i = 1 i++ print(i) return i&#125; 因为闭包其实就是函数，调用这个闭包就和调用函数一样。但是有区别的就是闭包都是没有外部外部参数名，调用的时候不要把内部参数名但做外部参数名使用。 有时候函数需要传递一个闭包的时候，可以在调用的时候使用大括号将一段代码生成为闭包 var b: Void-&gt;Int = &#123; var i = 1 return i&#125;func doClosures(c: Void-&gt;Void) &#123; c()&#125;doClosures(&#123;b()&#125;) //虽然b是一个Void-&gt;Int的闭包，但是其调用再封装之后变为了Void-&gt;Void的闭包doClosures(&#123; var i = 3 i++ print(i)&#125;) 此外，可以在函数参数列表里面使用@autoclosure关键字，这样就不用使用大括号封装了。但是对于多句的代码情况不行（上面的第二种），有时候自动封装也会出错，比如用上面的第一种情况，它把b()看做了Int，然后报错。需要将返回类型重新定义一下 var b: Void-&gt;Void = &#123; var i = 1 i++ print(i)// return i&#125;func doClosures(@autoclosure c: Void-&gt;Void) &#123; //或者不改b的类型，将这里的c的类型改为 Void-&gt;Int也可以 c()&#125;doClosures(b()) 如果想要自动封装的闭包可以在doClosures函数的作用域以外使用，那么加上escaping关键字。这个关键字只能用在@autoclosure后面 var b: Void-&gt;Void = &#123; var i = 1 i++ print(i)&#125;var t: (Void-&gt;Void)?func doClosures(@autoclosure(escaping) c: Void-&gt;Void) &#123; c() t = c //将自动封装的c赋值给外部变量t&#125;doClosures(b())t!() 闭包的值捕获在生成一个闭包的时候，闭包会将它用到的参数和变量都保存一份。提醒一下，其实闭包就是函数 func giveMeFunc2(step: Int) -&gt; (Void -&gt; Int)? &#123; var total = 0 func add() -&gt; Int &#123; total += step; return total &#125; return add&#125; 上面的函数里面生成了嵌套函数，通过输入不同的符号，返回不同的函数。这里有两个变量需要注意，一个是total，一个是step。当生成嵌套函数的时候，嵌套函数会将这两个变量都copy一份，然后保存起来。下面是对上面代码的一个使用 上面的函数里面生成了嵌套函数，通过输入不同的符号，返回不同的函数。这里有两个变量需要注意，一个是total，一个是step。当生成嵌套函数的时候，嵌套函数会将这两个变量都copy一份，然后保存起来。下面是对上面代码的一个使用 可以看到，f1和f2的total和step是不会相互干涉的。 再来看看这个值捕获的时间，看下面代码。这里可以看到，值捕获是发生在返回之前。这个和OC的block是一样的 func giveMeFunc2(step: Int) -&gt; (Void -&gt; Int)? &#123; var total = 0 func add() -&gt; Int &#123; total += step; return total &#125; print("before +100",add()) // total = 0 total += 100 print("after +100",add()) // total = 100 return add&#125;var f1 = giveMeFunc2(1)! //得到一个函数，它会将传入的参数累加，并且每次调用都会加上一次stepprint("f1=",f1()) // 103print("f1=",f1()) // 104 看到这里，可能大家会以为这个值捕获和OC的block差不多，但是其实差远了。这个值捕获的时间很有区别。这里明显的一点就是我们在函数内部改变外部变量total的时候，没有加任何修饰符，OC里面必须加上__block，要么就是对全局变量进行修改。 我们先看一段OC代码 int t =1;int(^b)() = ^() &#123; return t; &#125;;t = 3;NSLog(@"%d",b()); //输出1，理由就不多说了。假如我们把t改为__block。那么将会输出3。改为static同样的效果。__block int t =1;int(^b)() = ^() &#123; return t; &#125;;t = 3;NSLog(@"%d",b()); //3 来看OC和swift中两段很类似的代码 //OCtypedef int(^BLOCK)(void);BLOCK OCFunc (int step) &#123; __block int total = 0; BLOCK b = ^() &#123; total +=step; return total; &#125;; step = 100; NSLog(@&quot;before +100,%d&quot;,b()); //1 total +=100; NSLog(@&quot;after +100,%d&quot;,b()); //102 return b;&#125;//在main方法里面调用BLOCK b = OCFunc(1);NSLog(@&quot;%d&quot;,b()); // 103NSLog(@&quot;%d&quot;,b()); // 104 func swiftFunc(var step: Int) -&gt; Void -&gt; Int&#123; var total = 0 let b: Void -&gt; Int = &#123; Void in total += step; return total &#125; step = 100; print("before +100,",b()) // 100 total+=100 // total = 200 print("after +100,",b()) //300 return b&#125;let d = swiftFunc(1)print("d=",d()) //400print("d=",d()) //500 这里可以看到，OC中的step在block定义的时候就绑定了，后面在更改step的值也不影响block。但是在swift中，step仍然是可以改变的，直到step离开作用域后，闭包才将其捕获。 如果要OC中产生同样的效果，只需定义一个block变量，如下。可以这么看，Swift中的变量默认都是block的 //OCtypedef int(^BLOCK)(void);BLOCK OCFunc (int step) &#123; __block int total = 0; __block int step2 = step; BLOCK b = ^() &#123; total +=step2; return total; &#125;; step2 = 100; NSLog(@"before +100,%d",b()); //100 total +=100; NSLog(@"after +100,%d",b()); //300 return b;&#125;//在main方法里面调用BLOCK b = OCFunc(1);NSLog(@"%d",b()); //400NSLog(@"%d",b()); //500 这个值捕获和OC的block一样，也会产生循环引用问题。OC里面是使用__weak来解决，这里差不多，它可以在参数列表前面加上捕获列表，并且对捕获类别的参数进行权限控制，附上一个官方例子，以后写ARC的时候详细讲 lazy var someClosure: (Int, String) -&gt; String = &#123; [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in // closure body goes here&#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FF-Beichoo-有读1.1.0版本问题]]></title>
<url>../../../../../../../../2017/11/27/FF-Beichoo-有读1.1.0版本问题/</url>
    <content type="text"><![CDATA[问题如下 个人中心数据加载 版本判断问题 轻读页卡顿 TabBarC样式撤换 首页推荐-猜你喜欢 个人中心数据加载 上拉加载更多，一直加载/加载白页 1.AFN限制15秒 sessionManager.requestSerializer.timeoutInterval = 15;2.缓存，从缓存里取数据，应该也要让刷新状态结束 refresh直接end 是否对新的数据请求有影响（不确定）3.scrovlview滑动影响，控制子viewC里的tabelview的滑动 2.版本判断问题 1.AppDelegate里 后台控制 1 == 后台控制 0 == 依赖Appstore 获取版本号2、苹果下发 可能是上个版本版本号 测试 版本Bug 步骤 1.后台字段 修改force_update = 1 – 依赖后台控制版本 2.App版本号修改为1.1.1(最新，高版本) (结果：不提示) 3.App版本号修改为 小于1.1.1(低版本) （结果提示更新） 4.后台字段 修改force_update = 0 – 不依赖后台控制版本 5.App版本号修改为1.1.1(最新，高版本) (结果：不提示) 6.App版本号修改为 小于1.1.1(低版本) （结果： 提示更新） 版本控制基本配置@discussion: 后台决定依赖 后台控制还是appstore 版本号来控制 - (void)show_configurationLaunchUserOption&#123; FFNetWorkTool *api = [FFNetWorkTool api]; api.config.isSign = NO; [api httpPost:@&quot;special/launch&quot; parameters:nil success:^(NSDictionary *dic) &#123; [self analyzeResponse:dic];&#125; failure:^(NSError *error) &#123;&#125;];&#125; 版本控制 数据解析@brief: 只有当 app_version = 1 才能 轻质跟新 -(void)analyzeResponse:(id)dic&#123; if ([[dic allKeys] containsObject:@&quot;code&quot;]) &#123; if ([dic[@&quot;code&quot;] integerValue] == 0 &amp;&amp; [[dic allKeys] containsObject:@&quot;data&quot;] &amp;&amp; [[dic[@&quot;data&quot;] allKeys] containsObject:@&quot;app_version&quot;] &amp;&amp; [[dic[@&quot;data&quot;] allKeys] containsObject:@&quot;force_update&quot;] &amp;&amp; [dic[@&quot;data&quot;][@&quot;force_update&quot;]integerValue] == 1 &amp;&amp; dic[@&quot;data&quot;][@&quot;app_version&quot;] ) &#123; [self checkVersionDic:@&#123;@&quot;version&quot;:dic[@&quot;data&quot;][@&quot;app_version&quot;]&#125;]; return; &#125;&#125;//app store 版本去控制[self appVersonUpdate];&#125; Appstore 方式控制版本更新 入口） - (void)appVersonUpdate&#123;//定义app地址 NSString *urld = [NSString stringWithFormat:@"http://itunes.apple.com/lookup?id=%d",1282222817]; NSURL *url = [NSURL URLWithString:urld]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:10]; [request setHTTPMethod:@"POST"]; NSOperationQueue *queue = [NSOperationQueue new]; [NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *error)&#123; NSMutableDictionary *receiveStatusDic=[[NSMutableDictionary alloc]init]; if (data) &#123; NSDictionary *receiveDic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil]; if ([[receiveDic valueForKey:@"resultCount"] intValue]&gt;0) &#123; [receiveStatusDic setValue:@"1" forKey:@"status"]; [receiveStatusDic setValue:[[[receiveDic valueForKey:@"results"] objectAtIndex:0] valueForKey:@"version"] forKey:@"version"]; &#125;else&#123; [receiveStatusDic setValue:@"-1" forKey:@"status"]; &#125; &#125;else&#123; [receiveStatusDic setValue:@"-1" forKey:@"status"]; &#125; [self performSelectorOnMainThread:@selector(receiveData:) withObject:receiveStatusDic waitUntilDone:NO];&#125;]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSMutableDictionary *receiveStatusDic = @&#123;&#125;.mutableCopy; if (data) &#123; NSDictionary *receiveDic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil]; if ([[receiveDic valueForKey:@"resultCount"] intValue] &gt; 0) &#123; [receiveStatusDic setObject:@"1" forKey:@"status"]; [receiveStatusDic setObject:[[[receiveDic valueForKey:@"results"] objectAtIndex:0] valueForKey:@"version"] forKey:@"version"]; [self performSelectorOnMainThread:@selector(receiveData:) withObject:receiveStatusDic waitUntilDone:NO]; &#125;else&#123; [receiveStatusDic setValue:@"1" forKey:@"status"]; &#125; &#125;else&#123; [receiveStatusDic setValue:@"-1" forKey:@"status"]; &#125; &#125;]; [task resume]; &#125; 获取APP自身版本号@discussion: 版本号 去电 点，然后扩展成为3位数，不足3位末尾加0 -(void)receiveData:(id)sender&#123;]//拿到App 线上 版本号 NSInteger newVersionInt; if([[sender allKeys] containsObject:@"version"]) &#123; NSString *newVersionStr = [sender[@"version"] stringByReplacingOccurrencesOfString:@"." withString:@""]; if ([newVersionStr length] == 1) &#123; newVersionStr = [NSString stringWithFormat:@"%@%@",newVersionStr,@"00"]; &#125; if([newVersionStr length] == 2) &#123; newVersionStr = [NSString stringWithFormat:@"%@%@",newVersionStr,@"0"]; &#125; newVersionInt =[newVersionStr integerValue]; &#125;else&#123; return; &#125; NSLog(@" 本地： %ld 线上 %ld",(long)localVersionInt,(long)newVersionInt); if (localVersionInt&lt; newVersionInt) &#123; [self updateVersion]; &#125;else&#123; return; &#125; &#125; 轻读页卡顿 简单检测，线上版本需要关闭 [self check_pingObserver]; TabBarC样式撤换 撤换地上那方点击，略微弹动动画 首页推荐-猜你喜欢 换一换，偏移量修改 轻读上拉数据偶尔没有 移动端暂未找到原因，后台报userid问题数据偶尔没有 目前测的结果，后台可能已经解决]]></content>
      <categories>
        <category>FF</category>
        <category>Beichoo</category>
        <category>有读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Garmmar-Function函数]]></title>
<url>../../../../../../../../2017/11/24/Swift-Garmmar-Function函数/</url>
    <content type="text"><![CDATA[函数定义 Swift的函数和C的函数定义方式有区别，Swift将返回类型写在函数的最后 func函数名 (参数列表) -&gt; 返回值 &#123; //函数体&#125; 函数输入一个字符串，然后打印出这个字符串，并且返回一个字符串 //函数定义func printYourName (name: String)-&gt;String &#123; print(name) return "Hello, " + name&#125;var s = printYourName(name: "Tom") //函数调用print(s) //打印 Hello, Tom 一个函数没有返回值，那么从 -&gt; 返回值 这个部分可以省略 //函数定义func printYourName (name: String) &#123; print(name)&#125; 有多个参数 func printTwoString(firstString: String, secondString: String) &#123; print(firstString,secondString)&#125;printTwoString(firstString: "hello", secondString: "Kate") Function Argument Labels and Parameter Names 在函数定义时候，参数列表中使用的fristString和secondString称为参数(Parameter).但是参数包含了两个东西 1是Argument Label，它是在方法调用的时候写在参数值前面的参数标记，比如下面调用中的firstString和secondString printTwoString(firstString: "hello", secondString: "Kate") 2是Parameter Names，它只的是在方法体里面使用到的参数标志 printTwoString方法体里面print种使用到的firstString,secondString 默认情况下，Argument Label和Parameter Names是一样的。但是你也可以自定义Argument Label，方法是在Parameter Names前面加上另外一个字符串，并用空格相隔，如下，begin是自定义的Argument Label，然后调用的时候就需要使用begin来指定参数 func printTwoString(begin firstString: String, secondString: String) &#123; print(firstString,secondString)&#125;printTwoString(begin: "hello", secondString: "Kate") 使用print的时候没有加上任何的Argument Label。如果你不想要Argument Label，那么在定义方法的时候，将Argument Label的字符串写为下划线 _ func printTwoString(firstString: String, _ secondString: String) &#123; print(firstString,secondString)&#125;printTwoString(firstString: "hello", "Kate") //忽略了第二参数的外部参数名之后，这里就不能加上外部参数名了 参数默认值 可以给参数赋值默认值。具有默认值的参数，在调用的时候，可以不用给它赋值。好比print方法，它的原型是 print(_:separator:terminator:) 但是一般使用的时候都只传了一个字符串，原因就在于它后面的两个参数都是具有默认值的。给参数设置默认值的方法是在方法定义的时候，在参数的后面用 = 加上默认值。如下代码。官方文档建议我们把带默认值的参数放在参数列表的末尾，这样在调用的时候不至于混淆。但是其实可以对每个参数都赋值默认值。比如下面的例子 func printTwoString(firstString: String = "hello", secondString: String = "Lucy", thirdString: String = "end") &#123; print(firstString,secondString,thirdString)&#125;printTwoString( secondString:"two") //使用外部参数名指定要赋值的参数，其他参数使用默认值，输出 hello two end 值得注意的是，如果没有默认值的参数在调用的时候也没有给其赋值，那么会在编译的时候报错。如果你又把参数列表的Argument Label都去掉的话，那么在调用的时候，你给的参数将会从头开始匹配。如果参数类型不匹配的话，就会报错。当然，不建议大家这样做，因为会导致程序的可读性变差 可变参数列表func printStrings(strings: String...) &#123; print(strings)&#125;printStrings("1","2","3") //输出 ["1", "2", "3"] 通过输出我们可以看到，可变参数在函数体内是以数组的类型存在的。这点在官方文档上有说明 In-Out 参数 在默认的情况下，参数传递给方法后都是常量，也就是说不能在函数体里面对参数进行修改。这个常量是个形参，不是之前的实参 func add(first: Int, _ second: Int) -&gt; Int&#123; first = 2 //这句报错 return first + second&#125; 有一种情况，我们希望在方法里面改变实参的值，所以有了inout关键字，这个关键字不能对可变参数添加，同时加上了这个keyword之后，不能再添加 var let，也不能有默认值。然后调用的时候，这个参数必须传递一个变量，而不能是常量，并且在变量前加&amp; func add(first: inout Int, _ second: Int) -&gt; Int&#123; first = 2 return first + second&#125;var a = 1print("result = \(add(first: &amp;a, 3)), a = \(a) " )//输出 result = 5, a = 2 关于In-Out，这个实现原理是先将实参copy，然后在方法体内处理，方法结束的时候，再把copy覆盖回原来的实参。所以如果你在方法体里面去改变实参（通过某些方法获得），那么在方法结束的时候，你对实参的改变会被形参覆盖。建议不要在方法体里面操作InOut参数的实参。 关于InOut参数的捕获问题请参见官方文档 函数类型 函数也是一种类型。函数类型由函数定义决定 func add(first: inout Int, _ second: Int) -&gt; Int&#123; first = 2; return first + second&#125; 它的函数类型为 (inout Int, Int) -&gt; Int如果没有参数也没有返回值的函数，函数类型为 () -&gt; void，也可以写为 () -&gt; ()函数类型可以和基本类型一样，用来定义变量。继续利用上面定义的add函数 var mathFunc : (inout Int, Int) -&gt; Int = addvar f = 1;var s = 2;let result = mathFunc(&amp;f,s) //使用函数类型 函数类型可以用做参数或返回值，利用上面定义的mathFunc变量，可以有 func add(first: inout Int, _ second: Int) -&gt; Int&#123; first = 2; return first + second&#125;var mathFunc : (inout Int, Int) -&gt; Int = addfunc doMath(mathFunc: (inout Int, Int) -&gt; Int, first: inout Int, second: Int) &#123; print("mathFunc = \(mathFunc(&amp;first,second))") print("first = \(first)")&#125;var f = 1;var s = 2;doMath(mathFunc: mathFunc, first: &amp;f, second: 2)print("f = \(f)")//输出//mathFunc = 4//first=2//f=2 嵌套函数 在函数里面再定义函数。这个嵌套函数可以在函数内部调用，也可以作为返回值返回，使得它可以在其他范围内进行使用。例子如下//定义了add 和 sub 两个嵌套函数，然后用于返回。如果输入的不是”+“或”-“，那么返回一个nil。注意giveMeFunc返回的是一个函数类型的可选类型 func giveMeFunc(opt: Character) -&gt; ((Int, Int) -&gt; Int)? &#123; var method : ((Int, Int) -&gt; Int)? switch opt &#123; case "+" : func add(one: Int, _ two: Int) -&gt; Int &#123; return one + two &#125; method = add case "-" : func sub(one: Int, _ two: Int) -&gt; Int &#123; return one - two &#125; method = sub default : method = nil &#125; return method&#125;if let m = giveMeFunc(opt:"-") &#123; print(m(1, 2)) // 打印 -1, 留意一下，这里没有Argument Label。&#125; 操作符方法（Operator Methods） swift和C++一样，可以定义操作符函数。操作符指的是+，-，/，%，+=等等。一般我们这些操作符是给数字类型使用的。但是有了操作符函数之后，我们可以自定义这类符号的运算规则。下面是官方的示例 struct Vector2D &#123; var x = 0.0, y = 0.0&#125;extension Vector2D &#123; static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x, y: left.y + right.y) &#125;&#125; 上面的例子定义了一个操作符函数 + ，这个操作符函数的参数列表里面有两个参数left和right。分别代表着+号左右两边的两个参数。通过这个函数，我们可以直接将两个Vector示例进行相加。如下： let vector = Vector2D(x: 3.0, y: 1.0)let anotherVector = Vector2D(x: 2.0, y: 4.0)let combinedVector = vector + anotherVector// combinedVector is a Vector2D instance with values of (5.0, 5.0) 除了这种要接受两个参数的操作符之外，还要一些只有一个参数的操作符，比如 -，++，–等等。但是这类操作符有两类：前缀（Prefix）和后缀（Postfix），比如–a，i++；这类操作符的定义要加上prefix或postfix关键字。语法如下 extension Vector2D &#123; static prefix func - (vector: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: -vector.x, y: -vector.y) &#125;&#125; 上面定义了一个前缀的 - 操作符函数。用来将一个向量取反。后置操作符的关键字是postfix，中间操作符的关键字是infix 另外还有一种计算并赋值的操作符，比如++，+=等等。这类的操作符会对其中的一个操作对象进行操作后的赋值。所以必须将参数设置为inout extension Vector2D &#123; static func += (left: inout Vector2D, right: Vector2D) &#123; left = left + right &#125;&#125; 除了Swift已经定义的操作符之外，还可以自己定义操作符。比如下面定义了一个+++操作符 prefix operator +++ 上面的只是定义，我们还需要实现这个操作符所做的 extension Vector2D &#123; static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D &#123; vector += vector return vector &#125;&#125; 但是这个自定义的操作符有一些规定。自定义的操作符可以由/, =, -, +, !, *, %, &lt;, &gt;, &amp;, |, ^, ?,~，和某些Unicode 字符开始，至于是哪些字符可以参考官网。点击网页，在网页最下面在这些字符之后，可以接上unicode字符。另外有一些禁止的规定：1.不能重写一个单单的 ? 号。（可以在字符里面加入?号）2.不能重写这些操作符 =, -&gt;, //, /, /, ., 但是可以重写两个或更多个点的操作符。 不能以这些字符开头 ?, &lt;， &amp;4.不能以这些字符结尾 ?， &gt;， ! 在定义的操作符的时候末尾的那对大括号是有用的。在数学上，加减乘除是有优先级和结合规则的。同样的，这里的操作符也是。我们可以在定义操作符的大括号里面定义这个操作符的优先级和结合规律 infix operator +-: AdditionPrecedenceextension Vector2D &#123; static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x, y: left.y - right.y) &#125;&#125; 上面例子定义的是一个中间的操作符，它的结合规则是向左结合。优先级是AdditionPrecedence组，这个参考下面的Precedence Group Declaration链接。前置操作符和后置操作符不能指定优先级，它们作用在同一个操作数，那么先执行后置操作符。 wen]]></content>
      <categories>
        <category>Swift</category>
        <category>Garmmar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Garmmar-流程控制语句]]></title>
<url>../../../../../../../../2017/11/24/Swift-Garmmar-流程控制语句/</url>
    <content type="text"><![CDATA[if else语句 if语句if语句和其他语言中的使用是一样的，只是语法稍有不同首先,是不用括号其次,是即使是if后面只有一条语句，也必须加上大括号 var array1 = ["a","b","c"]if array1.count &gt; 1 &#123; print("array1 is not empty") //这句会打印出来&#125; else &#123; print("array1 is empty")&#125; f语句可以用来检测可选类型是否为空 var str : String?if let s = str &#123; print("str is not nil")&#125; else &#123; print("str is nil") //这句会打印&#125; for 语句 已经移除 for var index = 0; index &lt; 3; index++ &#123; //已经移除 print(index)&#125; for-in 语句 尤其是用来遍历集合 for index in 1...3 &#123; print(index)&#125; 上面的只能是每次加1，但是现在可能有需求每次增加的不是1，所以现在有了这个 for tickMark in stride(from: 0, to: 60, by: 5) &#123; print(tickMark) // 打印 (0, 5, 10, 15 ... 45, 50, 55)&#125; while语句和 repeat-while语句 把括号去掉就行了 var index = 3while index &gt; 0 &#123; index-- print(index)&#125;index = 3repeat &#123; index-- print(index)&#125; while index &gt; 0 Break和continue这个用法和C差不多Switch语句 Swift里面的Switch语句不仅可以判断整形，而且还可以判断各种类型。注意的是执行了一个case后是不会继续往下面执行的，也就是不用添加break语句。相反如果你想要继续往下执行，你必须在这个case最后加上Fallthrough。另外就是default，对于不是枚举类型的变量，defalut必须加上。枚举类型的变量在完全枚举的时候才可以省略default var str = "a"switch str &#123; case "a": print("a") //这句会打印 fallthrough case "b": print("b") //这句会打印 case "c": print("c") //不会打印 default: print("nil") //不会打印&#125; switch里面一个case可以对应多个选项，每个选项之间用逗号分开。这个用法是用来实现c里面的某个选项里面没有执行代码的情况。Swift不允许某个选项里面没有可执行的代码 var str = "s"switch str &#123;case "a","s": print("a") //只打印这句default: print("nil")&#125; case里面也可以是一个范围，在每个case之间的范围有重叠的话，只会匹配第一个 var i = 2switch i &#123;case 1...10: print("1-10") //只打印这句case 9..&lt;20: print("10-20") //因为匹配了第一句，所以这句不会再匹配default: print("other")&#125; 对Tuple 的匹配你可以匹配Tuple的两个值，也可以只匹配一个值，还可以匹配范围 //下面case的条件都是可以匹配的，把前面的case注释掉的话就会匹配下一个case。var tuple = (2,1)switch tuple &#123;case (2,1): print("(2,1)") //因为自动添加break的机制，所以不会往下走case (let x,1): //可以用变量来自由化其中一个值，只需要另外一个值匹配了，就会匹配这个。如果你不关注x的值，你也可以把x换为_ print("x = \(x)")case (-1...3,0...4): print("(-1~3,0~4)")default : print("other")&#125; Where语句在switch中 where可以用来进一步对case添加约束 var tuple = (2,1)switch tuple &#123;case var (x,y) where x == y: //这里用var 和 let 区别在于能不能在case里面修改解包的x，y值。但是即使修改也不会影响原来的tuple print("x == y")case let (_,x) where x == 4: print("x == 4")case var (x,y) where x != y: //匹配了这个case print("x != y") //打印 x != y x = 1 print(x) //打印 1default : print("other")&#125;print(tuple) //打印 （2，1） Labeled Statements 这个labeled statements就像goto语句，但是跳转比较有限，只能用于循环里面。虽然switch也可以加上去，但是并没有用 var tuple = (2,1)second:for _ in 0... &#123; frist : switch tuple &#123; //这个first并没有什么用 case var (x,y) where x == y: //这里用var 和 let 区别在于能不能在case里面修改解包的x，y值。但是即使修改也不会影响原来的tuple print("x == y") break second case var (x,y) where x != y: //匹配了这个case print("x != y") //打印 x != y tuple = (1,1) continue second default : print("other") &#125;&#125;//上面的for循环依次打印了 x != y x == y//注意下面的second，虽然前面也定义了，但是不会冲突。循环内的跳转只能针对循环second:repeat &#123; //对于while也是可以用。 frist : switch tuple &#123; //这个first并没有什么用 case var (x,y) where x == y: //这里用var 和 let 区别在于能不能在case里面修改解包的x，y值。但是即使修改也不会影响原来的tuple print("x == y") break second case var (x,y) where x != y: //匹配了这个case print("x != y") //打印 x != y tuple = (1,1) continue second default : print("other") &#125;&#125; while true//while循环只打印了 x == y，因为Tuple已经被修改为(1,1) Assertion和Preconditionassert(_:_:file:line:) 判断一个情况是否为true，不为true直接停止程序 assertionFailure(_:file:line:) Swift现在多了一个Preconditions，区别文档上说的是开发时候用Assertions，生产用Preconditions。(Assertions help you find mistakes and incorrect assumptions during development, and preconditions help you detect issues in production. ) precondition(_:_:file:line:) preconditionFailure(_:file:line:) 文档上有两段话： If you compile in unchecked mode (-Ounchecked), preconditions are not checked. The compiler assumes that preconditions are always true, and it optimizes your code accordingly. However, the fatalError(:file:line:) function always halts execution, regardless of optimization settings.You can use the fatalError(:file:line:) function during prototyping and early development to create stubs for functionality that hasn’t been implemented yet, by writing fatalError(“Unimplemented”) as the stub implementation. Because fatal errors are never optimized out, unlike assertions or preconditions, you can be sure that execution always halts if it encounters a stub implementation.但是没找到这个-Ounchecked模式，到时有一个选项是disable_safty_checks。这个选项的关闭和Swift_OPTIMIZATION_LEVEL的模式有关系。如果你选择的是 -Onone，那么不管disable_safty_checks的值，都会检测precondition和assert。但是如果开启了优化，那么assert就再不检测，而precondition就会根据是否关闭安全检测来执行 guard语句 这个和assertions差不多，都是用来做判断的，不过这个要自己加上处理。用来在条件不满足的情况下跳出方法或循环 var i = 1while true &#123; guard i &gt; 1 else &#123; print("i &lt;= 1") break //else里面必须加上break或return &#125;&#125; available 用来判断是否可以使用某个版本API if #available (iOS 8, OSX 10.10, *) &#123; //括号里面表示的是最低的版本。这个*必须有，代表其他平台&#125; else &#123;&#125;]]></content>
      <categories>
        <category>permalink</category>
        <category>Garmmar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-集合类型]]></title>
<url>../../../../../../../../2017/11/24/Swift-Grammar-集合类型/</url>
    <content type="text"><![CDATA[集合类型 集合类分为array、dictionary、set每个集合都有一个isEmpty属性来判断这个集合是否为空 Array 创建array的四种方法 var array1 = ["a","b","c"] //包含 a b c 三个字符串var array2 = Array&lt;Int&gt;() //空array，这里一定要指明元素类型var array3 = [String]() //空arrayvar array4 = Array(repeating:2.4, count:3) //包含3个double变量，值都为1.3var array5 = [Double](repeating:2.4, count:3) //包含3个double变量，值都为1.3 获取array的某个元素,直接用下标 var value = array1[9] 清空数组 array1.removeAll()array1 = []; 清空某个元素 remove(at:) 清空某个范围的元素 array.removeSubrange(1..&lt;arr.endIndex)// 这里会移除从1开始，但是不包括end的元素，但是endIndex是指向最后一个元素的后一个元素的，所以会从index为1的元素开始，删除后面全部。array[1...2] = [] //这里将范围1-2的元素都清空了,注意一点，如果数组越界的话，会产生运行时错误 向array添加元素 //使用append()方法array1.append("A") //向array1的末尾添加一个 A，现在只有一个 A 元素//使用运算符号array3 += ["d","e"] //array3从空数组变为包含 d e 两个字符串var array5 = array1 + array3 + ["last"] //array5包含 A d e last, 4个元素//使用insert方法array5.insert("first", at: 0) //array5包含 first A d e last, 5个元素 改变array元素 array5[0] = "newBe"array5[1...3] = ["1","2","3"] 遍历数组for item in array5 &#123; print(item)&#125;for (index,item) in array5.enumerated() &#123; print(index,item)&#125; Set Set 创建set里面的元素都必须实现hashable。因为区分set里面的元素的根本就是判断两个元素的hash值是否相等。swift基本类型都实现了hashable var emptySet = Set&lt;Character&gt;() //建立一个空set，必须指明内容的类型var nameSet : Set&lt;String&gt; = ["Tom","Lucy","Aaron"] //使用初始数据建立set 移除Set removeAll()，这个方法还可以传一个boolean参数，表示是否保持空间，传ture的话表示保持 移除一个元素有两种办法 var index = nameSet.index(of:"Tom")nameSet.remove(at:index!) //因为indexOf返回的是可选类型，所以这里要解包nameSet.remove("Tom") //这种和上面的是等价的 遍历Set for name in nameSet.sorted() &#123; //这里的sorted()可以不用，这里用来排序 print(name)&#125; 包含某个元素 Set和Array都有一个contains方法来判断 Set操作包括了求交集，并集，“减集”，“异或集”官方代码 let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]oddDigits.union(evenDigits).sort()// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]oddDigits.intersection(evenDigits).sort()// []oddDigits.subtracting(singleDigitPrimeNumbers).sort()// [1, 9]oddDigits.symmetricDifference(singleDigitPrimeNumbers).sort()// [1, 2, 9] Set关系 isSubset(of:) 判断一个set是否为另外一个set的子setisSuperset(of:) 判断一个set是否为另外一个set的父setisStrictSubset(of:) 和 isStrictSuperset(of:) 意思和上面的一样，只是这两个方法不能存在相等的情况。isDisjoint(with:) 判断两个set是否没有共同元素，没有的话返回true Dictionary 创建Dictionar var dict1 : [String:Int] = ["a":1,"b":2,"c":3]var dict = ["a":1,"b":2,"c":3, 3:"d"] as [AnyHashable : Any] //注意这个没声明类型的，因为key和value里面都有不同的类型，所以需要将二者都强转为AnyHashable，但是如果key（value）类型只有一种的话，那么就会转为那种类型。var dict2 = [Int:String]()var dict3 = Dictionary&lt;String,Int&gt;() 添加/修改/删除dictionarydictionary也提供了removeAll，removeAtIndex之类的方法使用和Set是一样的，就不写了。下面是dictionary特有的 dict[5] = "f" //添加一个键值对 5: "f"dict[5] = 5 //修改key为5的值为5dict[5] = nil //删除key为5的键值对dict[6] = nil //对不存在的键值对赋nil不会报错dict2 = [:] //清空所有 新增了一个更改和删除的方法，可以获得更新和删除前的旧值(可选类型)。如果这个值以前不存在，那么返回nil let oldValue = airports.updateValue("Dublin Airport", forKey: "DUB") let removedValue = airports.removeValue(forKey: "DUB") 遍历dictionary for (key,name) in dict &#123; print(key,name,separator:":")&#125;var keys = dict1.keys.sort();for key in keys &#123; print(key,dict[key]!)&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-String-Character]]></title>
<url>../../../../../../../../2017/11/24/Swift-Grammar-String-Character/</url>
    <content type="text"><![CDATA[String String 的定义 public struct String &#123; /// An empty `String`. public init()&#125; 创建字符串，最简单的方法 var str = "I am a string" 创建空串 var emptyStr1 = ""或var emptyStr2 = String() 使用三个引号来创建一段话的string开始的三个引号的第一行后面的空格都会忽略，但是第二行的空格不会 let quotation = """The White Rabbit put on his spectacles. "Where shall I begin,please your Majesty?" he asked."Begin at the beginning," the King said gravely, "and go ontill you come to the end; then stop."""" Character 创建一个Character，必须显式声明类型 var c1:Character = "c" //注意是双引号var c2 = "c" //c2被认为是String类型var c3 = 'c' //编译错误Character可以赋值为Unicodelet eAcute: Character = "\u&#123;E9&#125;" // é 改变String，这个语法和java一样的，不过内存管理层面已经是不同的对象了 var str:String = "first"var c1:Character = "c" //注意是双引号var c2 = "c" //c2被认为是String类型str += "sceond" //str变为firstsceond,此时的str和之前的str内存地址不同str += c2 //str变为firstc,此时的str和之前的str内存地址不同str.appendContentsOf("second") // 和使用+=是一样的str.appendContentsOf(c2) //和使用+=是一样的str.append(c1); //添加Character的方法 遍历String字符 var str:String = "first"for c in str.characters &#123; print(c)&#125; ------ 或for index in str.characters.indices &#123; print(str[index])&#125; 获取String长度 var s = "dfe"print(s.count) //3 swift里面有extended grapheme clusters(An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.) 也就是几个Unicode字符组合成一个人类可以识别的字符。 当string里面添加了characters后，count不一定会增加。string的count不一定和NSString的length一致。(The length of an NSString is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.) String的Index 不像java里面的Index直接就是一个数字。String的Index是在不同的extension中定义的。 获得String里面的某个字符的过程 let greeting = "Guten Tag!"greeting[greeting.startIndex]// Ggreeting[greeting.index(before: greeting.endIndex)]// !greeting[greeting.index(after: greeting.startIndex)]// ulet index = greeting.index(greeting.startIndex, offsetBy: 7)greeting[index]// a 插入和移除字符 var welcome = "hello"welcome.insert("!", at: welcome.endIndex)// welcome now equals "hello!"welcome.insert(contentsOf: " there", at: welcome.index(before: welcome.endIndex))// welcome now equals "hello there!"welcome.remove(at: welcome.index(before: welcome.endIndex))// welcome now equals "hello there"let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndexwelcome.removeSubrange(range)// welcome now equals "hello" 截串 Swift引入了一个SubString类，用来截串 let greeting = "Hello, world!"let index = greeting.index(of: ",") ?? greeting.endIndexlet beginning = greeting[..&lt;index]// beginning is "Hello"但是注意SubString可能会用到原来string的内存。官方建议是短时间使用，如果想要长时间保持，需要转为String// Convert the result to a String for long-term storage.let newString = String(beginning) 将String转换为NSString，然后调用NSString的截串方法 var str = "123456789"var ns = (str as NSString).substringWithRange(NSMakeRange(1, 4))print(ns) //输出 2345 xtension来扩展String(最简单) mport Foundationextension String &#123; //获取部分字符串，如果不在范围内，返回nil.如果end大于字符串长度，那么截取到最后 subscript (start: Int, end: Int) -&gt; String? &#123; if start &gt; self.count || start &lt; 0 || start &gt; end &#123; return nil &#125; let begin = self.index(self.startIndex, offsetBy: start) var terminal: Index if end &gt;= length &#123; terminal = self.index(self.startIndex, offsetBy: count) &#125; else &#123; terminal = self.index(self.startIndex, offsetBy: end + 1) &#125; let range = (begin ..&lt; terminal) return self.substring(with: range) &#125; //获取某个字符，如果不在范围内，返回nil subscript (index: Int) -&gt; Character? &#123; if index &gt; self.count - 1 || index &lt; 0 &#123; return nil &#125; return self[self.index(self.startIndex, offsetBy: index)] &#125;&#125;]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-基本类型和基本运算]]></title>
<url>../../../../../../../../2017/11/24/Swift-Grammar-基本类型和基本运算/</url>
    <content type="text"><![CDATA[基本类型 多出来的是 Tuple*8 和 可选类型** 数字类型 Int 在32位机器上是Int32 在64位机器上是Int64 除了Int之外，还有Int，Int8，Int16，Int32，Int64. UInt 在32位机器上是UInt32 在64位机器上是UInt64. 除了UInt之外，还有UInt8，UInt16，UInt32，UInt64. Double 64位浮点数 Float 32位浮点数 Swift不支持数字类型之间的自动转换。必须显式手动转换 var i: Int = 2_000 //这个表示2000 var d: Double = 5.3 var e = d * Double(i) 不同进制的前缀十进制 没有二进制 0b八进制 0o十六进制 0x科学计数1.25e2 代表 1.25乘上10的2次方0xFp2 代表 15乘上2的2次方typealias 关键字，用来个类型起别名 typealias ii = Int8 var mm = ii.min //这里的ii代表了Int8 Boolean 类型 Swift和java一样，对boolean类型是强要求的，不能在if里面传一个整形用于判断 新类型——元组（Tuple） 其实就是一群数据组合，可以将其解出来输出。注意的是tuple不只是两个元素，你可以自己扩展成多个元素 var menu = ("apple", 20) //定义一个Tuple var menu2 = (name: "banana", price:10) //可以在定义的时候指定元素名字 let (name,price) = menu //解Tuple，如果某个元素不想要的话，用 _ 代替 print(name, price) //输出 apple 20 print(menu.0,menu.1) //不解Tuple直接输出 print(menu2.name,menu2.price) //利用元素名字解Tuple 可选类型（Optionals) 当一个方法可以返回一个对象的时候，它有可能返回一个空值。比如将字符串转换为数字的方法。为了处理这种情况，有了可选类型。 可选类型表示一个数据，它可能有值，也可能为空。基本语法是在类型的后面加上问号 ？ 比如下面的代码var str:String print(str) //这里报错说str没初始化 但是如果将str改为可选类型，那么这就可以输出 var str:String? print(str) //输出 nil 可选类型转换为对应的类型 –&gt;对可选类型解包强制解包有个注意点，就是如果这个可选类型是nil的话，那么强制解包的语句会在运行时报错 var str:String? = "fe" var s = str! //将str解包为s，但是如果str没有赋值的话，那么这句会在运行时报错 print(s) 解决强制解包的时候，可选类型可能为nil的问题。if语句里面多了一个 Optional Binding 的概念。就是将可选类型解包后判断是否为nil，然后执行不同的分支代码 //因为没给str赋值，所以输出 str为空 var str:String? if let s = str &#123; print("str有值") &#125; else &#123; print("str为空") &#125; 在编程中，我们可以确保可选类型一定不为nil的，那么每次要将可选类型解包都要加个 !，很麻烦。所以有了隐式可选类型，它是用 ! 代替了 ? 号。然后在需要将可选类型转换为对应类型的时候就不用加 ! 了 var str:String! = "string" var s = str 基本运算一些和C完全一样的基本运算 加减乘除，负号，自增（++）自减（–），+=等， 判断大小之类（==，!=，&gt;=…），三元运算符，逻辑运算（!，&amp;&amp;，||） 不一样的运算符取模% 在C中，只能对整形进行运算Swift中可以对浮点数进行运算。结果就是多出来的那部分 比如 7.1%2.5 得到2.1，因为7.1可以最多减去2个2.5，然后剩下2.1 范围运算符 … 和 ..&lt;两个运算符可以用在for里面 //输出 1 2 3 包含最后一个元素3 for i in 1...3 &#123; print(i) &#125; //输出 1 2 不包含最后一个元素3 for i in 1..&lt;3 &#123; print(i) &#125; 单范围运算符 对于下标运算可以这样用 let names = ["Anna", "Alex", "Brian", "Jack"] for name in names[2...] &#123; print(name) &#125; // Brian // Jack for name in names[...2] &#123; print(name) &#125; // Anna // Alex // Brian for name in names[..&lt;2] &#123; print(name) &#125; // Anna // Alex 二元运算符 ??这是一个二元运算符 a ?? b它的意思是：如果可选类型a不是nil，那么解包a并返回解包值，如果a为nil，那么返回b相当于 a != nil ? a! : b]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Grammar-Protocol协议]]></title>
<url>../../../../../../../../2017/11/24/Swift-Grammar-Protocol协议/</url>
    <content type="text"><![CDATA[Protocol协议 协议 规定了用来实现某一特定功能所必须的方法和属性。任意能够满足协议要求的类型被称为遵循(conform)这个协议。类，结构体或枚举类型都可以遵循协议，并提供具体实现来完成协议定义的方法和功能 语法格式 语法 protol OneProtocol&#123;// 协议内容&#125; 要使类遵循某个协议，需要在类型名称后加上协议名称，中间以冒号:分隔，作为类型定义的一部分。遵循多个协议时，各协议之间用逗号,分隔 struct OneStructure: OneProtocol, TwoProtocol &#123; // 结构体内容&#125; 如果类在遵循协议的同时拥有父类，应该将 父类名 放在 协议名 之前，以逗号分隔 class OneClass: OneSuperClass, OneProtocol, TwoProtocol &#123; // 类的内容&#125; 对属性的规定 协议 用于指定特定的实例属性或类属性，而不是指定是存储型属性或计算型属性。此外还必须指明是只读的还是可读可写的。协议中的通常用var来声明变量属性，在类型声明后加上{ set get }来表示属性是可读可写的，只读属性则用{ get }来表示。 protocol classa &#123; var marks: Int &#123; get set &#125; var result: Bool &#123; get &#125; func attendance() -&gt; String func markssecured() -&gt; String&#125;protocol classb: classa &#123; var present: Bool &#123; get set &#125; var subject: String &#123; get set &#125; var stname: String &#123; get set &#125;&#125;class classc: classb &#123; var marks = 96 let result = true var present = false var subject = "Swift 协议" var stname = "Protocols" func attendance() -&gt; String &#123; return "The \(stname) has secured 99% attendance" &#125; func markssecured() -&gt; String &#123; return "\(stname) has scored \(marks)" &#125;&#125;let studdet = classc()studdet.stname = "Swift"studdet.marks = 98studdet.markssecured()print(studdet.marks)print(studdet.result)print(studdet.present)print(studdet.subject)print(studdet.stname)以上程序执行输出结果为98truefalseSwift 协议Swift 对 Mutating 方法的规定 有时需要在方法中改变它的实例。例如：值类型（结构体，枚举）的实例方法中，将mutating关键字作为函数的前缀，写在func之前，表示可以在该方法中修改它所属的实例及其实例属性的值 protocol daysofaweek &#123; mutating func show()&#125;enum days: daysofaweek &#123; case sun, mon, tue, wed, thurs, fri, sat mutating func show() &#123; switch self &#123; case .sun: self = .sun print("Sunday") case .mon: self = .mon print("Monday") case .tue: self = .tue print("Tuesday") case .wed: self = .wed print("Wednesday") case .thurs: self = .thurs print("Wednesday") case .fri: self = .fri print("Wednesday") case .sat: self = .sat print("Saturday") default: print("NO Such Day") &#125; &#125;&#125;var res = days.wedres.show()程序执行输出结果为：Wednesday 对构造器的规定 协议可以要求它的遵循者实现指定的构造器。像书写普通的构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体，语法如下： protocol SomeProtocol &#123; init(someParameter: Int)&#125; 实例 protocol tcpprotocol &#123; init(aprot: Int)&#125; 协议构造器规定在类中的实现 你可以在遵循该协议的类中实现构造器，并指定其为类的指定构造器或者便利构造器。在这两种情况下，你都必须给构造器实现标上”required”修饰符： class SomeClass: SomeProtocol &#123; required init(someParameter: Int) &#123; // 构造器实现 &#125;&#125;protocol tcpprotocol &#123; init(aprot: Int)&#125;class tcpClass: tcpprotocol &#123; required init(aprot: Int) &#123; &#125;&#125; 施用required修饰符可以保证：所有的遵循该协议的子类，同样能为构造器规定提供一个显式的实现或继承实现。如果一个子类重写了父类的指定构造器，并且该构造器遵循了某个协议的规定，那么该构造器的实现需要被同时标示required和override修饰符： protocol tcpprotocol &#123; init(no1: Int)&#125;class mainClass &#123; var no1: Int // 局部变量 init(no1: Int) &#123; self.no1 = no1 // 初始化 &#125;&#125;class subClass: mainClass, tcpprotocol &#123; var no2: Int init(no1: Int, no2 : Int) &#123; self.no2 = no2 super.init(no1:no1) &#125; // 因为遵循协议，需要加上"required"; 因为继承自父类，需要加上"override" required override convenience init(no1: Int) &#123; self.init(no1:no1, no2:0) &#125;&#125;let res = mainClass(no1: 20)let show = subClass(no1: 30, no2: 50)print("res is: \(res.no1)")print("res is: \(show.no1)")print("res is: \(show.no2)")以上程序执行输出结果为：res is: 20res is: 30res is: 50 协议类型 尽管协议本身并不实现任何功能，但是协议可以被当做类型来使用协议可以像其他普通类型一样使用，使用场景: 作为函数、方法或构造器中的参数类型或返回值类型 作为常量、变量或属性的类型 作为数组、字典或其他容器中的元素类型 实例 protocol Generator &#123; associatedtype members func next() -&gt; members?&#125;var items = [10,20,30].makeIterator()while let x = items.next() &#123; print(x)&#125;for lists in [1,2,3].map( &#123;i in i*5&#125;) &#123; print(lists)&#125;print([100,200,300])print([1,2,3].map(&#123;i in i*10&#125;))以上程序执行输出结果为：10203051015[100, 200, 300][10, 20, 30] 在扩展中添加协议成员 可以通过扩展来扩充已存在类型( 类，结构体，枚举等)。扩展可以为已存在的类型添加属性，方法，下标脚本，协议等成员。 protocol AgeClasificationProtocol &#123; var age: Int &#123; get &#125; func agetype() -&gt; String&#125;class Person &#123; let firstname: String let lastname: String var age: Int init(firstname: String, lastname: String) &#123; self.firstname = firstname self.lastname = lastname self.age = 10 &#125;&#125;extension Person : AgeClasificationProtocol &#123; func fullname() -&gt; String &#123; var c: String c = firstname + " " + lastname return c &#125; func agetype() -&gt; String &#123; switch age &#123; case 0...2: return "Baby" case 2...12: return "Child" case 13...19: return "Teenager" case let x where x &gt; 65: return "Elderly" default: return "Normal" &#125; &#125;&#125; 协议的继承协议能够继承一个或多个其他协议，可以在继承的协议基础上增加新的内容要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔： protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123; // 协议定义&#125; 实例 protocol Classa &#123; var no1: Int &#123; get set &#125; func calc(sum: Int)&#125;protocol Result &#123; func print(target: Classa)&#125;class Student2: Result &#123; func print(target: Classa) &#123; target.calc(1) &#125;&#125;class Classb: Result &#123; func print(target: Classa) &#123; target.calc(5) &#125;&#125;class Student: Classa &#123; var no1: Int = 10 func calc(sum: Int) &#123; no1 -= sum print("学生尝试 \(sum) 次通过") if no1 &lt;= 0 &#123; print("学生缺席考试") &#125; &#125;&#125;class Player &#123; var stmark: Result! init(stmark: Result) &#123; self.stmark = stmark &#125; func print(target: Classa) &#123; stmark.print(target) &#125;&#125;var marks = Player(stmark: Student2())var marksec = Student()marks.print(marksec)marks.print(marksec)marks.print(marksec)marks.stmark = Classb()marks.print(marksec)marks.print(marksec)marks.print(marksec)以上程序执行输出结果为：学生尝试 1 次通过学生尝试 1 次通过学生尝试 1 次通过学生尝试 5 次通过学生尝试 5 次通过学生缺席考试学生尝试 5 次通过学生缺席考试 类专属协议你可以在协议的继承列表中,通过添加class关键字,限制协议只能适配到类（class）类型。该class关键字必须是第一个出现在协议的继承列表中，其后，才是其他继承协议。格式如下： protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123; // 协议定义&#125; 实例 protocol TcpProtocol &#123; init(no1: Int)&#125;class MainClass &#123; var no1: Int // 局部变量 init(no1: Int) &#123; self.no1 = no1 // 初始化 &#125;&#125;class SubClass: MainClass, TcpProtocol &#123; var no2: Int init(no1: Int, no2 : Int) &#123; self.no2 = no2 super.init(no1:no1) &#125; // 因为遵循协议，需要加上"required"; 因为继承自父类，需要加上"override" required override convenience init(no1: Int) &#123; self.init(no1:no1, no2:0) &#125;&#125;let res = MainClass(no1: 20)let show = SubClass(no1: 30, no2: 50)print("res is: \(res.no1)")print("res is: \(show.no1)")print("res is: \(show.no2)")以上程序执行输出结果为：res is: 20res is: 30res is: 50 九、协议合成Swift 支持合成多个协议，这在我们需要同时遵循多个协议时非常有用。语法格式如下： protocol Stname &#123; var name: String &#123; get &#125;&#125;protocol Stage &#123; var age: Int &#123; get &#125;&#125;struct Person: Stname, Stage &#123; var name: String var age: Int&#125;func show(celebrator: Stname &amp; Stage) &#123; print(&quot;\(celebrator.name) is \(celebrator.age) years old&quot;)&#125;let studname = Person(name: &quot;Priya&quot;, age: 21)print(studname)let stud = Person(name: &quot;Rehan&quot;, age: 29)print(stud)let student = Person(name: &quot;Roshan&quot;, age: 19)print(student)以上程序执行输出结果为：Person(name: &quot;Priya&quot;, age: 21)Person(name: &quot;Rehan&quot;, age: 29)Person(name: &quot;Roshan&quot;, age: 19) 检验协议的一致性 使用is和as操作符来检查是否遵循某一协议或强制转化为某一类型。 is操作符用来检查实例是否遵循了某个协议。 as?返回一个可选值，当实例遵循协议时，返回该协议类型;否则返回nil。 as用以强制向下转型，如果强转失败，会引起运行时错误。 实例 下面的例子定义了一个 HasArea 的协议，要求有一个Double类型可读的 area： protocol HasArea &#123; var area: Double &#123; get &#125;&#125;// 定义了Circle类，都遵循了HasArea协议class Circle: HasArea &#123; let pi = 3.1415927 var radius: Double var area: Double &#123; return pi * radius * radius &#125; init(radius: Double) &#123; self.radius = radius &#125;&#125;// 定义了Country类，都遵循了HasArea协议class Country: HasArea &#123; var area: Double init(area: Double) &#123; self.area = area &#125;&#125;// Animal是一个没有实现HasArea协议的类class Animal &#123; var legs: Int init(legs: Int) &#123; self.legs = legs &#125;&#125;let objects: [AnyObject] = [ Circle(radius: 2.0), Country(area: 243_610), Animal(legs: 4)]for object in objects &#123; // 对迭代出的每一个元素进行检查，看它是否遵循了HasArea协议 if let objectWithArea = object as? HasArea &#123; print("面积为 \(objectWithArea.area)") &#125; else &#123; print("没有面积") &#125;&#125;以上程序执行输出结果为：面积为 12.5663708面积为 243610.0没有面积]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Develpe文档]]></title>
<url>../../../../../../../../2017/11/23/1/</url>
    <content type="text"><![CDATA[swift4苹果开发者中心 swift 语法基础]]></content>
      <categories>
        <category>Swift</category>
        <category>Document</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Lib-YYKit-YYmodel]]></title>
<url>../../../../../../../../2017/11/23/iOS-Lib-YYKit-YYmodel/</url>
    <content type="text"></content>
      <categories>
        <category>iOS</category>
        <category>Lib</category>
        <category>YYKit</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Tool-FastLane自动化发布工具+上传Bugly]]></title>
<url>../../../../../../../../2017/11/23/iOS-Tool-FastLane自动化发布工具+上传Bugly/</url>
    <content type="text"><![CDATA[打包的流程 修改测试版本号 修改Build版本号 执行Archive 选择Adhoc导出IPA安装包文件 上传Bugly测试平台 分享测试链接二维码FastlaneFastlane本身包含两大模块，内核部分+ActionActionAction是Fastlane自动化流程中的最小执行单元，直观上来讲就是Fastfile脚本中的一个个命令，比如：git_pull，deliver，pod_install等等，而这些命令背后都对应其实是一个用Ruby编写的脚本 Fastlane 是一套用 Ruby 编写的 iOS 命令行工具集（后来也支持了 Android），主要组件包括： match / cert / sigh 协助管理代码签名 pem 自动生成 APNs 证书 scan 自动化测试 gym 自动化编译并打包生成签名的 .ipa 文件 snapshot / frameit 协助处理 iOS 屏幕快照 pilot 上传和管理 TestFlight deliver 将应用及其它信息上传到 App Store 而正是这些颗粒度极小的Action，根据自己需求组合成一个自动化的链条 安装 首先确保Xcode命令行工具是最新版本的 $ xcode-select --install 安装Fastlane: $ sudo gem install fastlane -NV 找到工程文件目录下执行 $ fastlane init 在执行“Your Apple ID” 这一步输入苹果开发者账号，fastlane 会自动获取工程文件名，目录等其他数据。这一步“Please confirm the above values”，确认信息，没问题则输入 y。然后，fastlane 会进行一系列的初始化操作，包括下载 App Store 上的元数据和截屏文件。等待初始化完成之后，工程目录下就多了一个 fastlane目录： $ cd fastlane &amp;&amp; lsAppfile Fastfile metadata report.xmlDeliverfile README.md screenshots 文件目录 metadata目录下存放整个元数据文件，包括关键词、版本更新日志、图标等. screenshots目录下存放应用截图 Appfile文件记录App的 bundle ID、Apple ID、Team ID三种信息. Fastfile脚本的核心执行文件.有几个默认的选项，可直接使用. report文件时每次执行fastlane时生成报告 安装fastlane成功后，首先拆解我们需要自动化的两个流程: 自动打包成Adhoc的安装包ipa文件 通过fastlane自动上传到bugly 自动化打包 自动化打包使用最多就是Fastlane中gym这个Action, 转为打包而生, 安装gym这个组件: $ sudo gem install gym cd项目根目录, 创建自动打包脚本: $ vim gym.sh 输入脚本内容: #!/bin/bash#计时SECONDS=0#假设脚本放置在与项目相同的路径下project_path=$(pwd)#取当前时间字符串添加到文件结尾now=$(date +"%Y_%m_%d_%H_%M_%S")#指定项目的scheme名称scheme="Xitu"#指定要打包的配置名configuration="Adhoc"#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数export_method='ad-hoc'#指定项目地址workspace_path="$project_path/Xitu.xcworkspace"#指定输出路径output_path="project_path/APP"#指定输出归档文件地址archive_path="$output_path/Xitu$&#123;now&#125;.xcarchive"#指定输出ipa地址ipa_path="$output_path/Xitu$&#123;now&#125;.ipa"#指定输出ipa名称ipa_name="Xitu$&#123;now&#125;.ipa"#获取执行命令时的commit messagecommit_msg="$1"#输出设定的变量值echo "===workspace path: $&#123;workspace_path&#125;==="echo "===archive path: $&#123;archive_path&#125;==="echo "===ipa path: $&#123;ipa_path&#125;==="echo "===export method: $&#123;export_method&#125;==="echo "===commit msg: $1==="#先清空前一次buildgym --workspace $&#123;workspace_path&#125; --scheme $&#123;scheme&#125; --clean --configuration $&#123;configuration&#125; --archive_path $&#123;archive_path&#125; --export_method $&#123;export_method&#125; --output_directory $&#123;output_path&#125; --output_name $&#123;ipa_name&#125;#输出总用时echo "===Finished. Total time: $&#123;SECONDS&#125;s===" 把如上脚本中Xitu改成你的项目名称即可. 为脚本执行提升权限 $ chmod +x gym.sh 执行一下脚本看一下打包效果: $ ./gym.sh 经过572s，Adhoc版本的ipa文件打包成功，我们在项目根目录下找到App目录： =========================================== #上传Bugly fastlane中定义action$ fastlane new_action 这时命令行会要求你输入自定义action名字，直接以bugly上传文件命名 $ upload_app_to_bugly wei wan]]></content>
      <categories>
        <category>iOS</category>
        <category>Tool</category>
        <category>FastLane</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Blog-配置]]></title>
<url>../../../../../../../../2017/11/23/Blog-配置/</url>
    <content type="text"><![CDATA[博客配置01博客配置02]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Code-优化项目]]></title>
<url>../../../../../../../../2017/11/23/iOS-Code-优化项目/</url>
    <content type="text"><![CDATA[优化项目 结构与架构1.1 结构 这里说的结构大概有两点：1.文件目录分类 2.第三方库管理1.1.1 文件目录分类 为了方便管理，最好将Xcode中的项目展示目录与实际的存储目录保持一致此外，一般按业务模块分类,一级目录可以按照MVC格式，也可以按照业务模块划分用最普遍的Model View Controller架构举例]]></content>
      <categories>
        <category>iOS</category>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-Bug管理工具]]></title>
<url>../../../../../../../../2017/11/22/iOS-Func-Bug管理工具/</url>
    <content type="text"><![CDATA[#功能 非Crash Bug 在App内可截图添加描述并发送 Crash Bug 在App第二次启动时提取Crash log添加描述并发送 实现解释分析 bug 非Crash的Bug：字体不对、颜色不对、数据不对、布局不对 Crash Bug：系统Crash、处理signal场景交互 场景交互：发现非Crash Bug时候摇一摇手机，弹出邮件，图片带入邮件，点击发送即可。有Crash Bug的时候第二次启动App，弹出邮件，Crash log带入邮件，点击发送即可 使用 需要用到NSSetUncaughtExceptionHandler，MFMailComposeViewController，沙盒，NSFileManager实现截图的功能，考虑到并不是所有的页面都需要使用所以写在了分类里。需要用的时候直接引入头文件即可这三个方法分别在摇一摇的时候回调用，开始，需要，结束。他们的父类是UIResponsder在UIKit中 -(void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event&#123;&#125;-(void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event&#123;&#125;-(void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event&#123; [self screenShot];&#125;-(void)screenShot&#123; UIWindow *screen = [[UIApplication sharedApplication] keyWindow]; UIGraphicsBeginImageContext(screen.frame.size); [screen.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsGetCurrentContext(); NSData *screenData = UIImagePNGRepresentation(image); [screenData writeToFile:[NSHomeDirectory() stringByAppendingPathComponent:@"Library/Caches"] atomically:YES]; &#125; 发送邮件的功能 发送邮件的功能，也写在了分类里面，需要用的时候引入即可 @interface UIViewController (send)&lt;MFMailComposeViewControllerDelegate&gt;//发送邮件的方法，传入标题，描述信息，data, 接收人-(void)sendMail:(MFMailComposeViewController*)mf andSubject:(NSString*)subject andMessageBody:(NSString*)message andData:(NSData*)data andRecipients:(NSArray*)recipients&#123; if([MFMailComposeViewController canSendMail])&#123; mf.mailComposeDelegate = self; [mf setSubject:subject]; [mf setToRecipients:recipients]; [mf addAttachmentData:data mimeType:@"image/jpeg" fileName:@"error"]; [mf setMessageBody:message isHTML:YES]; [self presentViewController:mf animated:YES completion:nil]; &#125;else&#123; [self alertView:@"不能调用邮箱" andDesc:@"请尝试下载App原生邮箱，并配置"]; &#125;&#125; MFMailComposeViewControllerDelegate的代理方法，可以在这个方法里面写一些回调-(void)mailComposeController:(MFMailComposeViewController *)controller didFinishWithResult:(MFMailComposeResult)result error:(NSError *)error&#123; switch (result) &#123; case MFMailComposeResultSent: [self alertView:@"发送成功" andDesc:nil]; self.success(); break; case MFMailComposeResultSaved: [self alertView:@"保存成功" andDesc:nil]; break; case MFMailComposeResultFailed: self.faild(); [self alertView:error.domain andDesc:[NSString stringWithFormat:@"%@",error.userInfo]]; break; case MFMailComposeResultCancelled: [self alertView:@"取消发送" andDesc:nil]; break; default: [self alertView:@"为什么不发送" andDesc:nil]; break; &#125; [self dismissViewControllerAnimated:YES completion:nil];&#125; 异常捕获这两个为函数方法，导入类名，直接可调用不用初始化void CrashExceptionHandler(void)&#123; NSSetUncaughtExceptionHandler(&amp;ExceptionLog);&#125;void ExceptionLog(NSException *exception)&#123; NSDate *date_current = [NSDate date]; NSDictionary *dictInfo = [[NSBundle mainBundle]infoDictionary]; NSString *name_App = [dictInfo objectForKey:@"CFBundleDisplayName"]; NSString *verson_App = [dictInfo objectForKey:@"CFBundleShortVersionString"]; NSString *build_App = [dictInfo objectForKey:@"CFBundleVersion"]; NSArray *ecp = exception.callStackSymbols; NSString *reason = [exception reason]; NSString *name = [exception name]; NSString *exceptionInfo = [NSString stringWithFormat: @"\n\n ******************************异常日志****************************** \n时间:%@\nApp名称:%@\nApp版本:%@\nBuild版本:%@\n异常名称:%@\n异常原因:%@\n堆栈信息:%@",date_current,name_App,verson_App,build_App,name,reason,ecp]; [CrashHandler saveLog:exceptionInfo andDate:date_current];#ifdef DEBUG NSLog(@"%@",exceptionInfo);#else#endif&#125;@implementation CrashHandler+(void)saveLog:(NSString *)crashLog andDate:(NSDate *)date&#123; NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)objectAtIndex:0] stringByAppendingString:@"/Crash"]; if(![[NSFileManager defaultManager]fileExistsAtPath:path]) &#123; [[NSFileManager defaultManager]createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:nil]; &#125; NSString *logPath = [path stringByAppendingFormat:@"/%@.log",date]; [crashLog writeToFile:logPath atomically:YES encoding:NSUTF8StringEncoding error:nil];&#125;@end 检测Crash log 功能在App打开的第一个页面去调用就好-(void)crashLog { NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)objectAtIndex:0] stringByAppendingString:@"/Crash"]; NSFileManager *mf = [NSFileManager defaultManager]; if(![mf fileExistsAtPath:path]) { return; } NSArray *array = [mf contentsOfDirectoryAtPath:path error:nil]; } Bug管理工具]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-Crash日志]]></title>
<url>../../../../../../../../2017/11/22/iOS-Func-Crash日志/</url>
    <content type="text"><![CDATA[获得crash日志产生/保存 程序崩溃时，系统会创建一份crash日志保存在设备上。 这份crash日志记录着应用程序崩溃时的信息，包含每个执行线程的栈调用信息（低内存闪退日志例外），对定位问题很有帮助 连接设备获取 可以连接设备，打开Xcode - Window - Organizer， 在左侧面板中选择Device Logs（可以选择具体设备的Device Logs或者Library下所有设备的Device Logs） 然后根据时间排序查看设备上的crash日志 已发布app通过iTunes Connect获取 可以通过iTunes Connect（Manage Your Applications - View Details - Crash Reports）获取用户的crash日志 不过这并不是100%有效的，而且大多数开发者并不依赖于此，因为这需要用户设备同意上传相关信息，详情可参见iOS: Providing Apple with diagnostics and usage information摘要 接入现有的crash收集工具获取通常接入现有的crash收集工具，或者自己编写一个进行自动化收集、解析和统计汇总 解析crash日志符号化解析 当获得一份crash日志时，需要将初始展示的十六进制地址等原始信息映射为源代码级别的方法名称和代码行数，使其对开发人员可读这个过程称为符号化解析。要成功地符号化解析一份crash日志，我们需要有对应的应用程序二进制文件以及符号（.dSYM）文件 -如果处于开发调试阶段，通常Xcode都能匹配到crash日志对应的二进制文件和符号文件，所以能够帮我们自动解析。 如果处于测试阶段，测试人员已经安装了不同的版本（比如alpha、beta版本），那么需要保存好对应版本的二进制文件和符号文件，以便在应用程序崩溃时对crash日志进行解析。对于这种场景下产生的crash日志，只需要将.crash文件、.app文件和.dSYM文件三者放在同一个目录下，然后将.crash文件拖放到Xcode - Window - Organizer中左侧面板Library下的Device Logs中，即可进行解析。 如果要提交发布，那么我们通常会先执行Clean，再Build，最后通过Product - Archive来打包。这样，Xcode会将二进制文件和符号文件归档在一起，可以通过Organizer中的Archives进行浏览 关于如何解析crash日志的讨论 分析crash日志 在分析一份crash日志之前，如果开发人员对于常见的错误类型有所了解，那定是极好的。 crash日志的产生来源于两种问题：违反iOS策略被干掉，以及自身的代码bug iOS策略低内存闪退 低内存闪退日志 前面提到大多数crash日志都包含着执行线程的栈调用信息 但是低内存闪退日志除外，这里就先看看低内存闪退日志是什么样的我们使用Xcode 5和iOS 7的设备模拟一次低内存闪退，然后通过Organizer查看产生的crash日志，可以发现Process和Type都为Unknown： 具体的日志内容如下 第一部分是崩溃信息，包括识别标识、软硬件信息和时间信息等。 第二部分是内存页分配信息，以及当前占用内存最多的进程，上图中为crashTypeDemo。 第三部分是具体的进程列表，描述着每个进程使用内存的情况以及当前状态。在较早的版本中可以在某些进程后面看到“jettisoned”字样，表明这些进程使用过多内存被终止了，而现在我们看到的是“vm-pageshortage”字样。 当iOS检测到内存过低时，它（的VM系统）会发出低内存警告通知，尝试回收一些内存；如果情况没有得到足够的改善，iOS会终止后台应用以回收更多内存；最后，如果内存还是不足，那么正在运行的应用可能会被终止掉。 所以，我们的应用应该合理地响应系统抛出来的低内存警告通知，对一些缓存数据和可重新创建的对象进行释放，同时要避免出现内存泄露等问题。 低内存闪退是由iOS策略决定终止应用程序运行的，同样基于iOS策略的还有Watchdog超时和用户强制退出 Watchdog超时 Apple的iOS Developer Library网站上，QA1693文档中描述了Watchdog机制，包括生效场景和表现。如果我们的应用程序对一些特定的UI事件（比如启动、挂起、恢复、结束）响应不及时，Watchdog会把我们的应用程序干掉，并生成一份响应的crash报告 这份crash报告的有趣之处在于异常代码：“0x8badf00d”，即“ate bad food” 如果说特定的UI事件比较抽象，那么用代码来直接描述的话，对应的就是（创建一个工程时Xcode自动生成的）UIApplicationDelegate的几个方法： 所以当遇到Watchdog日志时，可以检查下上图几个方法是否有比较重的阻塞UI的动作 QA1693举的例子是在主线程进行同步网络请求。如果我们是在公司的Wifi环境下使用则一切顺利，但当应用程序发布出去面向很大范围的用户，在各种网络环境下运行，则不可避免地会出现一片Watchdog超时报告。另一种可能出现问题的场景就是数据量比较大的情况下进行的数据库版本迁移（同样是在主线程上），这也是促使我写这篇总结的一个直接因素。 用户强制退出 一看到“用户强制退出”，首先可能想到的双击Home键，然后关闭应用程序。不过这种场景是不会产生crash日志的，因为双击Home键后，所有的应用程序都处于后台状态，而iOS随时都有可能关闭后台进程，所以这种场景没有crash日志。 另一种场景是用户同时按住电源键和Home键，让iPhone重启。这种场景会产生日志（仅验证过一次），但并不针对特定应用程序。 这里指的“用户强制退出”场景，是稍微比较复杂点的操作：先按住电源键，直到出现“滑动关机”的界面时，再按住Home键，这时候当前应用程序会被终止掉，并且产生一份相应事件的crash日志 通常，用户应该是遇到应用程序卡死，并且影响到了iOS响应，才会进行这样的操作——不过感觉这操作好高级，所以这样的crash日志应该比较少见 常见错误标识Exception codes上面“用户强制退出”的crash日志中的Exception Codes是“0xdeadfa11”，再上面“Watchdog超时”的crash日志中的Exception Codes是“0x8badf00d”，这些都是特有的Exception codes。根据官方文档描述，至少有以下几种特定异常代码： 0x8badf00d错误码：Watchdog超时，意为“ate bad food”。 0xdeadfa11错误码：用户强制退出，意为“dead fall”。 0xbaaaaaad错误码：用户按住Home键和音量键，获取当前内存状态，不代表崩溃。0xbad22222错误码：VoIP应用（因为太频繁？）被iOS干掉。 0xc00010ff错误码：因为太烫了被干掉，意为“cool off”。 0xdead10cc错误码：因为在后台时仍然占据系统资源（比如通讯录）被干掉，意为“dead lock” Exception types查看我们的crash分析报告邮件，会发现最经常遇到的错误类型是SEGV（Segmentation Violation，段违例），表明内存操作不当，比如访问一个没有权限的内存地址。当我们收到SIGSEGV信号时，可以往以下几个方面考虑：访问无效内存地址，比如访问Zombie对象；尝试往只读区域写数据；解引用空指针；使用未初始化的指针；栈溢出；此外，还有其它常见信号：SIGABRT：收到Abort信号，可能自身调用abort()或者收到外部发送过来的信号；SIGBUS：总线错误。与SIGSEGV不同的是，SIGSEGV访问的是无效地址（比如虚存映射不到物理内存），而SIGBUS访问的是有效地址，但总线访问异常（比如地址对齐问题）；SIGILL：尝试执行非法的指令，可能不被识别或者没有权限；SIGFPE：Floating Point Error，数学计算相关问题（可能不限于浮点计算），比如除零操作；SIGPIPE：管道另一端没有进程接手数据 代码bug此外，比较常见的崩溃基本都源于代码bug，比如数组越界、插空、多线程安全性、访问野指针、发送未实现的selector等。如果引入Core Data，则又有另外一些常见问题，不过这是另一个话题了。 遇到这些bug时，都有比较清楚的错误原因说明，比如“index 0 beyond bounds for empty array”等。需要稍微注意点的是多线程问题，当一时找不到解决思路时，不妨往多线程方面考虑下 iOS应用的crash日志的分析基础]]></content>
      <categories>
        <category>iOS</category>
        <category>Crash</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-检测主线程卡顿的问题]]></title>
<url>../../../../../../../../2017/11/22/iOS-Func-检测主线程卡顿的问题/</url>
    <content type="text"><![CDATA[runloop - 检测方案 原文文档 runloop 的状态typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 耗时进行判断 利用 kCFRunLoopBeforeSources 和 *kCFRunLoopAfterWaiting 这两个状态之间的耗时 进行判断:是否有太多事件处理导致出现了卡顿 AppDelegate+AppService 监听runloop的状态而写的回调函数 static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; PingConfig *object = (__bridge PingConfig*)info; // 记录状态值 object-&gt;activity = activity; // 发送信号 dispatch_semaphore_t semaphore = object-&gt;semaphore; dispatch_semaphore_signal(semaphore);&#125; AppDelegate 注册监听 PingConfig: 一个用来存储runloop的状态和信号量的自定义类，其中的结构如下 APP启动时我可以进入 registerObserver 方法，其中首先我创建一个记录信息的类PingConfig实例，然后创建一个信号，并且保存在这个PingConfig实例中(其实只是为了方便拿到 创建了一个观察者监测主线程的runloop,它会在主线程runloop状态切换时进行回调 开启一个子线程，并且在里面进行一个 while 循环，在 循环的开始处 wait 一个信号量，并且设置超时为 50毫秒，失败后会返回一个非0数，成功将会返回0，这时候线程会阻塞住等待一个信号的发出 如果runloop状态正常切换，那么就会进入回调函数，在回调函数中我们发出一个信号，并且记录当前状态到PingConfig实例中，下面的判断语句中发现为0，timeoutCount自动置为0，一切正常 当主线程出现卡顿，while循环中的信号量再次等待，但是回调函数没有触发，从而导致等待超时，返回一个非0数，进入判断句后，我们再次判断状态是否处于 kCFRunLoopBeforeSources 或 kCFRunLoopAfterWaiting，如果成立，timeoutCount+1 持续五次runloop不切换状态，说明runloop正在处理某个棘手的事件无法休息且不更新状态，这样while循环中的信号量超时会一直发生，超过5次后我们将断定主线程的卡顿并上传堆栈信息 - (void)registerObserver&#123; PingConfig *config = [PingConfig new]; // 创建信号 dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); config-&gt;semaphore = semaphore; CFRunLoopObserverContext context = &#123;0,(__bridge void*)config,NULL,NULL&#125;; CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes); __block uint8_t timeoutCount = 0; // 在子线程监控时长 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (YES) &#123; // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms) long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC)); if (st != 0) &#123;// NSLog(@"循环中--%ld",config-&gt;activity); if (config-&gt;activity==kCFRunLoopBeforeSources || config-&gt;activity==kCFRunLoopAfterWaiting) &#123; if (++timeoutCount &lt; 5)&#123; continue; &#125;else&#123; NSLog(@"卡顿了"); &#125; &#125; &#125; timeoutCount = 0; &#125; &#125;);&#125; PingConfig@interface PingConfig : NSObject&#123; @public CFRunLoopActivity activity; dispatch_semaphore_t semaphore;&#125;@end Other情况主线程卡顿主线程卡在界面尚未完全显示前 当主线程卡在界面尚未完全显示前，这个方案就检测不出来卡顿了，比如我将下面的代码放在B控制器中 dispatch_semaphore_t t = dispatch_semaphore_create(0); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@"----"); dispatch_semaphore_signal(t); &#125;); dispatch_semaphore_wait(t, DISPATCH_TIME_FOREVER); 上面是一段有问题的代码，将导致主线程的持续堵塞，如果我们在这段代码放在B控制器的ViewDidLoad方法中(ViewWillAppear同样) 运行后，当你希望push到B控制器时，项目将在上一个界面完全卡住，并且无法用上面的方案检测到，而且CPU及内存都显示正常 原因分析 由于runloop在处理完source0或者source1后，比如界面的跳转也是执行了方法，具体有没有用到source0这不重要，但是后面会紧接着进入准备睡眠(kCFRunLoopBeforeWaiting)的状态，然而此时线程的阻塞导致runloop的状态也被卡住无法切换，这样也就导致在那段检测代码中无法进入条件，从而检测不出来。 但是话说回来，APP在静止状态(保持休眠)和刚刚那种卡死状态都会使runloop维持在 kCFRunLoopBeforeWaiting状态，这样我们就无法在那段代码中增加判断来修复，因为无法知道到底是真的静止没有操作还是被阻塞住，我也没找到线程的阻塞状态属性，如果你发现这个属性，那么就可以使用那个属性来判断 检测方案dispatch_queue_t serialQueue = dispatch_queue_create("serial", DISPATCH_QUEUE_SERIAL); self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, serialQueue); dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 0.25 * NSEC_PER_SEC, 0); __block int8_t chokeCount = 0; dispatch_semaphore_t t2 = dispatch_semaphore_create(0); dispatch_source_set_event_handler(self.timer, ^&#123; if (config-&gt;activity == kCFRunLoopBeforeWaiting) &#123; static BOOL ex = YES; if (ex == NO) &#123; chokeCount ++; if (chokeCount &gt; 40) &#123; NSLog(@"差不多卡死了"); dispatch_suspend(self.timer); return ; &#125; NSLog(@"卡顿了"); return ; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; ex = YES; dispatch_semaphore_signal(t2); &#125;); BOOL su = dispatch_semaphore_wait(t2, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC)); if (su != 0) &#123; ex = NO; &#125;; &#125; &#125;); dispatch_resume(self.timer); 方案解释 开启一个异步队列，并且创建一个定时器，时间我设置的是0.25秒，具体时间随你自己，这个时间是用来检测卡死的持续时间 在定时器外面我也同样创建了一个用来同步的信号量，这个不解释了，不会的就去看一下信号量的使用方式。进入定时器的回调后，我设置了一个静态变量来记录主队列是否执行完成。 我们判断当前runloop的状态是否为kCFRunLoopBeforeWaiting，所以这个方案是用来弥补前面那个方案，如果主线程此时没有阻塞住，我们在这里向main Queue抛一个block，看它是否能够成功执行，如果成功执行，说明主线程没有阻塞住，如果已经被阻塞住，那我抛过去的block是肯定不会被执行的。 下面的代码就是一些辅助操作，当信号量超过50毫秒，抛给主线程的block没有执行，那么说明此时就有一些阻塞了，返回一个非0数，并设置 ex为NO，从而在下一次定时器回调到来时进行上报]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-UI-Shadow阴影]]></title>
<url>../../../../../../../../2017/11/22/iOS-UI-Shadow阴影/</url>
    <content type="text"><![CDATA[shadowColor:阴影颜色,可设置透明度等. shadowOffset:偏移量.,xy表示view左上角,width表示阴影与x的偏移量,height表示阴影与y值的偏移量 shadowOpacity = 0.4//阴影透明度,默认为0则看不到阴影.因此要看到阴影这个值必须大于0,shadowColor的透明度也要大于0 shadowRadius:5.模糊计算的半径,取平均值的半径,设置为0的话则为一个矩形块. 模糊度的解释:每一个像素取平均值,分母的取值范围,越大越模糊.感觉这篇文章讲的比较容易懂(http://www.dongcoder.com/detail-22914.html). 注意:如果clipsToBounds设置为YES,则阴影效果消失 let layer = view.layer layer.shadowColor = UIColor.black.cgColor//阴影颜色 layer.shadowOffset = CGSize(width: 10, height: 10)//width表示阴影与x的便宜量,height表示阴影与y值的偏移量 layer.shadowOpacity = 0.4//阴影透明度,默认为0则看不到阴影 layer.shadowRadius = 5; Go!]]></content>
      <categories>
        <category>iOS</category>
        <category>UI</category>
        <category>Layer</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>Layer</tag>
        <tag>Shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-Autoreleasepool]]></title>
<url>../../../../../../../../2017/11/22/iOS-Func-autoreleasepool/</url>
    <content type="text"><![CDATA[Autoreleasepool释放时机 每个个Runloop已经默认会创建一个Autoreleasepool 新增对Runloop的Observer, 及时获取Runloop的状态变化确认释放时机 添加一个监听者 创建监听者 - (void)addRunLoopObserver &#123; CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; switch (activity) &#123; case kCFRunLoopEntry: NSLog(@&quot;进入RunLoop&quot;); break; case kCFRunLoopBeforeTimers: NSLog(@&quot;即将处理Timer事件&quot;); break; case kCFRunLoopBeforeSources: NSLog(@&quot;即将处理Source事件&quot;); break; case kCFRunLoopBeforeWaiting: NSLog(@&quot;即将休眠&quot;); break; case kCFRunLoopAfterWaiting: NSLog(@&quot;被唤醒&quot;); break; case kCFRunLoopExit: NSLog(@&quot;退出RunLoop&quot;); break; default: break; &#125; &#125;); 添加监听者 CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);&#125; 测试 不手动添加autoreleasepool 方法运行连续运行两次, 不手动添加autoreleasepool - (void)test1 &#123; NSLog(@&quot;test1 begin!&quot;); for (int i = 0; i &lt; 10e5 * 2; i++) &#123; //@autoreleasepool &#123; NSString *str = [NSString stringWithFormat:@&quot;hi + %d&quot;, i]; //&#125; &#125; NSLog(@&quot;test1 finished!&quot;);&#125;- (void)test2 &#123; NSLog(@&quot;test2 begin!&quot;); for (int i = 0; i &lt; 10e5 * 2; i++) &#123; //@autoreleasepool &#123; NSString *str = [NSString stringWithFormat:@&quot;hi + %d&quot;, i]; //&#125; &#125; NSLog(@&quot;test2 finished!&quot;);&#125; Runloop没有完成一次循环之前所有内存都未释放, 即使局部变量出了作用域也必须等待Runloop循环完成 手动添加autoreleasepool观察释放时机 for{@autoreleasepool{}} 效果好于 @autoreleasepool{for…}@autoreleasepool{} @autoreleasepool&#123;&#125; 等价于 void *context = objc_autoreleasePoolPush();// &#123;&#125;中的代码objc_autoreleasePoolPop(context); 每次出了{}时objc_autoreleasePoolPop()就被调用, 所以直接释放掉了. 当然, 系统自动创建的autoreleasepool也是一样, 只是调用的时机不同: 线程与Runloop是一一对应, Runloop与系统创建的autoreleasepool也是一一对应, 所以不论是Runloop完成了一次循环还是线程被关闭时, autoreleasepool都会释放, 当然手动添加的也会被管理 主要就是一个类:AutoreleasePoolPage 两个函数: objc_autoreleasePoolPush()、objc_autoreleasePoolPop() 运作方式: autoreleasepool由若干个autoreleasePoolPage类以双向链表的形式组合而成 当程序运行到@autoreleasepool{时, objc_autoreleasePoolPush()将被调用, runtime会向当前的AutoreleasePoolPage中添加一个nil对象作为哨兵,在{}中创建的对象会被依次记录到AutoreleasePoolPage的栈顶指针,当运行完@autoreleasepool{}时, objc_autoreleasePoolPop(哨兵)将被调用, runtime就会向AutoreleasePoolPage中记录的对象发送release消息直到哨兵的位置, 即完成了一次完整的运作. 主线程中的自动释放池是自动创建的, 文档中说子线程中的自动释放池是需要手动创建的, 但实测, 其实我们常用的多线程管理方式(GCD, NSOprationQueue, NSThread)都已经帮我们处理好了, 其中NSThread在iOS7之后才自动创建线程中的AutoreleasePool 我们常用的for循环, 以及enumerate其实跟autoreleasepool也有关, for循环是不自动创建autoreleasepool的, 而enumerate中已经自动创建了autoreleasepool, 值得注意的是高并发enumerate常常会出一些意外的问题, 例如对象被提前释放, 所以建议高并发情况下使用for循环(性能高于enumerate), 再手动添加autoreleasepool.]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
      <tags>
        <tag>Autoreleasepool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-RunTime-方法交换/拦截基础使用]]></title>
<url>../../../../../../../../2017/11/22/iOS-RunTime-方法交换-拦截基础使用/</url>
    <content type="text"><![CDATA[RunTime的消息机制参考链接 Objective-C的方法调用是属于消息传送的机制每个类都有一个isa的结构体指针在这个结构体里, 得到指定类的所有属性, 所有方法的列表, 也可以知父类是什么… 新建RTMsgModel RTMsgModel.h @interface RTMsgModel : NSObject- (void)ff_post;- (void)ff_getWithCount:(NSInteger)count; RTMsgModel.m - (void)ff_post&#123; NSLog(@&quot;被调用了: %@, 当前对象为: %@&quot;, NSStringFromClass([self class]), self);&#125;- (void)ff_getWithCount:(NSInteger)count&#123; NSLog(@&quot;被%ld人调用了&quot;, count);&#125; 测试消息机制//// ViewController.m// Runtime方法交换拦截//// Created by RN on 17/11/22.// Copyright © 2017年 YueKekui. All rights reserved.//#import &quot;ViewController.h&quot;#import &quot;RTMsgModel.h&quot;#import &lt;objc/message.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self show_runTimeMsg];&#125;#pragma mark - RunTime的消息机制/** * @brief: RunTime的消息机制 * * * * @attention： Xcode 会自动屏蔽通过objc_msgSend创建对象, 我们可以去到工程里设置 * Build Setting -&gt; Enable Strict Checking of objc_msgSend Calls 改成No */- (void)show_runTimeMsg&#123; //1.objc_getClass Class getClass = objc_getClass(&quot;RTMsgModel&quot;); NSLog(@&quot;Get The Class is: %@&quot;, getClass); //2.objc_msgSend RTMsgModel *messageModel = objc_msgSend(getClass, @selector(alloc)); NSLog(@&quot;alloc Object: %@&quot;, messageModel); // 在不调用init方法, 可以通过发消息调用想用的方法, 这里调用没有在.h文件里声明的方法会警告该方法没有声明 objc_msgSend(messageModel, @selector(ff_post)); messageModel = objc_msgSend(messageModel, @selector(init)); NSLog(@&quot;init Object: %@&quot;, messageModel); objc_msgSend(messageModel, @selector(ff_post)); // 还有另外一种写法, 就是把所有东西都集合在一起, 也就是我们常用的[[NSObject alloc] init];的原型 RTMsgModel *messageModelTwo = objc_msgSend(objc_msgSend(objc_getClass(&quot;RTMsgModel&quot;), @selector(alloc)), @selector(init)); objc_msgSend(messageModelTwo, @selector(ff_getWithCount:), 5);&#125;@end 打印2017-11-22 12:36:16.232 Runtime方法交换拦截[21927:3962074] Get The Class is: RTMsgModel2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] alloc Object: &lt;RTMsgModel: 0x600000003680&gt;2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] 被调用了: RTMsgModel, 当前对象为: &lt;RTMsgModel: 0x600000003680&gt;2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] init Object: &lt;RTMsgModel: 0x600000003680&gt;2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] 被调用了: RTMsgModel, 当前对象为: &lt;RTMsgModel: 0x600000003680&gt;2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] 被5人调用了 RunTime方法交换 建一个类RunTimeMethodModel.h #import &lt;Foundation/Foundation.h&gt;@interface RunTimeMethodModel : NSObject@property (nonatomic, copy) NSString *cl_height;@property (nonatomic, copy) NSString *cl_weight;- (NSString *)cl_height;- (NSString *)cl_weight;@end RunTimeMethodModel.m - (NSString *)cl_height &#123; return @&quot;我身高180&quot;;&#125;- (NSString *)cl_weight &#123; return @&quot;我体重280&quot;; &#125; 测试交换方法 执行方法交换 RunTimeMethodModel *methodModel = [[RunTimeMethodModel alloc] init]; NSLog(@&quot;身高: %@&quot;, methodModel.cl_height); NSLog(@&quot;体重: %@&quot;, methodModel.cl_weight); Method methodOne = class_getInstanceMethod([methodModel class], @selector(cl_height)); Method methodTwo = class_getInstanceMethod([methodModel class], @selector(cl_weight)); method_exchangeImplementations(methodOne, methodTwo); NSLog(@&quot;打印的内容: %@&quot;, [methodModel cl_height]); 打印身高: 我身高180体重: 我体重280 打印的内容: 我体重280 注意一点注意一点, 由于这里的ViewController会销毁, 但method_exchangeImplementations会一直存在, 再次进来的时候, 就会再次根据上次交换过的顺序再次交换 +load交换方法 +load交换方法+ (void)load &#123; Method methodOne = class_getInstanceMethod(self, @selector(cl_height)); Method methodTwo = class_getInstanceMethod(self, @selector(cl_weight)); method_exchangeImplementations(methodOne, methodTwo);&#125;- (NSString *)cl_height &#123; return @&quot;我身高180&quot;;&#125;- (NSString *)cl_weight &#123; return @&quot;我体重280&quot;;&#125; 打印 身高: 我体重280体重: 我身高180身高: 我体重280体重: 我身高180 +initialize交换方法 +load这个方法里的确是可以保证方法交换只有一次, 但这里有一个弊端, 就是当程序一运行就会执行这个方法交换了+load: 程序一开始就会去执行, 只执行一次.+initialize: 当类被初始化的时候会才会去执行, 该类只会执行一次. initializeclass_getInstanceMethod 获取实例方法method_exchangeImplementations 方法交换 + (void)initialize + &#123; Method methodOne = class_getInstanceMethod(self, @selector(cl_height)); Method methodTwo = class_getInstanceMethod(self, @selector(cl_weight)); method_exchangeImplementations(methodOne, methodTwo);&#125;- (NSString *)cl_height &#123; return @&quot;我身高180&quot;;&#125;- (NSString *)cl_weight &#123; return @&quot;我体重280&quot;;&#125; RunTime方法拦截 从刚刚我们就知道, 可以使用method_exchangeImplementations交换两个方法, 但只应用在本类, 现在我们来看看别的应 @implementation BaseModel- (void)cl_logBaseModel &#123; NSLog(@&quot;Base Model Log&quot;);&#125;@end@implementation InterceptModel- (void)cl_logInterceptModel &#123; NSLog(@&quot;Intercept You Method &quot;);&#125;@end 最终的实现 + (void)initialize &#123; Method mehtodOne = class_getInstanceMethod([BaseModel class], @selector(cl_logBaseModel)); Method mehtodTwo = class_getInstanceMethod([InterceptModel class], @selector(cl_logInterceptModel)); method_exchangeImplementations(mehtodOne, mehtodTwo);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; BaseModel *baseModel = [[BaseModel alloc] init]; [baseModel cl_logBaseModel];&#125;。 打印结果发现方法是被InterceptModel这个类拦截, 并且替换了InterceptModel的方法 [InterceptModel cl_logInterceptModel] 第15行 Intercept You Method 类方法也可以交换和拦截 新增类方法 #import &quot;BaseModel.h&quot;@implementation BaseModel- (void)cl_logBaseModel &#123; NSLog(@&quot;Base Model Log&quot;);&#125;+ (void)cl_logBaseModelClass &#123; NSLog(@&quot;Base Model Class Log&quot;);&#125;@end-----------------------------------------------@implementation InterceptModel- (void)cl_logInterceptModel &#123; NSLog(@&quot;Intercept You Method &quot;);&#125;+ (void)cl_logInterceptModelClass &#123; NSLog(@&quot;Intercept Class You Method &quot;);&#125;@end 最终实现class_getInstanceMethod 获取类方法method_exchangeImplementations initialize class_getInstanceMethod 实例方法 class_getClassMethod 类方法 method_exchangeImplementations 交换方法 + (void)initialize &#123; // 拦截实例方法 Method mehtodOne = class_getInstanceMethod([BaseModel class], @selector(cl_logBaseModel)); Method mehtodTwo = class_getInstanceMethod([InterceptModel class], @selector(cl_logInterceptModel)); method_exchangeImplementations(mehtodOne, mehtodTwo); // 拦截类方法 Method classMehtodOne = class_getClassMethod([BaseModel class], @selector(cl_logBaseModelClass)); Method classMehtodTwo = class_getClassMethod([InterceptModel class], @selector(cl_logInterceptModelClass)); method_exchangeImplementations(classMehtodOne, classMehtodTwo);&#125; 执行 self.view.backgroundColor = [UIColor whiteColor];BaseModel *baseModel = [[BaseModel alloc] init];[baseModel cl_logBaseModel];[BaseModel cl_logBaseModelClass]; 打印 Intercept You Method Intercept Class You Method]]></content>
      <categories>
        <category>iOS</category>
        <category>RunTime</category>
      </categories>
      <tags>
        <tag>RunTime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIScrollView基础用法]]></title>
<url>../../../../../../../../2017/11/22/iOS-UIScrollView基础用法/</url>
    <content type="text"><![CDATA[属性- (void)viewDidLoad &#123; [super viewDidLoad]; _scrollView.backgroundColor = [UIColor redColor]; //设置contentSize（必须设置） _scrollView.contentSize = CGSizeMake(400, 667); //偏移量 _scrollView.contentOffset = CGPointMake(100, 0); //contentInset(在原有的基础上调整内容滚动区域的大小) //_scrollView.contentInset = UIEdgeInsetsMake(-100, 0, 0, 0); //锁定方向(当系统识别滚动方向的时候，会把另外一个方向锁定，如果识别不了，就不锁定方向) _scrollView.directionalLockEnabled = YES; //反弹效果(默认为yes) _scrollView.bounces = YES; //默认是no，假如是yes并且bounces是yes,甚至如果内容大小小于bounds的时候，允许垂直拖动 _scrollView.alwaysBounceVertical = YES; //分页（默认no） _scrollView.pagingEnabled = YES; //滚动(默认yes允许滚动) _scrollView.scrollEnabled = YES; //滚动条 //showsHorizontalScrollIndicator默认yes 显示 _scrollView.showsHorizontalScrollIndicator = NO; //滚动条滚动的范围(垂直滚动条滚动范围上下各缩小50) _scrollView.scrollIndicatorInsets = UIEdgeInsetsMake(50, 0, 50, 0); //样式 _scrollView.indicatorStyle = UIScrollViewIndicatorStyleWhite; // Do any additional setup after loading the view, typically from a nib.&#125; 方法- (void)viewDidLoad &#123; [super viewDidLoad]; //创建并添加scrollView UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(100, 200, 200, 300)]; [self.view addSubview:scrollView]; scrollView.backgroundColor = [UIColor redColor]; //设置内容视图的大小 scrollView.contentSize = CGSizeMake(375, 667); //设置内容视图 UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 375, 667)]; imageView.image = [UIImage imageNamed:@&quot;new_feature_1&quot;]; [scrollView addSubview:imageView]; _imageView = imageView; //设置代理 scrollView.delegate = self; //[self performSelector:@selector(changeScrollViewContentOffSet:) withObject:scrollView afterDelay:3]; //设置缩放内容视图的缩放比例范围 scrollView.minimumZoomScale = 0.5; scrollView.maximumZoomScale = 1.5; //当缩放比例超出范围之后，是否有反弹效果（no:不会超出范围，yes:超出范围之后反弹） scrollView.bouncesZoom = YES; //属性设置滚动至顶部 //scrollView.scrollsToTop = YES; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)changeScrollViewContentOffSet:(UIScrollView *)scrollView&#123; [scrollView setContentOffset:CGPointMake(0, 300) animated:YES];&#125;#if 0#pragma mark -UIScrollViewDelegate 滚动//当scrollView滚动的时候，不停调用（可以监听scrollView的contentOffset）- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; //NSLog(@&quot;%@&quot;,NSStringFromCGPoint(scrollView.contentOffset)); //NSLog(@&quot;decelerating：%d&quot;,scrollView.decelerating); //NSLog(@&quot;dragging：%d&quot;,scrollView.dragging); //NSLog(@&quot;tracking:%d&quot;,scrollView.tracking); NSLog(@&quot;%s&quot;,__func__);&#125;//开始拖动的时候调用- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123; //NSLog(@&quot;tracking:%d&quot;,scrollView.tracking); NSLog(@&quot;%s&quot;,__func__);&#125;// called on finger up if the user dragged. velocity is in points/millisecond. targetContentOffset may be changed to adjust where the scroll view comes to rest//将要结束拖动- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset &#123;// NSLog(@&quot;velocity:%@&quot;,NSStringFromCGPoint(velocity));// NSLog(@&quot;targetContentOffset:%@&quot;,NSStringFromCGPoint(*targetContentOffset)); //强制设置scrollView的偏移量 //*targetContentOffset = CGPointMake(0, 200); NSLog(@&quot;%s&quot;,__func__);&#125;// 已经结束拖动- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; //NSLog(@&quot;dragging：%d&quot;,scrollView.dragging); NSLog(@&quot;%s&quot;,__func__);&#125;//将要开始减速- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView&#123; //NSLog(@&quot;decelerating：%d&quot;,scrollView.decelerating); NSLog(@&quot;%s&quot;,__func__);&#125;//减速完成（停止）- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; //NSLog(@&quot;contentOffset:%@&quot;,NSStringFromCGPoint(scrollView.contentOffset)); NSLog(@&quot;%s&quot;,__func__);&#125;// called when setContentOffset/scrollRectVisible:animated: finishes. not called if not animating- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView&#123; NSLog(@&quot;%s&quot;,__func__);&#125;#endif#pragma mark -UIScrollViewDelegate(缩放)//指定缩放视图- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView&#123; NSLog(@&quot;%s,zooming:%d&quot;,__func__,scrollView.zooming); return _imageView;&#125;//缩放之前调用- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view &#123; NSLog(@&quot;%s,zooming:%d&quot;,__func__,scrollView.zooming);&#125;//完成缩放- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view atScale:(CGFloat)scale&#123; NSLog(@&quot;%s,zooming:%d&quot;,__func__,scrollView.zooming);&#125;//缩放时调用- (void)scrollViewDidZoom:(UIScrollView *)scrollView&#123; NSLog(@&quot;%s,zooming:%d&quot;,__func__,scrollView.zooming);&#125;#pragma mark -UIScrollViewDelegate(滚动至顶部)//允许滚动至顶部- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView&#123; return YES;&#125;//已经滚动至顶部- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView&#123; NSLog(@&quot;加载新数据，刷新界面&quot;);&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>UI</category>
        <category>UIScrollView</category>
      </categories>
      <tags>
        <tag>UIScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS_App跳转设置]]></title>
<url>../../../../../../../../2017/11/21/iOS-App跳转设置/</url>
    <content type="text"><![CDATA[跳到更多设置界面除了跳到WiFi设置界面，能不能跳到其他的设置界面呢？比如：定位服务、FaceTime、音乐等等。都是可以的，一起来看看如何实现的 跳到这些界面的参数配置： ##定位服务 用户关闭了定位,APP里面提示打开定位服务点击到设置界面设置，直接跳到定位服务设置界面= //定位服务设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=LOCATION_SERVICES&quot;];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; FaceTim//FaceTime设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=FACETIME&quot;];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; 音乐//音乐设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=MUSIC&quot;];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; 蓝牙设置界面//蓝牙设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=Bluetooth&quot;];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; iCloud设置界面//iCloud设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=CASTLE&quot;];if ([[UIApplication sharedApplication] canOpenURL:url]&#123; [[UIApplication sharedApplication] openURL:url];&#125; other设置界面只需要prefs:root=后面的值即可可以跳到这些界面的参数配置：r About — prefs:root=General&amp;path=AboutAccessibility — prefs:root=General&amp;path=ACCESSIBILITYAirplane Mode On — prefs:root=AIRPLANE_MODEAuto-Lock — prefs:root=General&amp;path=AUTOLOCKBrightness — prefs:root=BrightnessBluetooth — prefs:root=General&amp;path=BluetoothDate &amp; Time — prefs:root=General&amp;path=DATE_AND_TIMEFaceTime — prefs:root=FACETIMEGeneral — prefs:root=GeneralKeyboard — prefs:root=General&amp;path=KeyboardiCloud — prefs:root=CASTLEiCloud Storage &amp; Backup — prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUPInternational — prefs:root=General&amp;path=INTERNATIONALLocation Services — prefs:root=LOCATION_SERVICESMusic — prefs:root=MUSICMusic Equalizer — prefs:root=MUSIC&amp;path=EQMusic Volume Limit — prefs:root=MUSIC&amp;path=VolumeLimitNetwork — prefs:root=General&amp;path=NetworkNike + iPod — prefs:root=NIKE_PLUS_IPODNotes — prefs:root=NOTESNotification — prefs:root=NOTIFICATIONS_IDPhone — prefs:root=PhonePhotos — prefs:root=PhotosProfile — prefs:root=General&amp;path=ManagedConfigurationListReset — prefs:root=General&amp;path=ResetSafari — prefs:root=SafariSiri — prefs:root=General&amp;path=AssistantSounds — prefs:root=SoundsSoftware Update — prefs:root=General&amp;path=SOFTWARE_UPDATE_LINKStore — prefs:root=STORETwitter — prefs:root=TWITTERUsage — prefs:root=General&amp;path=USAGEVPN — prefs:root=General&amp;path=Network/VPNWallpaper — prefs:root=WallpaperWi-Fi — prefs:root=WIFI]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS_Safari跳转App]]></title>
<url>../../../../../../../../2017/11/21/iOS-Safari-跳转App/</url>
    <content type="text"><![CDATA[Safari跳转到App##App中定义一个URL协议 TARGETS -&gt; info -&gt; URL Types -&gt; 添加一个URL协议 URL Schemes字段就是你这个APP的特殊标示，indentifier:这个URL协议的标示。一个APP可以拥有多个URL协议下面的两个字段可为空。最后再运行一下你的APP。 浏览里访问打开Safari浏览器，在输入在地址栏输入：myapp://然后回车 Safari跳回到APP时传一些参数比如在Safari浏览器的地址了输入：myapp://myappTest，用下面的方法获取到该参数之后就看自己的操作了 在appdelegate.m文件中写下如下方法如果iOS版本低于9.0，会在下面方法接受到在地址栏输入的字符串- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; [[[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@&quot;sourceApplication-&gt;%@&quot;, [url absoluteString]] message:nil delegate:nil cancelButtonTitle:@&quot;ok&quot; otherButtonTitles:nil] show]; return YES;&#125;如果iOS版本是9.0及以上的，会在下面方法接受到在地址栏输入的字符串- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options&#123; [[[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@&quot;openURL-&gt;%@&quot;, [url absoluteString]] message:nil delegate:nil cancelButtonTitle:@&quot;ok&quot; otherButtonTitles:nil] show]; return YES;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
      <tags>
        <tag>Func</tag>
        <tag>跳转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func- Universal Links通用链接]]></title>
<url>../../../../../../../../2017/11/21/iOS-Func- Universal Links通用链接/</url>
    <content type="text"><![CDATA[Universal Links简介 iOS9之前 iOS9之前,对于从各种从浏览器,Safari、UIWebView或者 WKWebView中唤醒APP的需求,我们通常只能使用scheme.首先是app中注册某个scheme 在iOS 9以后 通过Universal Link，将App 与网页端建立连接桥，可以从Safari 或者其他前端浏览器来识别并唤醒App，甚至是微信环境下也可以冲破障碍 官方的说明文档–&gt; Universal Link的优点 唯一性: 不像自定义的scheme,因为它使用标准的http/https链接到你的web站点,所以它不会被其它的app所声明.另外,Custom URL scheme 因为是自定义的协议，所以在没有安装 app 的情况下是无法直接打开的，而 universal links 本身是一个 HTTP/HTTPS 链接，所以有更好的兼容性 安全: 当用户的手机上安装了你的app,那么iOS将去你的网站上去下载你上传上去的说明文件(这个说明文件声明了你的app可以打开哪些类型的http链接).因为只有你自己才能上传文件到你网站的根目录,所以你的网站和你的app之间的关联是安全的. 可变: 当用户手机上没有安装你的app的时候,Universal Links也能够工作.如果你愿意,在没有安装你的app的时候,用户点击链接,会在safari中展示你网站的内容. 简单: 一个URL链接,可以同时作用于网站和ap 私有 其它app可以在不需要知道你的app是否安装了的情况下和你的app相互通信 需求 分享页面中，我们经常会看到在页面的顶端或者底部遇到有【打开App】或者【下载App】这样的按钮。 比较友好的产品，会做设备识别，以及检测APP是否安装，来做打开或者下载App 的需求但是在微信中，这方面做的比较恶心，微信下面几乎是全面屏蔽了唤起原生App 的功能 Universal Link 实现条件 域名 有一个域名,且这个域名的网站需要支持https,然后拥有网站的上传到根目录的权限(这个权限是为了上传一个apple指定的文件) 支持Universal Links(通用链接) 创建一个json格式的命名为apple-app-site-association文件 注意这个文件必须没有后缀名,文件名必须为: apple-app-site-association &#123; "applinks": &#123; "apps": [], "details": [ &#123; "appID": "Prefix +点 +BundleID", "paths": [ "/html/1/*", "/*"], &#125;, ] &#125;&#125; Prefix 和 BundleID paths:根据 paths 键设定一个你的app支持的路径列表,只有这些指定的路径的链接,才能被app所处理,举个例子:如果你的网站是www.XXXX.com,你的path写的是”/support/“,那么当用户点击www.yohunl.com/support/myDoucument,就可以进入你的app了,相反www.yohunl.com/other 就不会.path是大小写敏感的! 号表示任意路径. 服务器服务器配置 准备独立域名一级域名，二级域名均可。SSL 证书 为服务器配置HTTPS 用的SSL 证书上传签名好的JSON 配置文件 新建JSON文件新建一个JSON文件，不需要后缀名，内容输入以下代码： appID:相关内容可以在Developer 中心找到相关的内容。如图，前半部分为Prefix 后半部分为ID，即你的App 的bundle id，两者通过.相连paths:用来唤醒App 所需要指定的JSON文件在服务器中的路径。用”/* “ 是根目录，而/html 则是指html目录下的注意：这里的AppID中前半部分，在App 转让主体后会改变，需重新更新填好后保存为apple-app-site-association 名，上传到域名指向的服务器根目录。 &#123; "applinks": &#123; "apps": [], "details": [ &#123; "appID": "5B5Q4xxxx.com.xxxx.xxxx", "paths": [ "/html/1/*", "/*"] &#125;, ] &#125;&#125; 上传传该文件apple-app-site-association 上传传该文件apple-app-site-association到你的域名所对应的网站的根目录下(其实也不一定是根目录,例如ghost博客站点,就没有根目录一说,它就需要放在相应的主题目录下) 这一步是为了苹果能从https://你的域名/apple-app-site-associationxh获取到你上传的apple-app-site-association文件.上传完后,自己先访问一下,看看是否能够获取到,用我的做例子,https://yohunl.com/apple-app-site-association ,当你点击这个链接,应该是下载apple-app-site-association文件.验证该文件是否合法,苹果为了方便开发者,提供了一个网页来验证我们编写的这个apple-app-site-association是否合法有效,验证网址,进入网站进行验证 App配置工程文件配置 在工程文件中，找到Targets - Capabilities - Associated Domains 将开关选为On，并添加你的域名， 格式为 applinks: + 后台给的域名.com applinks: + www.后台给的域名.com iOS移动端的代码- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler&#123; if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb]) &#123; NSString *url = userActivity.webpageURL.description; // 这里可以通过拆分url 来传入参数，达到跳转原生页面的功能，如跳转某商品页 [UIApplication sharedApplication] openURL:webpageURL]; &#125; return YES;&#125; h5网页配置 h5网页中对需要唤起App 的按钮或者控件添加点击事件，事件的函数代码如下: function wakeUpApp()&#123; if (navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) &#123; var loadDateTime = new Date(); window.setTimeout(function() &#123; var timeOutDateTime = new Date(); if (timeOutDateTime - loadDateTime &lt; 5000) &#123; window.location.href = "http://a.app.qq.com/o/simple.jsp?pkgname=你的应用宝BundleID"; &#125; else &#123; window.close(); &#125; &#125;, 25); window.location.href = "https://yourdomainname.com/"; &#125; else if (navigator.userAgent.match(/android/i)) &#123; var state = null; try &#123; state = window.open("apps custom url schemes ", '_blank'); &#125; catch(e) &#123;&#125; if (state) &#123; window.close(); &#125; else &#123; window.location.href = "要跳转的页面URL"; &#125; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MarkDomn语法]]></title>
<url>../../../../../../../../2017/11/21/MarkDomn-语法/</url>
    <content type="text"><![CDATA[目录效果生成目录* [1.语法示例](#1)* [1.1图片](#1.1) * [1.2换行](#1.2)* [1.3强调](#1.3) * 字体h1&gt;h2&gt;h3.... &lt;h2 id=&quot;1&quot;&gt;目录标题&lt;/h2&gt; 效果 1.h2比h1字体小 1.1图片 1.2换行 1.3强调 页面内跳转锚 放在 目的地定义一个锚(id)： 跳转markdown语法[点击跳转--&gt;](#index)]]></content>
      <categories>
        <category>Tool</category>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDomn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS_App_代码规范]]></title>
<url>../../../../../../../../2017/11/20/iOS-App_Code-代码规范/</url>
    <content type="text"><![CDATA[iOS编码规范#命名 变量命名 首字母小写，驼峰法则UI控件（描述+控件类型） priceLabel或priceLab 注释也要写 最好对齐 @property (nonatomic, strong) UIButton *collectsImgView; //合集 - 图标@property (nonatomic, strong) UILabel *collectsThemeLab; //合集 - 主题@property (nonatomic, strong) UILabel *collectsAuthorLab; //合集 - 作者 方法命名 首字母小写，驼峰法则 public method 规则： 方法用途单词_方法 一般的方法 - (void)show_editBtnOnOneViewC:(OneViewC *)oneViewC editBtn:(UIButton *)editBtn.....跳转 push_更新数据 update_collectList删除数据 delete_collectList private method 规则：不加下划线 不需要and： nameStr:(NSstring)nameStr - (void)pushOnewViewC:(OnewViewC *)onewViewC - nameStr:(NSstring)nameStr &#123;&#125; 扩展或封装方法 规则：以FF或ff开头 FanFan简写 - (void)ff_editOnOneViewC:(oneViewC)oneViewC isOpen:(BOOL) isOpen 少用#define预处理指令，多用类型常量 预处理指令命名 （字母全大写，以”_”分割） #define NSString * APP_ROOT_DIR @"xxx" 常量命名 （字母全大写，”k”开头） static NSString * const kAPPROOTDIR = @"xxx"; 资源文件中变量命名 全小写，”“分割模块： 开发功能模块外 nav tab login refresh share hud common(公有)格式：“模块类别状态描述” 状态可不要目前版本我们以模块作为文件夹 ，后面的按照这个4个 personal_btn_un_select.pngpersonal_btn_name_pngnav_btn_left.pngnav_imgView_lright.pngtab_item_un_select.pngtab_item_select.png 能用糖衣语法的尽量用糖衣语法，使用时注意nil报错。NSMutableArray = @[].mutableCopy;NSString *name = dic[@"name"];NSArray *array= @[item1, item2]; 用前缀避免命名空间冲突。大多数的自定制，都需要用前缀比如创建有读界面 Have (文件夹) ViewC(文件夹) HaveReadViewC.h View HaveReadView.h Model HaveReadModel.h Cell HaveReadCell.h 委托Delegate的定义和使用放在对应类的.h文件中，命名为该类名+Delegate，//定义代理HaveReadViewCDelegate ==&gt;HaveReadViewC + DelegateHaveReadCellDelegate ==&gt; HaveReadCell + Delegate//声明@property (nonatomic, weak) id &lt;ArticleHeadTableUrlDelegate&gt; delegate;//必须加判断！！！if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(push_safariWithUrl:)]) &#123; [_delegate pushSafariWithUrl:XXXXX]; &#125; 注释使用清晰而协调的命名方式+适当注释/** * @beif: 执行push操作 （ 简单明了就可以） * * @prama: namestr 名称 * @prama: isOpen 是否打开 0 = 关闭 1= 打开 * * @discussion: 注意这个方法子啊使用时候XXXXXXXX 等等 * **/ viewC里区块划分 h文件顶部:类的作用 类的注意一些内容 /** 订阅合集 分2种 我的订阅 xxxx 他的订阅 xxx */ 代理 @protocol XXXXXDelegate &lt;NSObject&gt;@required@optional- (void)delete_nameOnOne:(类 *)one nameStr:(NSString *) nameStr .... 代码结构 //#pragma ------------------ LifeCycle生命周期 -----------------//#pragma ------------------ Setter- (void)setNameLab:(UILable *)nameLab &#123; _nameLab = nameLab; &#125;//#pragma ------------------ Getter- (UIButton *)nameBtn:(UIButton *) nameBtn&#123; if(!_ nameBtn)&#123; nameBtn = ... [self addSubView: nameBtn]; &#125; return nameBtn;&#125;//#pragma ------------------ Layout ------------------//#pragma - nameBtn//#pragma - nameBtn - action //布局- (void)layoutSubviews;//#pragma ------------------ Plubic Method ------------------- (void)update_newViewC....- (BOOL)delete_editBtn.....//#pragma ------------------ private Method ------------------- (void)updateNewViewC....- (BOOL)deleteEditBtn.....//#pragma mark ------------- API ------------------//#pragma mark ------------- 代理//#pragma ------------------ Cell ------------------/** * @brief: 设置cell * * @prama: tableView * @prama: model * @prama: indexPath * */+( PersonalSubscribeCell *)show_cellOfTableView:(UITableView *)tableView model:(PersonalSubscribeModel *)model indexPath:(NSIndexPath *)indexPath 编程习惯 一个原则：能不做的事情，尽量不做，尽量少唤醒CPU，绝不能在UI线程中做耗时操作（如网络请求，数据库读写，文件读写等） Copy、mutableCopy要注意其关联的元素是否支持for循环 不要在循环中创建引用类型变量for循环中，用局部变量替代“array.count” @autoreleasepool@autoreleasepool&#123; for（）&#123; @autoreleasepool&#123;&#125; &#125;&#125; 引用变量声明放在循环外面，可以避免在栈内存中创建过多引用变量UserInfo userInfo;// 避免循环中每次都要调用userList.count取值int size = userList.count;for (int i = 0; i &lt; size; i++) &#123; userInfo = userList[i]; // do something...&#125;// 推荐for (int i = 0, max = userList.count; i &lt; max; i++) &#123; userInfo = userList[i]; // do something...&#125; NSString 在不需要外部任意修改的情况下，全部用Copy Block Block内部需要使用外部类变量的时候,防止循环引用切忌在block体中使用_name这样的变量，请使用self.name otehr 由于Objective-C是类型不安全的，注意加强类型判断、数据越界判断等等原则上不建议拷贝代码，同一段代码拷贝3次，必须抽离出一个方法，统一调用所有的系统的宏，都不得在任意地方乱定义，统一在FFConfig文件夹下的头文件中定义，并写好注释ViewController中的代码要分结构，多用#pragma mark - Life Circle对代码进行分区，ViewController中的代码分区可分为Life Circle、Request、Private、Delegate、Lazy等等ViewController中的代码尽量不要超过500行，注意优化 API 一级界面，API考虑离线缓存如果你用一句话无法将一个方法的内容表述清楚的话，这往往就意味着API的名字需要改进了；例如：removeAtPoint:就会比remove要清晰很多 提交代码规范提交代码时的描述必须写，且简明扼要就可以 我们的目标是让每一位小伙伴都能欣赏我们的代码]]></content>
      <categories>
        <category>iOS</category>
        <category>Code</category>
      </categories>
      <tags>
        <tag>iOS编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImag加载高分辨率图问题]]></title>
<url>../../../../../../../../2017/11/20/iOS-Lib-SDWebImag加载高分辨率图问题/</url>
    <content type="text"><![CDATA[SDWebImage_图片分辨率过高内存过高问题#高分辨率多图问题： 高分辨率图，导致内存飙升，卡顿，设置闪退,提示： Restore the connection to &quot;“XXX”的 iPod&quot; and run &quot;XXX&quot; again, or if &quot;XXX&quot; is still running, you can attach to it by selecting Debug &gt; Attach to Process &gt; XXX. 由于应用程序突然消耗了大量内存，然后再分配调度内存的时候，出现错误，致使系统将APP进程关闭。能够去查看一下是不是载入了大量的图片等等，或者哪里有消耗内存的地方改动一下。 分析SDWebimage， 1.判断本地是否有这张图2.二有的时候直接从本地取图片3.没有的时候去网络下载 if(imgStr.length&gt;0)&#123; [[SDImageCache sharedImageCache] queryDiskCacheForKey:imgStr done:^(UIImage *image, SDImageCacheType cacheType) &#123; if (image) &#123; [_oneImage setImage:image]; &#125;else&#123; [_oneImage sd_setImageWithURL:kNSUrl(imgStr) placeholderImage:IMGNAMED(@&quot;defaultAvatar2&quot;) options:SDWebImageRefreshCached completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123; if (image) &#123; [[SDImageCache sharedImageCache] storeImage:image forKey:imgStr toDisk:YES]; &#125; &#125;]; &#125; &#125;];&#125; 内部会调用下面这个方法- (UIImage *)diskImageForKey:(NSString *)key &#123; NSData *data = [self diskImageDataBySearchingAllPathsForKey:key]; if (data) &#123; UIImage *image = [UIImage sd_imageWithData:data]; image = [self scaledImageForKey:key image:image]; image = [UIImage decodedImageWithImage:image]; return image; &#125; else &#123; return nil; &#125; &#125; UIImage *image = [UIImage sd_imageWithData:data];图片取出来的时候就已经巨大无比，占用了很大的内存，导致内存来不及释放就崩溃 解决UIImage+MultiFormat这个类里面添加如下压缩方法，+(UIImage *)compressImageWith:(UIImage *)image &#123; float imageWidth = image.size.width; float imageHeight = image.size.height; float width = 640; float height = image.size.height/(image.size.width/width); float widthScale = imageWidth /width; float heightScale = imageHeight /height; // 创建一个bitmap的context // 并把它设置成为当前正在使用的context UIGraphicsBeginImageContext(CGSizeMake(width, height)); if (widthScale &gt; heightScale) &#123; [image drawInRect:CGRectMake(0, 0, imageWidth /heightScale , height)]; &#125; else &#123; [image drawInRect:CGRectMake(0, 0, width , imageHeight /widthScale)]; &#125; // 从当前context中创建一个改变大小后的图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); // 使当前的context出堆栈 UIGraphicsEndImageContext(); return newImage; &#125; 修改第三方方法#ifdef SD_WEBP else if ([imageContentType isEqualToString:@&quot;image/webp&quot;]) &#123; image = [UIImage sd_imageWithWebPData:data]; &#125; #endif else &#123; image = [[UIImage alloc] initWithData:data]; if (data.length/1024 &gt; 128) &#123; image = [self compressImageWith:image]; &#125; UIImageOrientation orientation = [self sd_imageOrientationFromImageData:data]; if (orientation != UIImageOrientationUp) &#123; image = [UIImage imageWithCGImage:image.CGImage scale:image.scale orientation:orientation]; &#125; 设置加载在SDWebImageDownloaderOperation的connectionDidFinishLoading方法里面的 UIImage *image = [UIImage sd_imageWithData:self.imageData]; //将等比压缩过的image在赋在转成data赋给self.imageData NSData *data = UIImageJPEGRepresentation(image, 1); self.imageData = [NSMutableData dataWithData:data]; 再配合 [[SDImageCache sharedImageCache] setValue:nil forKey:@&quot;memCache&quot;];（图片加载后使用）大功告成，亲测内存基本变化不大，自动释放也来得及]]></content>
      <categories>
        <category>iOS</category>
        <category>Lib</category>
        <category>SDWebImage</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UM_UMAnalytics友统计]]></title>
<url>../../../../../../../../2017/11/20/UM-UMAnalytics友盟统计/</url>
    <content type="text"><![CDATA[UMAnalytics友盟统计埋点官方 配置 文档—&gt; Go! 配置集成Appkey不同平台的应用禁止使用相同的Appkey，需要分开注册友盟后台的应用名与实际应用名和包名无关，建议命名为“应用名+平台（IOS/Android)” 使用 Cocoapods 安装 SDK //标准SDK，含IDFA pod &apos;UMengAnalytics&apos; 无IDFA版SDK（请根据需要选择其中一个） pod &apos;UMengAnalytics-NO-IDFA&apos; 基本功能集成配置 AppDelegate.m 主要包括填写Appkey，设置发送策略和填写渠道id三部分UMConfigInstance为SDK参数配置的实例类，只需要将其成员中标注为required的参数赋值，optional的为可选项。appKey: 统计分析-&gt;设置-&gt;应用信息ChannelId: 应用的渠道标识。默认为 @”App Store” 头文件：&quot;UMMobClick/MobClick.h&quot;- (BOOL])application:(UIApplication] *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; UMConfigInstance.appKey = @&quot;xxxxxxxxxxxxxx...&quot;; UMConfigInstance.ChannelId = @&quot;App Store&quot;; //仅适用于游戏场景，应用统计不用设置 UMConfigInstance.eSType = E_UM_GAME; //配置以上参数后调用此方法初始化SDK！ [MobClick startWithConfigure:UMConfigInstance];&#125; 页面的统计 runtime写交换方法不太好基础类可增加 - (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [MobClick beginLogPageView:@&quot;PageOne&quot;];//(&quot;PageOne&quot;为页面名称，可自定义) &#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [MobClick endLogPageView:@&quot;PageOne&quot;]; &#125; 自定义事件的统计 计数事件+计算事件 计数事件统计发生次数 某个事件发生的次数 [MobClick event:(NSString *)eventId]; 统计点击行为各属性被触发的次数[MobClick event:(NSString *)eventId attributes:(NSDictionary *)attributes];NSDictionary *dict = @&#123;@&quot;type&quot; : @&quot;book&quot;, @&quot;quantity&quot; : @&quot;3&quot;&#125;;[MobClick event:@&quot;purchase&quot; attributes:dict]; 计算事件 使用计算事件需要在后台添加事件时选择“计算事件” 统计数值型变量的值的分布 统计一个数值类型的连续变量（该变量必须为整数），用户每次触发的数值的分布情况，如事件持续时间、每次付款金额等，可以调用如下方法: +[MobClick event:(NSString *)eventId attributes:(NSDictionary *)attributes counter:(int)number]; 示例：购买《Swift Fundamentals》这本书，花了110元 [MobClick event:@&quot;pay&quot; attributes:@&#123;@&quot;book&quot; : @&quot;Swift Fundamentals&quot;&#125; counter:110]; 如果您使用的是V3.1.2以下版本的SDK，请使用下面的方法： -(void)umengEvent:(NSString *)eventId attributes:(NSDictionary *)attributes number:(NSNumber *)number&#123; NSString *numberKey = @&quot;__ct__&quot;; NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:attributes]; [mutableDictionary setObject:[number stringValue] forKey:numberKey]; [MobClick event:eventId attributes:mutableDictionary]; &#125; 示例：购买《Swift Fundamentals》这本书，花了110元 [self umengEvent:@&quot;pay&quot; attributes:@&#123;@&quot;book&quot; : @&quot;Swift Fundamentals&quot;&#125; number:@(110)];]]></content>
      <categories>
        <category>iOS</category>
        <category>UM</category>
        <category>UMAnalytics</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UI_JSBadgeView数字角标]]></title>
<url>../../../../../../../../2017/11/14/iOS-UIView-JSBadgeView数字角标/</url>
    <content type="text"><![CDATA[使用方法//在父控件上显示，//显示的位置TopRight self.badgeView = [[JSBadgeView alloc]initWithParentView:parentView alignment:JSBadgeViewAlignmentTopRight]; //位置 self.badgeView.badgePositionAdjustment = CGPointMake(-15, 10);//设置tag要辨别 self.badgeView.tag = 10086;//背景色self.badgeView.badgeBackgroundColor = [UIColor redColor]; //没有反光面self.badgeView.badgeOverlayColor = [UIColor clearColor]; //外圈的颜色，默认是白色 self.badgeView.badgeStrokeColor = [UIColor redColor]; 设置数字//1、用字符self.badgeView.badgeText = @&quot;1&quot;; //2、如果不显示就设置为空self.badgeView.badgeText = nil; //当更新数字时，最好刷新，不然由于frame固定的，数字为2位时，红圈变形 [self.badgeView setNeedsLayout];]]></content>
      <categories>
        <category>iOS</category>
        <category>UI</category>
        <category>UIView</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>iOS</tag>
        <tag>JSBadge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UILaebl_Shadow文字阴影]]></title>
<url>../../../../../../../../2017/11/14/iOS-UILabel-Shadow文字阴影/</url>
    <content type="text"><![CDATA[#方法1 设置UILabel中的shadowColor和shadowOffset属性 问题:阴影没有模糊效果，并且无法设置阴影的宽度等等，比较具有局限性 #方法2 NSShadow *shadow = [[NSShadow alloc]init]; shadow.shadowBlurRadius = 1; shadow.shadowOffset = CGSizeMake(0,1); shadow.shadowColor = [UIColor colorWithWhite:0 alpha:0.6]; NSAttributedString *attText = [[NSAttributedString alloc]initWithString:[NSString stringWithFormat:@&quot;%@浏览过&quot;,!model.read_num?@&quot;0&quot;:model.read_num] attributes:@&#123;NSShadowAttributeName:shadow&#125;]; cell.skimLab.attributedText = attText;]]></content>
      <categories>
        <category>iOS</category>
        <category>UI</category>
        <category>UILabel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Runtime实践:占位图]]></title>
<url>../../../../../../../../2017/11/13/iOS-RunTime-占位图/</url>
    <content type="text"><![CDATA[eqweqweqw23123123]]></content>
      <categories>
        <category>iOS</category>
        <category>RumTime</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS]]></title>
<url>../../../../../../../../2016/11/23/iOS/</url>
    <content type="text"><![CDATA[iOS多线程的锁]]></content>
      <categories>
        <category>iOS</category>
        <category>Refer</category>
      </categories>
  </entry>
</search>
