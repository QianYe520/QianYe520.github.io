<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift-Grammar-Protocol协议]]></title>
<url>../../../../../../../../2017/11/24/1/</url>
    <content type="text"><![CDATA[Protocol协议 协议 规定了用来实现某一特定功能所必须的方法和属性。任意能够满足协议要求的类型被称为遵循(conform)这个协议。类，结构体或枚举类型都可以遵循协议，并提供具体实现来完成协议定义的方法和功能 语法格式 语法 protol OneProtocol&#123;// 协议内容&#125; 要使类遵循某个协议，需要在类型名称后加上协议名称，中间以冒号:分隔，作为类型定义的一部分。遵循多个协议时，各协议之间用逗号,分隔 struct OneStructure: OneProtocol, TwoProtocol &#123; // 结构体内容&#125; 如果类在遵循协议的同时拥有父类，应该将 父类名 放在 协议名 之前，以逗号分隔 class OneClass: OneSuperClass, OneProtocol, TwoProtocol &#123; // 类的内容&#125; 对属性的规定 协议 用于指定特定的实例属性或类属性，而不是指定是存储型属性或计算型属性。此外还必须指明是只读的还是可读可写的。协议中的通常用var来声明变量属性，在类型声明后加上{ set get }来表示属性是可读可写的，只读属性则用{ get }来表示。 protocol classa &#123; var marks: Int &#123; get set &#125; var result: Bool &#123; get &#125; func attendance() -&gt; String func markssecured() -&gt; String&#125;protocol classb: classa &#123; var present: Bool &#123; get set &#125; var subject: String &#123; get set &#125; var stname: String &#123; get set &#125;&#125;class classc: classb &#123; var marks = 96 let result = true var present = false var subject = "Swift 协议" var stname = "Protocols" func attendance() -&gt; String &#123; return "The \(stname) has secured 99% attendance" &#125; func markssecured() -&gt; String &#123; return "\(stname) has scored \(marks)" &#125;&#125;let studdet = classc()studdet.stname = "Swift"studdet.marks = 98studdet.markssecured()print(studdet.marks)print(studdet.result)print(studdet.present)print(studdet.subject)print(studdet.stname)以上程序执行输出结果为98truefalseSwift 协议Swift 对 Mutating 方法的规定 有时需要在方法中改变它的实例。例如：值类型（结构体，枚举）的实例方法中，将mutating关键字作为函数的前缀，写在func之前，表示可以在该方法中修改它所属的实例及其实例属性的值 protocol daysofaweek &#123; mutating func show()&#125;enum days: daysofaweek &#123; case sun, mon, tue, wed, thurs, fri, sat mutating func show() &#123; switch self &#123; case .sun: self = .sun print("Sunday") case .mon: self = .mon print("Monday") case .tue: self = .tue print("Tuesday") case .wed: self = .wed print("Wednesday") case .thurs: self = .thurs print("Wednesday") case .fri: self = .fri print("Wednesday") case .sat: self = .sat print("Saturday") default: print("NO Such Day") &#125; &#125;&#125;var res = days.wedres.show()程序执行输出结果为：Wednesday 对构造器的规定 协议可以要求它的遵循者实现指定的构造器。像书写普通的构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体，语法如下： protocol SomeProtocol &#123; init(someParameter: Int)&#125; 实例 protocol tcpprotocol &#123; init(aprot: Int)&#125; 四、协议构造器规定在类中的实现 你可以在遵循该协议的类中实现构造器，并指定其为类的指定构造器或者便利构造器。在这两种情况下，你都必须给构造器实现标上”required”修饰符： class SomeClass: SomeProtocol &#123; required init(someParameter: Int) &#123; // 构造器实现 &#125;&#125;protocol tcpprotocol &#123; init(aprot: Int)&#125;class tcpClass: tcpprotocol &#123; required init(aprot: Int) &#123; &#125;&#125; 施用required修饰符可以保证：所有的遵循该协议的子类，同样能为构造器规定提供一个显式的实现或继承实现。如果一个子类重写了父类的指定构造器，并且该构造器遵循了某个协议的规定，那么该构造器的实现需要被同时标示required和override修饰符： protocol tcpprotocol &#123; init(no1: Int)&#125;class mainClass &#123; var no1: Int // 局部变量 init(no1: Int) &#123; self.no1 = no1 // 初始化 &#125;&#125;class subClass: mainClass, tcpprotocol &#123; var no2: Int init(no1: Int, no2 : Int) &#123; self.no2 = no2 super.init(no1:no1) &#125; // 因为遵循协议，需要加上&quot;required&quot;; 因为继承自父类，需要加上&quot;override&quot; required override convenience init(no1: Int) &#123; self.init(no1:no1, no2:0) &#125;&#125;let res = mainClass(no1: 20)let show = subClass(no1: 30, no2: 50)print(&quot;res is: \(res.no1)&quot;)print(&quot;res is: \(show.no1)&quot;)print(&quot;res is: \(show.no2)&quot;)以上程序执行输出结果为：res is: 20res is: 30res is: 50 五、协议类型尽管协议本身并不实现任何功能，但是协议可以被当做类型来使用。协议可以像其他普通类型一样使用，使用场景: 作为函数、方法或构造器中的参数类型或返回值类型 作为常量、变量或属性的类型 作为数组、字典或其他容器中的元素类型 实例 protocol Generator &#123; associatedtype members func next() -&gt; members?&#125;var items = [10,20,30].makeIterator()while let x = items.next() &#123; print(x)&#125;for lists in [1,2,3].map( &#123;i in i*5&#125;) &#123; print(lists)&#125;print([100,200,300])print([1,2,3].map(&#123;i in i*10&#125;))以上程序执行输出结果为：10203051015[100, 200, 300][10, 20, 30] 六、在扩展中添加协议成员我们可以可以通过扩展来扩充已存在类型( 类，结构体，枚举等)。扩展可以为已存在的类型添加属性，方法，下标脚本，协议等成员。 protocol AgeClasificationProtocol &#123; var age: Int &#123; get &#125; func agetype() -&gt; String&#125;class Person &#123; let firstname: String let lastname: String var age: Int init(firstname: String, lastname: String) &#123; self.firstname = firstname self.lastname = lastname self.age = 10 &#125;&#125;extension Person : AgeClasificationProtocol &#123; func fullname() -&gt; String &#123; var c: String c = firstname + &quot; &quot; + lastname return c &#125; func agetype() -&gt; String &#123; switch age &#123; case 0...2: return &quot;Baby&quot; case 2...12: return &quot;Child&quot; case 13...19: return &quot;Teenager&quot; case let x where x &gt; 65: return &quot;Elderly&quot; default: return &quot;Normal&quot; &#125; &#125;&#125; 七、协议的继承协议能够继承一个或多个其他协议，可以在继承的协议基础上增加新的内容要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔： protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123; // 协议定义&#125; 实例 protocol Classa &#123; var no1: Int &#123; get set &#125; func calc(sum: Int)&#125;protocol Result &#123; func print(target: Classa)&#125;class Student2: Result &#123; func print(target: Classa) &#123; target.calc(1) &#125;&#125;class Classb: Result &#123; func print(target: Classa) &#123; target.calc(5) &#125;&#125;class Student: Classa &#123; var no1: Int = 10 func calc(sum: Int) &#123; no1 -= sum print(&quot;学生尝试 \(sum) 次通过&quot;) if no1 &lt;= 0 &#123; print(&quot;学生缺席考试&quot;) &#125; &#125;&#125;class Player &#123; var stmark: Result! init(stmark: Result) &#123; self.stmark = stmark &#125; func print(target: Classa) &#123; stmark.print(target) &#125;&#125;var marks = Player(stmark: Student2())var marksec = Student()marks.print(marksec)marks.print(marksec)marks.print(marksec)marks.stmark = Classb()marks.print(marksec)marks.print(marksec)marks.print(marksec)以上程序执行输出结果为：学生尝试 1 次通过学生尝试 1 次通过学生尝试 1 次通过学生尝试 5 次通过学生尝试 5 次通过学生缺席考试学生尝试 5 次通过学生缺席考试 八、类专属协议你可以在协议的继承列表中,通过添加class关键字,限制协议只能适配到类（class）类型。该class关键字必须是第一个出现在协议的继承列表中，其后，才是其他继承协议。格式如下： protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123; // 协议定义&#125; 实例 protocol TcpProtocol &#123; init(no1: Int)&#125;class MainClass &#123; var no1: Int // 局部变量 init(no1: Int) &#123; self.no1 = no1 // 初始化 &#125;&#125;class SubClass: MainClass, TcpProtocol &#123; var no2: Int init(no1: Int, no2 : Int) &#123; self.no2 = no2 super.init(no1:no1) &#125; // 因为遵循协议，需要加上&quot;required&quot;; 因为继承自父类，需要加上&quot;override&quot; required override convenience init(no1: Int) &#123; self.init(no1:no1, no2:0) &#125;&#125;let res = MainClass(no1: 20)let show = SubClass(no1: 30, no2: 50)print(&quot;res is: \(res.no1)&quot;)print(&quot;res is: \(show.no1)&quot;)print(&quot;res is: \(show.no2)&quot;)以上程序执行输出结果为：res is: 20res is: 30res is: 50 九、协议合成Swift 支持合成多个协议，这在我们需要同时遵循多个协议时非常有用。语法格式如下： protocol Stname &#123; var name: String &#123; get &#125;&#125;protocol Stage &#123; var age: Int &#123; get &#125;&#125;struct Person: Stname, Stage &#123; var name: String var age: Int&#125;func show(celebrator: Stname &amp; Stage) &#123; print(&quot;\(celebrator.name) is \(celebrator.age) years old&quot;)&#125;let studname = Person(name: &quot;Priya&quot;, age: 21)print(studname)let stud = Person(name: &quot;Rehan&quot;, age: 29)print(stud)let student = Person(name: &quot;Roshan&quot;, age: 19)print(student)以上程序执行输出结果为：Person(name: &quot;Priya&quot;, age: 21)Person(name: &quot;Rehan&quot;, age: 29)Person(name: &quot;Roshan&quot;, age: 19) 十、检验协议的一致性你可以使用is和as操作符来检查是否遵循某一协议或强制转化为某一类型。 is操作符用来检查实例是否遵循了某个协议。 as?返回一个可选值，当实例遵循协议时，返回该协议类型;否则返回nil。 as用以强制向下转型，如果强转失败，会引起运行时错误。 实例 下面的例子定义了一个 HasArea 的协议，要求有一个Double类型可读的 area：protocol HasArea &#123; var area: Double &#123; get &#125;&#125;// 定义了Circle类，都遵循了HasArea协议class Circle: HasArea &#123; let pi = 3.1415927 var radius: Double var area: Double &#123; return pi * radius * radius &#125; init(radius: Double) &#123; self.radius = radius &#125;&#125;// 定义了Country类，都遵循了HasArea协议class Country: HasArea &#123; var area: Double init(area: Double) &#123; self.area = area &#125;&#125;// Animal是一个没有实现HasArea协议的类class Animal &#123; var legs: Int init(legs: Int) &#123; self.legs = legs &#125;&#125;let objects: [AnyObject] = [ Circle(radius: 2.0), Country(area: 243_610), Animal(legs: 4)]for object in objects &#123; // 对迭代出的每一个元素进行检查，看它是否遵循了HasArea协议 if let objectWithArea = object as? HasArea &#123; print(&quot;面积为 \(objectWithArea.area)&quot;) &#125; else &#123; print(&quot;没有面积&quot;) &#125;&#125;以上程序执行输出结果为：面积为 12.5663708面积为 243610.0没有面积]]></content>
      <categories>
        <category>Swift</category>
        <category>Grammar</category>
        <category>Protocol</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift-Develpe文档]]></title>
<url>../../../../../../../../2017/11/23/1/</url>
    <content type="text"><![CDATA[swift4苹果开发者中心 swift 语法]]></content>
      <categories>
        <category>Swift</category>
        <category>Document</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Lib-YYKit-YYmodel]]></title>
<url>../../../../../../../../2017/11/23/iOS-Lib-YYKit-YYmodel/</url>
    <content type="text"></content>
      <categories>
        <category>iOS</category>
        <category>Lib</category>
        <category>YYKit</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FF-Code-Appdelegate激光跳转]]></title>
<url>../../../../../../../../2017/11/23/FF-Code-Appdelegate激光跳转/</url>
    <content type="text"></content>
      <categories>
        <category>FF</category>
        <category>Code</category>
        <category>Appdelegate</category>
      </categories>
      <tags>
        <tag>推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blog-配置]]></title>
<url>../../../../../../../../2017/11/23/Blog-配置/</url>
    <content type="text"><![CDATA[博客配置01博客配置02]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Tool-FastLane自动化发布工具+上传Bugly]]></title>
<url>../../../../../../../../2017/11/23/iOS-Tool-FastLane自动化发布工具+上传Bugly/</url>
    <content type="text"><![CDATA[打包的流程 修改测试版本号 修改Build版本号 执行Archive 选择Adhoc导出IPA安装包文件 上传Bugly测试平台 分享测试链接二维码FastlaneFastlane本身包含两大模块，内核部分+ActionActionAction是Fastlane自动化流程中的最小执行单元，直观上来讲就是Fastfile脚本中的一个个命令，比如：git_pull，deliver，pod_install等等，而这些命令背后都对应其实是一个用Ruby编写的脚本 Fastlane 是一套用 Ruby 编写的 iOS 命令行工具集（后来也支持了 Android），主要组件包括： match / cert / sigh 协助管理代码签名 pem 自动生成 APNs 证书 scan 自动化测试 gym 自动化编译并打包生成签名的 .ipa 文件 snapshot / frameit 协助处理 iOS 屏幕快照 pilot 上传和管理 TestFlight deliver 将应用及其它信息上传到 App Store 而正是这些颗粒度极小的Action，根据自己需求组合成一个自动化的链条 安装 首先确保Xcode命令行工具是最新版本的 $ xcode-select --install 安装Fastlane: $ sudo gem install fastlane -NV 找到工程文件目录下执行 $ fastlane init 在执行“Your Apple ID” 这一步输入苹果开发者账号，fastlane 会自动获取工程文件名，目录等其他数据。这一步“Please confirm the above values”，确认信息，没问题则输入 y。然后，fastlane 会进行一系列的初始化操作，包括下载 App Store 上的元数据和截屏文件。等待初始化完成之后，工程目录下就多了一个 fastlane目录： $ cd fastlane &amp;&amp; lsAppfile Fastfile metadata report.xmlDeliverfile README.md screenshots 文件目录 metadata目录下存放整个元数据文件，包括关键词、版本更新日志、图标等. screenshots目录下存放应用截图 Appfile文件记录App的 bundle ID、Apple ID、Team ID三种信息. Fastfile脚本的核心执行文件.有几个默认的选项，可直接使用. report文件时每次执行fastlane时生成报告 安装fastlane成功后，首先拆解我们需要自动化的两个流程: 自动打包成Adhoc的安装包ipa文件 通过fastlane自动上传到bugly 自动化打包 自动化打包使用最多就是Fastlane中gym这个Action, 转为打包而生, 安装gym这个组件: $ sudo gem install gym cd项目根目录, 创建自动打包脚本: $ vim gym.sh 输入脚本内容: #!/bin/bash#计时SECONDS=0#假设脚本放置在与项目相同的路径下project_path=$(pwd)#取当前时间字符串添加到文件结尾now=$(date +"%Y_%m_%d_%H_%M_%S")#指定项目的scheme名称scheme="Xitu"#指定要打包的配置名configuration="Adhoc"#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数export_method='ad-hoc'#指定项目地址workspace_path="$project_path/Xitu.xcworkspace"#指定输出路径output_path="project_path/APP"#指定输出归档文件地址archive_path="$output_path/Xitu$&#123;now&#125;.xcarchive"#指定输出ipa地址ipa_path="$output_path/Xitu$&#123;now&#125;.ipa"#指定输出ipa名称ipa_name="Xitu$&#123;now&#125;.ipa"#获取执行命令时的commit messagecommit_msg="$1"#输出设定的变量值echo "===workspace path: $&#123;workspace_path&#125;==="echo "===archive path: $&#123;archive_path&#125;==="echo "===ipa path: $&#123;ipa_path&#125;==="echo "===export method: $&#123;export_method&#125;==="echo "===commit msg: $1==="#先清空前一次buildgym --workspace $&#123;workspace_path&#125; --scheme $&#123;scheme&#125; --clean --configuration $&#123;configuration&#125; --archive_path $&#123;archive_path&#125; --export_method $&#123;export_method&#125; --output_directory $&#123;output_path&#125; --output_name $&#123;ipa_name&#125;#输出总用时echo "===Finished. Total time: $&#123;SECONDS&#125;s===" 把如上脚本中Xitu改成你的项目名称即可. 为脚本执行提升权限 $ chmod +x gym.sh 执行一下脚本看一下打包效果: $ ./gym.sh 经过572s，Adhoc版本的ipa文件打包成功，我们在项目根目录下找到App目录： =========================================== #上传Bugly fastlane中定义action$ fastlane new_action 这时命令行会要求你输入自定义action名字，直接以bugly上传文件命名 $ upload_app_to_bugly wei wan]]></content>
      <categories>
        <category>iOS</category>
        <category>Tool</category>
        <category>FastLane</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Code-优化项目]]></title>
<url>../../../../../../../../2017/11/23/iOS-Code-优化项目/</url>
    <content type="text"><![CDATA[优化项目 结构与架构1.1 结构 这里说的结构大概有两点：1.文件目录分类 2.第三方库管理1.1.1 文件目录分类 为了方便管理，最好将Xcode中的项目展示目录与实际的存储目录保持一致此外，一般按业务模块分类,一级目录可以按照MVC格式，也可以按照业务模块划分用最普遍的Model View Controller架构举例]]></content>
      <categories>
        <category>iOS</category>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-Bug管理工具]]></title>
<url>../../../../../../../../2017/11/22/iOS-Func-Bug管理工具/</url>
    <content type="text"><![CDATA[#功能 非Crash Bug 在App内可截图添加描述并发送 Crash Bug 在App第二次启动时提取Crash log添加描述并发送 实现解释分析 bug 非Crash的Bug：字体不对、颜色不对、数据不对、布局不对 Crash Bug：系统Crash、处理signal场景交互 场景交互：发现非Crash Bug时候摇一摇手机，弹出邮件，图片带入邮件，点击发送即可。有Crash Bug的时候第二次启动App，弹出邮件，Crash log带入邮件，点击发送即可 使用 需要用到NSSetUncaughtExceptionHandler，MFMailComposeViewController，沙盒，NSFileManager实现截图的功能，考虑到并不是所有的页面都需要使用所以写在了分类里。需要用的时候直接引入头文件即可这三个方法分别在摇一摇的时候回调用，开始，需要，结束。他们的父类是UIResponsder在UIKit中 -(void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event&#123;&#125;-(void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event&#123;&#125;-(void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event&#123; [self screenShot];&#125;-(void)screenShot&#123; UIWindow *screen = [[UIApplication sharedApplication] keyWindow]; UIGraphicsBeginImageContext(screen.frame.size); [screen.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsGetCurrentContext(); NSData *screenData = UIImagePNGRepresentation(image); [screenData writeToFile:[NSHomeDirectory() stringByAppendingPathComponent:@"Library/Caches"] atomically:YES]; &#125; 发送邮件的功能 发送邮件的功能，也写在了分类里面，需要用的时候引入即可 @interface UIViewController (send)&lt;MFMailComposeViewControllerDelegate&gt;//发送邮件的方法，传入标题，描述信息，data, 接收人-(void)sendMail:(MFMailComposeViewController*)mf andSubject:(NSString*)subject andMessageBody:(NSString*)message andData:(NSData*)data andRecipients:(NSArray*)recipients&#123; if([MFMailComposeViewController canSendMail])&#123; mf.mailComposeDelegate = self; [mf setSubject:subject]; [mf setToRecipients:recipients]; [mf addAttachmentData:data mimeType:@"image/jpeg" fileName:@"error"]; [mf setMessageBody:message isHTML:YES]; [self presentViewController:mf animated:YES completion:nil]; &#125;else&#123; [self alertView:@"不能调用邮箱" andDesc:@"请尝试下载App原生邮箱，并配置"]; &#125;&#125; MFMailComposeViewControllerDelegate的代理方法，可以在这个方法里面写一些回调-(void)mailComposeController:(MFMailComposeViewController *)controller didFinishWithResult:(MFMailComposeResult)result error:(NSError *)error&#123; switch (result) &#123; case MFMailComposeResultSent: [self alertView:@"发送成功" andDesc:nil]; self.success(); break; case MFMailComposeResultSaved: [self alertView:@"保存成功" andDesc:nil]; break; case MFMailComposeResultFailed: self.faild(); [self alertView:error.domain andDesc:[NSString stringWithFormat:@"%@",error.userInfo]]; break; case MFMailComposeResultCancelled: [self alertView:@"取消发送" andDesc:nil]; break; default: [self alertView:@"为什么不发送" andDesc:nil]; break; &#125; [self dismissViewControllerAnimated:YES completion:nil];&#125; 异常捕获这两个为函数方法，导入类名，直接可调用不用初始化void CrashExceptionHandler(void)&#123; NSSetUncaughtExceptionHandler(&amp;ExceptionLog);&#125;void ExceptionLog(NSException *exception)&#123; NSDate *date_current = [NSDate date]; NSDictionary *dictInfo = [[NSBundle mainBundle]infoDictionary]; NSString *name_App = [dictInfo objectForKey:@"CFBundleDisplayName"]; NSString *verson_App = [dictInfo objectForKey:@"CFBundleShortVersionString"]; NSString *build_App = [dictInfo objectForKey:@"CFBundleVersion"]; NSArray *ecp = exception.callStackSymbols; NSString *reason = [exception reason]; NSString *name = [exception name]; NSString *exceptionInfo = [NSString stringWithFormat: @"\n\n ******************************异常日志****************************** \n时间:%@\nApp名称:%@\nApp版本:%@\nBuild版本:%@\n异常名称:%@\n异常原因:%@\n堆栈信息:%@",date_current,name_App,verson_App,build_App,name,reason,ecp]; [CrashHandler saveLog:exceptionInfo andDate:date_current];#ifdef DEBUG NSLog(@"%@",exceptionInfo);#else#endif&#125;@implementation CrashHandler+(void)saveLog:(NSString *)crashLog andDate:(NSDate *)date&#123; NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)objectAtIndex:0] stringByAppendingString:@"/Crash"]; if(![[NSFileManager defaultManager]fileExistsAtPath:path]) &#123; [[NSFileManager defaultManager]createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:nil]; &#125; NSString *logPath = [path stringByAppendingFormat:@"/%@.log",date]; [crashLog writeToFile:logPath atomically:YES encoding:NSUTF8StringEncoding error:nil];&#125;@end 检测Crash log 功能在App打开的第一个页面去调用就好-(void)crashLog { NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)objectAtIndex:0] stringByAppendingString:@"/Crash"]; NSFileManager *mf = [NSFileManager defaultManager]; if(![mf fileExistsAtPath:path]) { return; } NSArray *array = [mf contentsOfDirectoryAtPath:path error:nil]; } Bug管理工具]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-Crash日志]]></title>
<url>../../../../../../../../2017/11/22/iOS-Func-Crash日志/</url>
    <content type="text"><![CDATA[获得crash日志产生/保存 程序崩溃时，系统会创建一份crash日志保存在设备上。 这份crash日志记录着应用程序崩溃时的信息，包含每个执行线程的栈调用信息（低内存闪退日志例外），对定位问题很有帮助 连接设备获取 可以连接设备，打开Xcode - Window - Organizer， 在左侧面板中选择Device Logs（可以选择具体设备的Device Logs或者Library下所有设备的Device Logs） 然后根据时间排序查看设备上的crash日志 已发布app通过iTunes Connect获取 可以通过iTunes Connect（Manage Your Applications - View Details - Crash Reports）获取用户的crash日志 不过这并不是100%有效的，而且大多数开发者并不依赖于此，因为这需要用户设备同意上传相关信息，详情可参见iOS: Providing Apple with diagnostics and usage information摘要 接入现有的crash收集工具获取通常接入现有的crash收集工具，或者自己编写一个进行自动化收集、解析和统计汇总 解析crash日志符号化解析 当获得一份crash日志时，需要将初始展示的十六进制地址等原始信息映射为源代码级别的方法名称和代码行数，使其对开发人员可读这个过程称为符号化解析。要成功地符号化解析一份crash日志，我们需要有对应的应用程序二进制文件以及符号（.dSYM）文件 -如果处于开发调试阶段，通常Xcode都能匹配到crash日志对应的二进制文件和符号文件，所以能够帮我们自动解析。 如果处于测试阶段，测试人员已经安装了不同的版本（比如alpha、beta版本），那么需要保存好对应版本的二进制文件和符号文件，以便在应用程序崩溃时对crash日志进行解析。对于这种场景下产生的crash日志，只需要将.crash文件、.app文件和.dSYM文件三者放在同一个目录下，然后将.crash文件拖放到Xcode - Window - Organizer中左侧面板Library下的Device Logs中，即可进行解析。 如果要提交发布，那么我们通常会先执行Clean，再Build，最后通过Product - Archive来打包。这样，Xcode会将二进制文件和符号文件归档在一起，可以通过Organizer中的Archives进行浏览 关于如何解析crash日志的讨论 分析crash日志 在分析一份crash日志之前，如果开发人员对于常见的错误类型有所了解，那定是极好的。 crash日志的产生来源于两种问题：违反iOS策略被干掉，以及自身的代码bug iOS策略低内存闪退 低内存闪退日志 前面提到大多数crash日志都包含着执行线程的栈调用信息 但是低内存闪退日志除外，这里就先看看低内存闪退日志是什么样的我们使用Xcode 5和iOS 7的设备模拟一次低内存闪退，然后通过Organizer查看产生的crash日志，可以发现Process和Type都为Unknown： 具体的日志内容如下 第一部分是崩溃信息，包括识别标识、软硬件信息和时间信息等。 第二部分是内存页分配信息，以及当前占用内存最多的进程，上图中为crashTypeDemo。 第三部分是具体的进程列表，描述着每个进程使用内存的情况以及当前状态。在较早的版本中可以在某些进程后面看到“jettisoned”字样，表明这些进程使用过多内存被终止了，而现在我们看到的是“vm-pageshortage”字样。 当iOS检测到内存过低时，它（的VM系统）会发出低内存警告通知，尝试回收一些内存；如果情况没有得到足够的改善，iOS会终止后台应用以回收更多内存；最后，如果内存还是不足，那么正在运行的应用可能会被终止掉。 所以，我们的应用应该合理地响应系统抛出来的低内存警告通知，对一些缓存数据和可重新创建的对象进行释放，同时要避免出现内存泄露等问题。 低内存闪退是由iOS策略决定终止应用程序运行的，同样基于iOS策略的还有Watchdog超时和用户强制退出 Watchdog超时 Apple的iOS Developer Library网站上，QA1693文档中描述了Watchdog机制，包括生效场景和表现。如果我们的应用程序对一些特定的UI事件（比如启动、挂起、恢复、结束）响应不及时，Watchdog会把我们的应用程序干掉，并生成一份响应的crash报告 这份crash报告的有趣之处在于异常代码：“0x8badf00d”，即“ate bad food” 如果说特定的UI事件比较抽象，那么用代码来直接描述的话，对应的就是（创建一个工程时Xcode自动生成的）UIApplicationDelegate的几个方法： 所以当遇到Watchdog日志时，可以检查下上图几个方法是否有比较重的阻塞UI的动作 QA1693举的例子是在主线程进行同步网络请求。如果我们是在公司的Wifi环境下使用则一切顺利，但当应用程序发布出去面向很大范围的用户，在各种网络环境下运行，则不可避免地会出现一片Watchdog超时报告。另一种可能出现问题的场景就是数据量比较大的情况下进行的数据库版本迁移（同样是在主线程上），这也是促使我写这篇总结的一个直接因素。 用户强制退出 一看到“用户强制退出”，首先可能想到的双击Home键，然后关闭应用程序。不过这种场景是不会产生crash日志的，因为双击Home键后，所有的应用程序都处于后台状态，而iOS随时都有可能关闭后台进程，所以这种场景没有crash日志。 另一种场景是用户同时按住电源键和Home键，让iPhone重启。这种场景会产生日志（仅验证过一次），但并不针对特定应用程序。 这里指的“用户强制退出”场景，是稍微比较复杂点的操作：先按住电源键，直到出现“滑动关机”的界面时，再按住Home键，这时候当前应用程序会被终止掉，并且产生一份相应事件的crash日志 通常，用户应该是遇到应用程序卡死，并且影响到了iOS响应，才会进行这样的操作——不过感觉这操作好高级，所以这样的crash日志应该比较少见 常见错误标识Exception codes上面“用户强制退出”的crash日志中的Exception Codes是“0xdeadfa11”，再上面“Watchdog超时”的crash日志中的Exception Codes是“0x8badf00d”，这些都是特有的Exception codes。根据官方文档描述，至少有以下几种特定异常代码： 0x8badf00d错误码：Watchdog超时，意为“ate bad food”。 0xdeadfa11错误码：用户强制退出，意为“dead fall”。 0xbaaaaaad错误码：用户按住Home键和音量键，获取当前内存状态，不代表崩溃。0xbad22222错误码：VoIP应用（因为太频繁？）被iOS干掉。 0xc00010ff错误码：因为太烫了被干掉，意为“cool off”。 0xdead10cc错误码：因为在后台时仍然占据系统资源（比如通讯录）被干掉，意为“dead lock” Exception types查看我们的crash分析报告邮件，会发现最经常遇到的错误类型是SEGV（Segmentation Violation，段违例），表明内存操作不当，比如访问一个没有权限的内存地址。当我们收到SIGSEGV信号时，可以往以下几个方面考虑：访问无效内存地址，比如访问Zombie对象；尝试往只读区域写数据；解引用空指针；使用未初始化的指针；栈溢出；此外，还有其它常见信号：SIGABRT：收到Abort信号，可能自身调用abort()或者收到外部发送过来的信号；SIGBUS：总线错误。与SIGSEGV不同的是，SIGSEGV访问的是无效地址（比如虚存映射不到物理内存），而SIGBUS访问的是有效地址，但总线访问异常（比如地址对齐问题）；SIGILL：尝试执行非法的指令，可能不被识别或者没有权限；SIGFPE：Floating Point Error，数学计算相关问题（可能不限于浮点计算），比如除零操作；SIGPIPE：管道另一端没有进程接手数据 代码bug此外，比较常见的崩溃基本都源于代码bug，比如数组越界、插空、多线程安全性、访问野指针、发送未实现的selector等。如果引入Core Data，则又有另外一些常见问题，不过这是另一个话题了。 遇到这些bug时，都有比较清楚的错误原因说明，比如“index 0 beyond bounds for empty array”等。需要稍微注意点的是多线程问题，当一时找不到解决思路时，不妨往多线程方面考虑下 iOS应用的crash日志的分析基础]]></content>
      <categories>
        <category>iOS</category>
        <category>Crash</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-检测主线程卡顿的问题]]></title>
<url>../../../../../../../../2017/11/22/iOS-Func-检测主线程卡顿的问题/</url>
    <content type="text"><![CDATA[runloop - 检测方案 原文文档 runloop 的状态typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 耗时进行判断 利用 kCFRunLoopBeforeSources 和 *kCFRunLoopAfterWaiting 这两个状态之间的耗时 进行判断:是否有太多事件处理导致出现了卡顿 AppDelegate+AppService 监听runloop的状态而写的回调函数 static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; PingConfig *object = (__bridge PingConfig*)info; // 记录状态值 object-&gt;activity = activity; // 发送信号 dispatch_semaphore_t semaphore = object-&gt;semaphore; dispatch_semaphore_signal(semaphore);&#125; AppDelegate 注册监听 PingConfig: 一个用来存储runloop的状态和信号量的自定义类，其中的结构如下 APP启动时我可以进入 registerObserver 方法，其中首先我创建一个记录信息的类PingConfig实例，然后创建一个信号，并且保存在这个PingConfig实例中(其实只是为了方便拿到 创建了一个观察者监测主线程的runloop,它会在主线程runloop状态切换时进行回调 开启一个子线程，并且在里面进行一个 while 循环，在 循环的开始处 wait 一个信号量，并且设置超时为 50毫秒，失败后会返回一个非0数，成功将会返回0，这时候线程会阻塞住等待一个信号的发出 如果runloop状态正常切换，那么就会进入回调函数，在回调函数中我们发出一个信号，并且记录当前状态到PingConfig实例中，下面的判断语句中发现为0，timeoutCount自动置为0，一切正常 当主线程出现卡顿，while循环中的信号量再次等待，但是回调函数没有触发，从而导致等待超时，返回一个非0数，进入判断句后，我们再次判断状态是否处于 kCFRunLoopBeforeSources 或 kCFRunLoopAfterWaiting，如果成立，timeoutCount+1 持续五次runloop不切换状态，说明runloop正在处理某个棘手的事件无法休息且不更新状态，这样while循环中的信号量超时会一直发生，超过5次后我们将断定主线程的卡顿并上传堆栈信息 - (void)registerObserver&#123; PingConfig *config = [PingConfig new]; // 创建信号 dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); config-&gt;semaphore = semaphore; CFRunLoopObserverContext context = &#123;0,(__bridge void*)config,NULL,NULL&#125;; CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes); __block uint8_t timeoutCount = 0; // 在子线程监控时长 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (YES) &#123; // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms) long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC)); if (st != 0) &#123;// NSLog(@"循环中--%ld",config-&gt;activity); if (config-&gt;activity==kCFRunLoopBeforeSources || config-&gt;activity==kCFRunLoopAfterWaiting) &#123; if (++timeoutCount &lt; 5)&#123; continue; &#125;else&#123; NSLog(@"卡顿了"); &#125; &#125; &#125; timeoutCount = 0; &#125; &#125;);&#125; PingConfig@interface PingConfig : NSObject&#123; @public CFRunLoopActivity activity; dispatch_semaphore_t semaphore;&#125;@end Other情况主线程卡顿主线程卡在界面尚未完全显示前 当主线程卡在界面尚未完全显示前，这个方案就检测不出来卡顿了，比如我将下面的代码放在B控制器中 dispatch_semaphore_t t = dispatch_semaphore_create(0); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@"----"); dispatch_semaphore_signal(t); &#125;); dispatch_semaphore_wait(t, DISPATCH_TIME_FOREVER); 上面是一段有问题的代码，将导致主线程的持续堵塞，如果我们在这段代码放在B控制器的ViewDidLoad方法中(ViewWillAppear同样) 运行后，当你希望push到B控制器时，项目将在上一个界面完全卡住，并且无法用上面的方案检测到，而且CPU及内存都显示正常 原因分析 由于runloop在处理完source0或者source1后，比如界面的跳转也是执行了方法，具体有没有用到source0这不重要，但是后面会紧接着进入准备睡眠(kCFRunLoopBeforeWaiting)的状态，然而此时线程的阻塞导致runloop的状态也被卡住无法切换，这样也就导致在那段检测代码中无法进入条件，从而检测不出来。 但是话说回来，APP在静止状态(保持休眠)和刚刚那种卡死状态都会使runloop维持在 kCFRunLoopBeforeWaiting状态，这样我们就无法在那段代码中增加判断来修复，因为无法知道到底是真的静止没有操作还是被阻塞住，我也没找到线程的阻塞状态属性，如果你发现这个属性，那么就可以使用那个属性来判断 检测方案dispatch_queue_t serialQueue = dispatch_queue_create("serial", DISPATCH_QUEUE_SERIAL); self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, serialQueue); dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 0.25 * NSEC_PER_SEC, 0); __block int8_t chokeCount = 0; dispatch_semaphore_t t2 = dispatch_semaphore_create(0); dispatch_source_set_event_handler(self.timer, ^&#123; if (config-&gt;activity == kCFRunLoopBeforeWaiting) &#123; static BOOL ex = YES; if (ex == NO) &#123; chokeCount ++; if (chokeCount &gt; 40) &#123; NSLog(@"差不多卡死了"); dispatch_suspend(self.timer); return ; &#125; NSLog(@"卡顿了"); return ; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; ex = YES; dispatch_semaphore_signal(t2); &#125;); BOOL su = dispatch_semaphore_wait(t2, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC)); if (su != 0) &#123; ex = NO; &#125;; &#125; &#125;); dispatch_resume(self.timer); 方案解释 开启一个异步队列，并且创建一个定时器，时间我设置的是0.25秒，具体时间随你自己，这个时间是用来检测卡死的持续时间 在定时器外面我也同样创建了一个用来同步的信号量，这个不解释了，不会的就去看一下信号量的使用方式。进入定时器的回调后，我设置了一个静态变量来记录主队列是否执行完成。 我们判断当前runloop的状态是否为kCFRunLoopBeforeWaiting，所以这个方案是用来弥补前面那个方案，如果主线程此时没有阻塞住，我们在这里向main Queue抛一个block，看它是否能够成功执行，如果成功执行，说明主线程没有阻塞住，如果已经被阻塞住，那我抛过去的block是肯定不会被执行的。 下面的代码就是一些辅助操作，当信号量超过50毫秒，抛给主线程的block没有执行，那么说明此时就有一些阻塞了，返回一个非0数，并设置 ex为NO，从而在下一次定时器回调到来时进行上报]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-UI-Shadow阴影]]></title>
<url>../../../../../../../../2017/11/22/iOS-UI-Shadow阴影/</url>
    <content type="text"><![CDATA[shadowColor:阴影颜色,可设置透明度等. shadowOffset:偏移量.,xy表示view左上角,width表示阴影与x的偏移量,height表示阴影与y值的偏移量 shadowOpacity = 0.4//阴影透明度,默认为0则看不到阴影.因此要看到阴影这个值必须大于0,shadowColor的透明度也要大于0 shadowRadius:5.模糊计算的半径,取平均值的半径,设置为0的话则为一个矩形块. 模糊度的解释:每一个像素取平均值,分母的取值范围,越大越模糊.感觉这篇文章讲的比较容易懂(http://www.dongcoder.com/detail-22914.html). 注意:如果clipsToBounds设置为YES,则阴影效果消失 let layer = view.layer layer.shadowColor = UIColor.black.cgColor//阴影颜色 layer.shadowOffset = CGSize(width: 10, height: 10)//width表示阴影与x的便宜量,height表示阴影与y值的偏移量 layer.shadowOpacity = 0.4//阴影透明度,默认为0则看不到阴影 layer.shadowRadius = 5; Go!]]></content>
      <categories>
        <category>iOS</category>
        <category>UI</category>
        <category>Layer</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>Layer</tag>
        <tag>Shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func-Autoreleasepool]]></title>
<url>../../../../../../../../2017/11/22/iOS-Func-autoreleasepool/</url>
    <content type="text"><![CDATA[Autoreleasepool释放时机 每个个Runloop已经默认会创建一个Autoreleasepool 新增对Runloop的Observer, 及时获取Runloop的状态变化确认释放时机 添加一个监听者 创建监听者 - (void)addRunLoopObserver &#123; CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; switch (activity) &#123; case kCFRunLoopEntry: NSLog(@&quot;进入RunLoop&quot;); break; case kCFRunLoopBeforeTimers: NSLog(@&quot;即将处理Timer事件&quot;); break; case kCFRunLoopBeforeSources: NSLog(@&quot;即将处理Source事件&quot;); break; case kCFRunLoopBeforeWaiting: NSLog(@&quot;即将休眠&quot;); break; case kCFRunLoopAfterWaiting: NSLog(@&quot;被唤醒&quot;); break; case kCFRunLoopExit: NSLog(@&quot;退出RunLoop&quot;); break; default: break; &#125; &#125;); 添加监听者 CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);&#125; 测试 不手动添加autoreleasepool 方法运行连续运行两次, 不手动添加autoreleasepool - (void)test1 &#123; NSLog(@&quot;test1 begin!&quot;); for (int i = 0; i &lt; 10e5 * 2; i++) &#123; //@autoreleasepool &#123; NSString *str = [NSString stringWithFormat:@&quot;hi + %d&quot;, i]; //&#125; &#125; NSLog(@&quot;test1 finished!&quot;);&#125;- (void)test2 &#123; NSLog(@&quot;test2 begin!&quot;); for (int i = 0; i &lt; 10e5 * 2; i++) &#123; //@autoreleasepool &#123; NSString *str = [NSString stringWithFormat:@&quot;hi + %d&quot;, i]; //&#125; &#125; NSLog(@&quot;test2 finished!&quot;);&#125; Runloop没有完成一次循环之前所有内存都未释放, 即使局部变量出了作用域也必须等待Runloop循环完成 手动添加autoreleasepool观察释放时机 for{@autoreleasepool{}} 效果好于 @autoreleasepool{for…}@autoreleasepool{} @autoreleasepool&#123;&#125; 等价于 void *context = objc_autoreleasePoolPush();// &#123;&#125;中的代码objc_autoreleasePoolPop(context); 每次出了{}时objc_autoreleasePoolPop()就被调用, 所以直接释放掉了. 当然, 系统自动创建的autoreleasepool也是一样, 只是调用的时机不同: 线程与Runloop是一一对应, Runloop与系统创建的autoreleasepool也是一一对应, 所以不论是Runloop完成了一次循环还是线程被关闭时, autoreleasepool都会释放, 当然手动添加的也会被管理 主要就是一个类:AutoreleasePoolPage 两个函数: objc_autoreleasePoolPush()、objc_autoreleasePoolPop() 运作方式: autoreleasepool由若干个autoreleasePoolPage类以双向链表的形式组合而成 当程序运行到@autoreleasepool{时, objc_autoreleasePoolPush()将被调用, runtime会向当前的AutoreleasePoolPage中添加一个nil对象作为哨兵,在{}中创建的对象会被依次记录到AutoreleasePoolPage的栈顶指针,当运行完@autoreleasepool{}时, objc_autoreleasePoolPop(哨兵)将被调用, runtime就会向AutoreleasePoolPage中记录的对象发送release消息直到哨兵的位置, 即完成了一次完整的运作. 主线程中的自动释放池是自动创建的, 文档中说子线程中的自动释放池是需要手动创建的, 但实测, 其实我们常用的多线程管理方式(GCD, NSOprationQueue, NSThread)都已经帮我们处理好了, 其中NSThread在iOS7之后才自动创建线程中的AutoreleasePool 我们常用的for循环, 以及enumerate其实跟autoreleasepool也有关, for循环是不自动创建autoreleasepool的, 而enumerate中已经自动创建了autoreleasepool, 值得注意的是高并发enumerate常常会出一些意外的问题, 例如对象被提前释放, 所以建议高并发情况下使用for循环(性能高于enumerate), 再手动添加autoreleasepool.]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
      <tags>
        <tag>Autoreleasepool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-RunTime-方法交换/拦截基础使用]]></title>
<url>../../../../../../../../2017/11/22/iOS-RunTime-方法交换-拦截基础使用/</url>
    <content type="text"><![CDATA[RunTime的消息机制参考链接 Objective-C的方法调用是属于消息传送的机制每个类都有一个isa的结构体指针在这个结构体里, 得到指定类的所有属性, 所有方法的列表, 也可以知父类是什么… 新建RTMsgModel RTMsgModel.h @interface RTMsgModel : NSObject- (void)ff_post;- (void)ff_getWithCount:(NSInteger)count; RTMsgModel.m - (void)ff_post&#123; NSLog(@&quot;被调用了: %@, 当前对象为: %@&quot;, NSStringFromClass([self class]), self);&#125;- (void)ff_getWithCount:(NSInteger)count&#123; NSLog(@&quot;被%ld人调用了&quot;, count);&#125; 测试消息机制//// ViewController.m// Runtime方法交换拦截//// Created by RN on 17/11/22.// Copyright © 2017年 YueKekui. All rights reserved.//#import &quot;ViewController.h&quot;#import &quot;RTMsgModel.h&quot;#import &lt;objc/message.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self show_runTimeMsg];&#125;#pragma mark - RunTime的消息机制/** * @brief: RunTime的消息机制 * * * * @attention： Xcode 会自动屏蔽通过objc_msgSend创建对象, 我们可以去到工程里设置 * Build Setting -&gt; Enable Strict Checking of objc_msgSend Calls 改成No */- (void)show_runTimeMsg&#123; //1.objc_getClass Class getClass = objc_getClass(&quot;RTMsgModel&quot;); NSLog(@&quot;Get The Class is: %@&quot;, getClass); //2.objc_msgSend RTMsgModel *messageModel = objc_msgSend(getClass, @selector(alloc)); NSLog(@&quot;alloc Object: %@&quot;, messageModel); // 在不调用init方法, 可以通过发消息调用想用的方法, 这里调用没有在.h文件里声明的方法会警告该方法没有声明 objc_msgSend(messageModel, @selector(ff_post)); messageModel = objc_msgSend(messageModel, @selector(init)); NSLog(@&quot;init Object: %@&quot;, messageModel); objc_msgSend(messageModel, @selector(ff_post)); // 还有另外一种写法, 就是把所有东西都集合在一起, 也就是我们常用的[[NSObject alloc] init];的原型 RTMsgModel *messageModelTwo = objc_msgSend(objc_msgSend(objc_getClass(&quot;RTMsgModel&quot;), @selector(alloc)), @selector(init)); objc_msgSend(messageModelTwo, @selector(ff_getWithCount:), 5);&#125;@end 打印2017-11-22 12:36:16.232 Runtime方法交换拦截[21927:3962074] Get The Class is: RTMsgModel2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] alloc Object: &lt;RTMsgModel: 0x600000003680&gt;2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] 被调用了: RTMsgModel, 当前对象为: &lt;RTMsgModel: 0x600000003680&gt;2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] init Object: &lt;RTMsgModel: 0x600000003680&gt;2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] 被调用了: RTMsgModel, 当前对象为: &lt;RTMsgModel: 0x600000003680&gt;2017-11-22 12:36:16.233 Runtime方法交换拦截[21927:3962074] 被5人调用了 RunTime方法交换 建一个类RunTimeMethodModel.h #import &lt;Foundation/Foundation.h&gt;@interface RunTimeMethodModel : NSObject@property (nonatomic, copy) NSString *cl_height;@property (nonatomic, copy) NSString *cl_weight;- (NSString *)cl_height;- (NSString *)cl_weight;@end RunTimeMethodModel.m - (NSString *)cl_height &#123; return @&quot;我身高180&quot;;&#125;- (NSString *)cl_weight &#123; return @&quot;我体重280&quot;; &#125; 测试交换方法 执行方法交换 RunTimeMethodModel *methodModel = [[RunTimeMethodModel alloc] init]; NSLog(@&quot;身高: %@&quot;, methodModel.cl_height); NSLog(@&quot;体重: %@&quot;, methodModel.cl_weight); Method methodOne = class_getInstanceMethod([methodModel class], @selector(cl_height)); Method methodTwo = class_getInstanceMethod([methodModel class], @selector(cl_weight)); method_exchangeImplementations(methodOne, methodTwo); NSLog(@&quot;打印的内容: %@&quot;, [methodModel cl_height]); 打印身高: 我身高180体重: 我体重280 打印的内容: 我体重280 注意一点注意一点, 由于这里的ViewController会销毁, 但method_exchangeImplementations会一直存在, 再次进来的时候, 就会再次根据上次交换过的顺序再次交换 +load交换方法 +load交换方法+ (void)load &#123; Method methodOne = class_getInstanceMethod(self, @selector(cl_height)); Method methodTwo = class_getInstanceMethod(self, @selector(cl_weight)); method_exchangeImplementations(methodOne, methodTwo);&#125;- (NSString *)cl_height &#123; return @&quot;我身高180&quot;;&#125;- (NSString *)cl_weight &#123; return @&quot;我体重280&quot;;&#125; 打印 身高: 我体重280体重: 我身高180身高: 我体重280体重: 我身高180 +initialize交换方法 +load这个方法里的确是可以保证方法交换只有一次, 但这里有一个弊端, 就是当程序一运行就会执行这个方法交换了+load: 程序一开始就会去执行, 只执行一次.+initialize: 当类被初始化的时候会才会去执行, 该类只会执行一次. initializeclass_getInstanceMethod 获取实例方法method_exchangeImplementations 方法交换 + (void)initialize + &#123; Method methodOne = class_getInstanceMethod(self, @selector(cl_height)); Method methodTwo = class_getInstanceMethod(self, @selector(cl_weight)); method_exchangeImplementations(methodOne, methodTwo);&#125;- (NSString *)cl_height &#123; return @&quot;我身高180&quot;;&#125;- (NSString *)cl_weight &#123; return @&quot;我体重280&quot;;&#125; RunTime方法拦截 从刚刚我们就知道, 可以使用method_exchangeImplementations交换两个方法, 但只应用在本类, 现在我们来看看别的应 @implementation BaseModel- (void)cl_logBaseModel &#123; NSLog(@&quot;Base Model Log&quot;);&#125;@end@implementation InterceptModel- (void)cl_logInterceptModel &#123; NSLog(@&quot;Intercept You Method &quot;);&#125;@end 最终的实现 + (void)initialize &#123; Method mehtodOne = class_getInstanceMethod([BaseModel class], @selector(cl_logBaseModel)); Method mehtodTwo = class_getInstanceMethod([InterceptModel class], @selector(cl_logInterceptModel)); method_exchangeImplementations(mehtodOne, mehtodTwo);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; BaseModel *baseModel = [[BaseModel alloc] init]; [baseModel cl_logBaseModel];&#125;。 打印结果发现方法是被InterceptModel这个类拦截, 并且替换了InterceptModel的方法 [InterceptModel cl_logInterceptModel] 第15行 Intercept You Method 类方法也可以交换和拦截 新增类方法 #import &quot;BaseModel.h&quot;@implementation BaseModel- (void)cl_logBaseModel &#123; NSLog(@&quot;Base Model Log&quot;);&#125;+ (void)cl_logBaseModelClass &#123; NSLog(@&quot;Base Model Class Log&quot;);&#125;@end-----------------------------------------------@implementation InterceptModel- (void)cl_logInterceptModel &#123; NSLog(@&quot;Intercept You Method &quot;);&#125;+ (void)cl_logInterceptModelClass &#123; NSLog(@&quot;Intercept Class You Method &quot;);&#125;@end 最终实现class_getInstanceMethod 获取类方法method_exchangeImplementations initialize class_getInstanceMethod 实例方法 class_getClassMethod 类方法 method_exchangeImplementations 交换方法 + (void)initialize &#123; // 拦截实例方法 Method mehtodOne = class_getInstanceMethod([BaseModel class], @selector(cl_logBaseModel)); Method mehtodTwo = class_getInstanceMethod([InterceptModel class], @selector(cl_logInterceptModel)); method_exchangeImplementations(mehtodOne, mehtodTwo); // 拦截类方法 Method classMehtodOne = class_getClassMethod([BaseModel class], @selector(cl_logBaseModelClass)); Method classMehtodTwo = class_getClassMethod([InterceptModel class], @selector(cl_logInterceptModelClass)); method_exchangeImplementations(classMehtodOne, classMehtodTwo);&#125; 执行 self.view.backgroundColor = [UIColor whiteColor];BaseModel *baseModel = [[BaseModel alloc] init];[baseModel cl_logBaseModel];[BaseModel cl_logBaseModelClass]; 打印 Intercept You Method Intercept Class You Method]]></content>
      <categories>
        <category>iOS</category>
        <category>RunTime</category>
      </categories>
      <tags>
        <tag>RunTime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIScrollView基础用法]]></title>
<url>../../../../../../../../2017/11/22/iOS-UIScrollView基础用法/</url>
    <content type="text"><![CDATA[属性- (void)viewDidLoad &#123; [super viewDidLoad]; _scrollView.backgroundColor = [UIColor redColor]; //设置contentSize（必须设置） _scrollView.contentSize = CGSizeMake(400, 667); //偏移量 _scrollView.contentOffset = CGPointMake(100, 0); //contentInset(在原有的基础上调整内容滚动区域的大小) //_scrollView.contentInset = UIEdgeInsetsMake(-100, 0, 0, 0); //锁定方向(当系统识别滚动方向的时候，会把另外一个方向锁定，如果识别不了，就不锁定方向) _scrollView.directionalLockEnabled = YES; //反弹效果(默认为yes) _scrollView.bounces = YES; //默认是no，假如是yes并且bounces是yes,甚至如果内容大小小于bounds的时候，允许垂直拖动 _scrollView.alwaysBounceVertical = YES; //分页（默认no） _scrollView.pagingEnabled = YES; //滚动(默认yes允许滚动) _scrollView.scrollEnabled = YES; //滚动条 //showsHorizontalScrollIndicator默认yes 显示 _scrollView.showsHorizontalScrollIndicator = NO; //滚动条滚动的范围(垂直滚动条滚动范围上下各缩小50) _scrollView.scrollIndicatorInsets = UIEdgeInsetsMake(50, 0, 50, 0); //样式 _scrollView.indicatorStyle = UIScrollViewIndicatorStyleWhite; // Do any additional setup after loading the view, typically from a nib.&#125; 方法- (void)viewDidLoad &#123; [super viewDidLoad]; //创建并添加scrollView UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(100, 200, 200, 300)]; [self.view addSubview:scrollView]; scrollView.backgroundColor = [UIColor redColor]; //设置内容视图的大小 scrollView.contentSize = CGSizeMake(375, 667); //设置内容视图 UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 375, 667)]; imageView.image = [UIImage imageNamed:@&quot;new_feature_1&quot;]; [scrollView addSubview:imageView]; _imageView = imageView; //设置代理 scrollView.delegate = self; //[self performSelector:@selector(changeScrollViewContentOffSet:) withObject:scrollView afterDelay:3]; //设置缩放内容视图的缩放比例范围 scrollView.minimumZoomScale = 0.5; scrollView.maximumZoomScale = 1.5; //当缩放比例超出范围之后，是否有反弹效果（no:不会超出范围，yes:超出范围之后反弹） scrollView.bouncesZoom = YES; //属性设置滚动至顶部 //scrollView.scrollsToTop = YES; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)changeScrollViewContentOffSet:(UIScrollView *)scrollView&#123; [scrollView setContentOffset:CGPointMake(0, 300) animated:YES];&#125;#if 0#pragma mark -UIScrollViewDelegate 滚动//当scrollView滚动的时候，不停调用（可以监听scrollView的contentOffset）- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; //NSLog(@&quot;%@&quot;,NSStringFromCGPoint(scrollView.contentOffset)); //NSLog(@&quot;decelerating：%d&quot;,scrollView.decelerating); //NSLog(@&quot;dragging：%d&quot;,scrollView.dragging); //NSLog(@&quot;tracking:%d&quot;,scrollView.tracking); NSLog(@&quot;%s&quot;,__func__);&#125;//开始拖动的时候调用- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123; //NSLog(@&quot;tracking:%d&quot;,scrollView.tracking); NSLog(@&quot;%s&quot;,__func__);&#125;// called on finger up if the user dragged. velocity is in points/millisecond. targetContentOffset may be changed to adjust where the scroll view comes to rest//将要结束拖动- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset &#123;// NSLog(@&quot;velocity:%@&quot;,NSStringFromCGPoint(velocity));// NSLog(@&quot;targetContentOffset:%@&quot;,NSStringFromCGPoint(*targetContentOffset)); //强制设置scrollView的偏移量 //*targetContentOffset = CGPointMake(0, 200); NSLog(@&quot;%s&quot;,__func__);&#125;// 已经结束拖动- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; //NSLog(@&quot;dragging：%d&quot;,scrollView.dragging); NSLog(@&quot;%s&quot;,__func__);&#125;//将要开始减速- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView&#123; //NSLog(@&quot;decelerating：%d&quot;,scrollView.decelerating); NSLog(@&quot;%s&quot;,__func__);&#125;//减速完成（停止）- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; //NSLog(@&quot;contentOffset:%@&quot;,NSStringFromCGPoint(scrollView.contentOffset)); NSLog(@&quot;%s&quot;,__func__);&#125;// called when setContentOffset/scrollRectVisible:animated: finishes. not called if not animating- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView&#123; NSLog(@&quot;%s&quot;,__func__);&#125;#endif#pragma mark -UIScrollViewDelegate(缩放)//指定缩放视图- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView&#123; NSLog(@&quot;%s,zooming:%d&quot;,__func__,scrollView.zooming); return _imageView;&#125;//缩放之前调用- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view &#123; NSLog(@&quot;%s,zooming:%d&quot;,__func__,scrollView.zooming);&#125;//完成缩放- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view atScale:(CGFloat)scale&#123; NSLog(@&quot;%s,zooming:%d&quot;,__func__,scrollView.zooming);&#125;//缩放时调用- (void)scrollViewDidZoom:(UIScrollView *)scrollView&#123; NSLog(@&quot;%s,zooming:%d&quot;,__func__,scrollView.zooming);&#125;#pragma mark -UIScrollViewDelegate(滚动至顶部)//允许滚动至顶部- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView&#123; return YES;&#125;//已经滚动至顶部- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView&#123; NSLog(@&quot;加载新数据，刷新界面&quot;);&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>UI</category>
        <category>UIScrollView</category>
      </categories>
      <tags>
        <tag>UIScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS_App跳转设置]]></title>
<url>../../../../../../../../2017/11/21/iOS-App跳转设置/</url>
    <content type="text"><![CDATA[跳到更多设置界面除了跳到WiFi设置界面，能不能跳到其他的设置界面呢？比如：定位服务、FaceTime、音乐等等。都是可以的，一起来看看如何实现的 跳到这些界面的参数配置： ##定位服务 用户关闭了定位,APP里面提示打开定位服务点击到设置界面设置，直接跳到定位服务设置界面= //定位服务设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=LOCATION_SERVICES&quot;];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; FaceTim//FaceTime设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=FACETIME&quot;];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; 音乐//音乐设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=MUSIC&quot;];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; 蓝牙设置界面//蓝牙设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=Bluetooth&quot;];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; iCloud设置界面//iCloud设置界面NSURL *url = [NSURL URLWithString:@&quot;prefs:root=CASTLE&quot;];if ([[UIApplication sharedApplication] canOpenURL:url]&#123; [[UIApplication sharedApplication] openURL:url];&#125; other设置界面只需要prefs:root=后面的值即可可以跳到这些界面的参数配置：r About — prefs:root=General&amp;path=AboutAccessibility — prefs:root=General&amp;path=ACCESSIBILITYAirplane Mode On — prefs:root=AIRPLANE_MODEAuto-Lock — prefs:root=General&amp;path=AUTOLOCKBrightness — prefs:root=BrightnessBluetooth — prefs:root=General&amp;path=BluetoothDate &amp; Time — prefs:root=General&amp;path=DATE_AND_TIMEFaceTime — prefs:root=FACETIMEGeneral — prefs:root=GeneralKeyboard — prefs:root=General&amp;path=KeyboardiCloud — prefs:root=CASTLEiCloud Storage &amp; Backup — prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUPInternational — prefs:root=General&amp;path=INTERNATIONALLocation Services — prefs:root=LOCATION_SERVICESMusic — prefs:root=MUSICMusic Equalizer — prefs:root=MUSIC&amp;path=EQMusic Volume Limit — prefs:root=MUSIC&amp;path=VolumeLimitNetwork — prefs:root=General&amp;path=NetworkNike + iPod — prefs:root=NIKE_PLUS_IPODNotes — prefs:root=NOTESNotification — prefs:root=NOTIFICATIONS_IDPhone — prefs:root=PhonePhotos — prefs:root=PhotosProfile — prefs:root=General&amp;path=ManagedConfigurationListReset — prefs:root=General&amp;path=ResetSafari — prefs:root=SafariSiri — prefs:root=General&amp;path=AssistantSounds — prefs:root=SoundsSoftware Update — prefs:root=General&amp;path=SOFTWARE_UPDATE_LINKStore — prefs:root=STORETwitter — prefs:root=TWITTERUsage — prefs:root=General&amp;path=USAGEVPN — prefs:root=General&amp;path=Network/VPNWallpaper — prefs:root=WallpaperWi-Fi — prefs:root=WIFI]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS_Safari跳转App]]></title>
<url>../../../../../../../../2017/11/21/iOS-Safari-跳转App/</url>
    <content type="text"><![CDATA[Safari跳转到App##App中定义一个URL协议 TARGETS -&gt; info -&gt; URL Types -&gt; 添加一个URL协议 URL Schemes字段就是你这个APP的特殊标示，indentifier:这个URL协议的标示。一个APP可以拥有多个URL协议下面的两个字段可为空。最后再运行一下你的APP。 浏览里访问打开Safari浏览器，在输入在地址栏输入：myapp://然后回车 Safari跳回到APP时传一些参数比如在Safari浏览器的地址了输入：myapp://myappTest，用下面的方法获取到该参数之后就看自己的操作了 在appdelegate.m文件中写下如下方法如果iOS版本低于9.0，会在下面方法接受到在地址栏输入的字符串- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; [[[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@&quot;sourceApplication-&gt;%@&quot;, [url absoluteString]] message:nil delegate:nil cancelButtonTitle:@&quot;ok&quot; otherButtonTitles:nil] show]; return YES;&#125;如果iOS版本是9.0及以上的，会在下面方法接受到在地址栏输入的字符串- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options&#123; [[[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@&quot;openURL-&gt;%@&quot;, [url absoluteString]] message:nil delegate:nil cancelButtonTitle:@&quot;ok&quot; otherButtonTitles:nil] show]; return YES;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
      <tags>
        <tag>Func</tag>
        <tag>跳转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-Func- Universal Links通用链接]]></title>
<url>../../../../../../../../2017/11/21/iOS-Func- Universal Links通用链接/</url>
    <content type="text"><![CDATA[Universal Links简介 iOS9之前 iOS9之前,对于从各种从浏览器,Safari、UIWebView或者 WKWebView中唤醒APP的需求,我们通常只能使用scheme.首先是app中注册某个scheme 在iOS 9以后 通过Universal Link，将App 与网页端建立连接桥，可以从Safari 或者其他前端浏览器来识别并唤醒App，甚至是微信环境下也可以冲破障碍 官方的说明文档–&gt; Universal Link的优点 唯一性: 不像自定义的scheme,因为它使用标准的http/https链接到你的web站点,所以它不会被其它的app所声明.另外,Custom URL scheme 因为是自定义的协议，所以在没有安装 app 的情况下是无法直接打开的，而 universal links 本身是一个 HTTP/HTTPS 链接，所以有更好的兼容性 安全: 当用户的手机上安装了你的app,那么iOS将去你的网站上去下载你上传上去的说明文件(这个说明文件声明了你的app可以打开哪些类型的http链接).因为只有你自己才能上传文件到你网站的根目录,所以你的网站和你的app之间的关联是安全的. 可变: 当用户手机上没有安装你的app的时候,Universal Links也能够工作.如果你愿意,在没有安装你的app的时候,用户点击链接,会在safari中展示你网站的内容. 简单: 一个URL链接,可以同时作用于网站和ap 私有 其它app可以在不需要知道你的app是否安装了的情况下和你的app相互通信 需求 分享页面中，我们经常会看到在页面的顶端或者底部遇到有【打开App】或者【下载App】这样的按钮。 比较友好的产品，会做设备识别，以及检测APP是否安装，来做打开或者下载App 的需求但是在微信中，这方面做的比较恶心，微信下面几乎是全面屏蔽了唤起原生App 的功能 Universal Link 实现条件 域名 有一个域名,且这个域名的网站需要支持https,然后拥有网站的上传到根目录的权限(这个权限是为了上传一个apple指定的文件) 支持Universal Links(通用链接) 创建一个json格式的命名为apple-app-site-association文件 注意这个文件必须没有后缀名,文件名必须为: apple-app-site-association &#123; "applinks": &#123; "apps": [], "details": [ &#123; "appID": "Prefix +点 +BundleID", "paths": [ "/html/1/*", "/*"], &#125;, ] &#125;&#125; Prefix 和 BundleID paths:根据 paths 键设定一个你的app支持的路径列表,只有这些指定的路径的链接,才能被app所处理,举个例子:如果你的网站是www.XXXX.com,你的path写的是”/support/“,那么当用户点击www.yohunl.com/support/myDoucument,就可以进入你的app了,相反www.yohunl.com/other 就不会.path是大小写敏感的! 号表示任意路径. 服务器服务器配置 准备独立域名一级域名，二级域名均可。SSL 证书 为服务器配置HTTPS 用的SSL 证书上传签名好的JSON 配置文件 新建JSON文件新建一个JSON文件，不需要后缀名，内容输入以下代码： appID:相关内容可以在Developer 中心找到相关的内容。如图，前半部分为Prefix 后半部分为ID，即你的App 的bundle id，两者通过.相连paths:用来唤醒App 所需要指定的JSON文件在服务器中的路径。用”/* “ 是根目录，而/html 则是指html目录下的注意：这里的AppID中前半部分，在App 转让主体后会改变，需重新更新填好后保存为apple-app-site-association 名，上传到域名指向的服务器根目录。 &#123; "applinks": &#123; "apps": [], "details": [ &#123; "appID": "5B5Q4xxxx.com.xxxx.xxxx", "paths": [ "/html/1/*", "/*"] &#125;, ] &#125;&#125; 上传传该文件apple-app-site-association 上传传该文件apple-app-site-association到你的域名所对应的网站的根目录下(其实也不一定是根目录,例如ghost博客站点,就没有根目录一说,它就需要放在相应的主题目录下) 这一步是为了苹果能从https://你的域名/apple-app-site-associationxh获取到你上传的apple-app-site-association文件.上传完后,自己先访问一下,看看是否能够获取到,用我的做例子,https://yohunl.com/apple-app-site-association ,当你点击这个链接,应该是下载apple-app-site-association文件.验证该文件是否合法,苹果为了方便开发者,提供了一个网页来验证我们编写的这个apple-app-site-association是否合法有效,验证网址,进入网站进行验证 App配置工程文件配置 在工程文件中，找到Targets - Capabilities - Associated Domains 将开关选为On，并添加你的域名， 格式为 applinks: + 后台给的域名.com applinks: + www.后台给的域名.com iOS移动端的代码- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler&#123; if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb]) &#123; NSString *url = userActivity.webpageURL.description; // 这里可以通过拆分url 来传入参数，达到跳转原生页面的功能，如跳转某商品页 [UIApplication sharedApplication] openURL:webpageURL]; &#125; return YES;&#125; h5网页配置 h5网页中对需要唤起App 的按钮或者控件添加点击事件，事件的函数代码如下: function wakeUpApp()&#123; if (navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) &#123; var loadDateTime = new Date(); window.setTimeout(function() &#123; var timeOutDateTime = new Date(); if (timeOutDateTime - loadDateTime &lt; 5000) &#123; window.location.href = "http://a.app.qq.com/o/simple.jsp?pkgname=你的应用宝BundleID"; &#125; else &#123; window.close(); &#125; &#125;, 25); window.location.href = "https://yourdomainname.com/"; &#125; else if (navigator.userAgent.match(/android/i)) &#123; var state = null; try &#123; state = window.open("apps custom url schemes ", '_blank'); &#125; catch(e) &#123;&#125; if (state) &#123; window.close(); &#125; else &#123; window.location.href = "要跳转的页面URL"; &#125; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Func</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MarkDomn语法]]></title>
<url>../../../../../../../../2017/11/21/MarkDomn-语法/</url>
    <content type="text"><![CDATA[目录效果生成目录* [1.语法示例](#1)* [1.1图片](#1.1) * [1.2换行](#1.2)* [1.3强调](#1.3) * 字体h1&gt;h2&gt;h3.... &lt;h2 id=&quot;1&quot;&gt;目录标题&lt;/h2&gt; 效果 1.h2比h1字体小 1.1图片 1.2换行 1.3强调 页面内跳转锚 放在 目的地定义一个锚(id)： 跳转markdown语法[点击跳转--&gt;](#index)]]></content>
      <categories>
        <category>Tool</category>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDomn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS_代码规范]]></title>
<url>../../../../../../../../2017/11/20/iOS-Code-代码规范/</url>
    <content type="text"><![CDATA[#一、iOS编码规范 命名变量命名首字母小写，驼峰法则 UI控件（描述+控件类型） `priceLabel或priceLab` 注释也要写 最好对齐@property (nonatomic, strong) UIButton *collectsImgView; //合集 - 图标@property (nonatomic, strong) UILabel *collectsThemeLab; //合集 - 主题@property (nonatomic, strong) UILabel *collectsAuthorLab; //合集 - 作者 方法命名首字母小写，驼峰法则 public method 规则： 方法用途单词_方法一般的方法 show_editBtnOnOneViewC:(OneViewC *)oneViewC editBtn:(UIButton *)editBtn.....跳转 push_更新数据 update_collectList删除数据 delete_collectList private method private method 规则：不加下划线 不需要and： nameStr:(NSstring)nameStr- (void)pushOnewViewC:(OnewViewC *)onewViewC nameStr:(NSstring)nameStr &#123;&#125; 扩展或封装方法 规则：以FF或ff开头 FanFan简写public method - (void)ff_editOnOneViewC:(oneViewC) isOpen:(BOOL) 括号原则，尽可以的少占一行。对齐就好 少用#define预处理指令，多用类型常量预处理指令命名 （字母全大写，以”_”分割） #define NSString * APP_ROOT_DIR @&quot;xxx&quot; 常量命名 （字母全大写，”k”开头） static NSString * const kAPPROOTDIR = @&quot;xxx&quot;; 资源文件中变量命名全小写，”“分割模块： 开发功能模块外 nav tab login refresh share hud common(公有)格式：“模块类别状态描述” 状态可不要 目前版本我们以模块作为文件夹 ，后面的按照这个4个 personal_btn_un_select.pngpersonal_btn_name_pngnav_btn_left.pngnav_imgView_lright.pngtab_item_un_select.pngtab_item_select.png 能用糖衣语法的尽量用糖衣语法，使用时注意nil报错。= @[].mutableCopy;NSString *name = dic[@&quot;name&quot;];NSArray *array= @[item1, item2]; 用前缀避免命名空间冲突。大多数的自定制，都需要用前缀比如创建有读界面 Have (文件夹) ViewC(文件夹) HaveReadViewC.h View HaveReadView.h Model HaveReadModel.h Cell HaveReadCell.h 委托Delegate的定义和使用放在对应类的.h文件中，命名为该类名+Delegate，//定义代理HaveReadViewCDelegate ==&gt;HaveReadViewC + DelegateHaveReadCellDelegate ==&gt; HaveReadCell + Delegate//声明@property (nonatomic, weak) id &lt;ArticleHeadTableUrlDelegate&gt; delegate;//必须加判断！！！if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(push_safariWithUrl:)]) &#123; [_delegate pushSafariWithUrl:XXXXX]; &#125; 方法注释：/** xxx */，变量注释：//&lt; xxx 注释使用清晰而协调的命名方式，让队友一看就懂，不需要注释/** * @beif: 执行push操作 （ 简单明了就可以） * * @prama: namestr 名称 * @prama: isOpen 是否打开 0 = 关闭 1= 打开 * * @discussion: 注意这个方法子啊使用时候XXXXXXXX 等等 * **/ viewC里区块划分 (过几天会提供快捷创建方式) h文件顶部:类的作用 类的注意一些内容 /** 订阅合集 分2种 我的订阅 xxxx 他的订阅 xxx */ 代理 @protocol XXXXXDelegate &lt;NSObject&gt;@required@optional- (void)delete_nameOnOne:(类 *)one nameStr:(NSString *) nameStr .... #pragma ------------------ LifeCycle生命周期 -----------------#pragma ------------------ Setter- (void)setNameLab:(UILable *)nameLab &#123; _nameLab = nameLab; &#125;#pragma ------------------ Getter- (UIButton *)nameBtn:(UIButton *) nameBtn&#123; if(!_ nameBtn)&#123; nameBtn = ... [self addSubView: nameBtn]; &#125; return nameBtn;&#125;#pragma ------------------ Layout ------------------#pragma - nameBtn#pragma - nameBtn - action //布局- (void)layoutSubviews &#123; [super layoutSubviews]; //布局写在这里 &#125;#pragma ------------------ Plubic Method ------------------- (void)update_newViewC....- (BOOL)delete_editBtn.....#pragma ------------------ private Method ------------------- (void)updateNewViewC....- (BOOL)deleteEditBtn.....#pragma mark ------------- API ------------------#pragma mark ------------- 代理#pragma ------------------ Cell ------------------/** * @brief: 设置cell * * @prama: tableView * @prama: model * @prama: indexPath * */+( PersonalSubscribeCell *)show_cellOfTableView:(UITableView *)tableView model:(PersonalSubscribeModel *)model indexPath:(NSIndexPath *)indexPath view里区块划分cell里区块划分编程习惯，一个原则：能不做的事情，尽量不做，尽量少唤醒CPU，绝不能在UI线程中做耗时操作（如网络请求，数据库读写，文件读写等）涉及到引用变量的时候，需要多想一下，哪边的操作会对引用计数有影响，尽可能少的去操作。Copy、mutableCopy要注意其关联的元素是否支持for循环不要在循环中创建引用类型变量for循环中，用局部变量替代“array.count” @autoreleasepool 建议内外都使用，可以看下YYKit源码 @autoreleasepool{ for（）{ @autoreleasepool{} } } 引用变量声明放在循环外面，可以避免在栈内存中创建过多引用变量UserInfo userInfo; // 避免循环中每次都要调用userList.count取值 int size = userList.count; for (int i = 0; i &lt; size; i++) { userInfo = userList[i]; // do something... } // 推荐 for (int i = 0, max = userList.count; i &lt; max; i++) { userInfo = userList[i]; // do something... } NSString 在不需要外部任意修改的情况下，全部用Copy BlockBlock内部需要使用外部类变量的时候，统一用@weakify(self)、@strongify(self)来防止循环引用切忌在block体中使用_name这样的变量，请使用self.name 由于Objective-C是类型不安全的，注意加强类型判断、数据越界判断等等原则上不建议拷贝代码，同一段代码拷贝3次，必须抽离出一个方法，统一调用所有的系统的宏，都不得在任意地方乱定义，统一在FFConfig文件夹下的头文件中定义，并写好注释ViewController中的代码要分结构，多用#pragma mark - Life Circle对代码进行分区，ViewController中的代码分区可分为Life Circle、Request、Private、Delegate、Lazy等等###ViewController中的代码尽量不要超过500行，注意优化 API API考虑离线缓存 如果你用一句话无法将一个方法的内容表述清楚的话，这往往就意味着API的名字需要改进了；例如：removeAtPoint:就会比remove要清晰很多 方法名 方法名应该是动词或者动词短语开头，而属性名应该是名词；当遇到冲突时，（比如这里的displayName，既可以是名字也可以是动词）应该特别注意属性和方法的上下文造成的理解不同。更好的方式是避免名动皆可的词语，比如把displayName换为screenName，就不会产生歧义了。 单元测试、优先测试、测试驱动；自己写的每个函数都需要模拟数据测试通过才行，多考虑特殊数据的情况。硬性要求，下面的情况必须注明注释，强业务逻辑部分、业务逻辑与UI强关联部分，方便后续跟进。在View上面创建控件时,先移除子控件,再去创建,避免重复创建SDAutoLayout、Masnory等在使用是要先添加到视图上之后在约束尺寸[self.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)] 提交代码规范提交代码时的描述必须写，且简明扼要就可以 我们的目标是让每一位小伙伴都能欣赏我们的代码]]></content>
      <categories>
        <category>iOS</category>
        <category>Code</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImag加载高分辨率图问题]]></title>
<url>../../../../../../../../2017/11/20/iOS-Lib-SDWebImag加载高分辨率图问题/</url>
    <content type="text"><![CDATA[SDWebImage_图片分辨率过高内存过高问题#高分辨率多图问题： 高分辨率图，导致内存飙升，卡顿，设置闪退,提示： Restore the connection to &quot;“XXX”的 iPod&quot; and run &quot;XXX&quot; again, or if &quot;XXX&quot; is still running, you can attach to it by selecting Debug &gt; Attach to Process &gt; XXX. 由于应用程序突然消耗了大量内存，然后再分配调度内存的时候，出现错误，致使系统将APP进程关闭。能够去查看一下是不是载入了大量的图片等等，或者哪里有消耗内存的地方改动一下。 分析SDWebimage， 1.判断本地是否有这张图2.二有的时候直接从本地取图片3.没有的时候去网络下载 if(imgStr.length&gt;0)&#123; [[SDImageCache sharedImageCache] queryDiskCacheForKey:imgStr done:^(UIImage *image, SDImageCacheType cacheType) &#123; if (image) &#123; [_oneImage setImage:image]; &#125;else&#123; [_oneImage sd_setImageWithURL:kNSUrl(imgStr) placeholderImage:IMGNAMED(@&quot;defaultAvatar2&quot;) options:SDWebImageRefreshCached completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123; if (image) &#123; [[SDImageCache sharedImageCache] storeImage:image forKey:imgStr toDisk:YES]; &#125; &#125;]; &#125; &#125;];&#125; 内部会调用下面这个方法- (UIImage *)diskImageForKey:(NSString *)key &#123; NSData *data = [self diskImageDataBySearchingAllPathsForKey:key]; if (data) &#123; UIImage *image = [UIImage sd_imageWithData:data]; image = [self scaledImageForKey:key image:image]; image = [UIImage decodedImageWithImage:image]; return image; &#125; else &#123; return nil; &#125; &#125; UIImage *image = [UIImage sd_imageWithData:data];图片取出来的时候就已经巨大无比，占用了很大的内存，导致内存来不及释放就崩溃 解决UIImage+MultiFormat这个类里面添加如下压缩方法，+(UIImage *)compressImageWith:(UIImage *)image &#123; float imageWidth = image.size.width; float imageHeight = image.size.height; float width = 640; float height = image.size.height/(image.size.width/width); float widthScale = imageWidth /width; float heightScale = imageHeight /height; // 创建一个bitmap的context // 并把它设置成为当前正在使用的context UIGraphicsBeginImageContext(CGSizeMake(width, height)); if (widthScale &gt; heightScale) &#123; [image drawInRect:CGRectMake(0, 0, imageWidth /heightScale , height)]; &#125; else &#123; [image drawInRect:CGRectMake(0, 0, width , imageHeight /widthScale)]; &#125; // 从当前context中创建一个改变大小后的图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); // 使当前的context出堆栈 UIGraphicsEndImageContext(); return newImage; &#125; 修改第三方方法#ifdef SD_WEBP else if ([imageContentType isEqualToString:@&quot;image/webp&quot;]) &#123; image = [UIImage sd_imageWithWebPData:data]; &#125; #endif else &#123; image = [[UIImage alloc] initWithData:data]; if (data.length/1024 &gt; 128) &#123; image = [self compressImageWith:image]; &#125; UIImageOrientation orientation = [self sd_imageOrientationFromImageData:data]; if (orientation != UIImageOrientationUp) &#123; image = [UIImage imageWithCGImage:image.CGImage scale:image.scale orientation:orientation]; &#125; 设置加载在SDWebImageDownloaderOperation的connectionDidFinishLoading方法里面的 UIImage *image = [UIImage sd_imageWithData:self.imageData]; //将等比压缩过的image在赋在转成data赋给self.imageData NSData *data = UIImageJPEGRepresentation(image, 1); self.imageData = [NSMutableData dataWithData:data]; 再配合 [[SDImageCache sharedImageCache] setValue:nil forKey:@&quot;memCache&quot;];（图片加载后使用）大功告成，亲测内存基本变化不大，自动释放也来得及]]></content>
      <categories>
        <category>iOS</category>
        <category>Lib</category>
        <category>SDWebImage</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UM_UMAnalytics友统计]]></title>
<url>../../../../../../../../2017/11/20/UM-UMAnalytics友盟统计/</url>
    <content type="text"><![CDATA[UMAnalytics友盟统计埋点官方 配置 文档—&gt; Go! 配置集成Appkey不同平台的应用禁止使用相同的Appkey，需要分开注册友盟后台的应用名与实际应用名和包名无关，建议命名为“应用名+平台（IOS/Android)” 使用 Cocoapods 安装 SDK //标准SDK，含IDFA pod &apos;UMengAnalytics&apos; 无IDFA版SDK（请根据需要选择其中一个） pod &apos;UMengAnalytics-NO-IDFA&apos; 基本功能集成配置 AppDelegate.m 主要包括填写Appkey，设置发送策略和填写渠道id三部分UMConfigInstance为SDK参数配置的实例类，只需要将其成员中标注为required的参数赋值，optional的为可选项。appKey: 统计分析-&gt;设置-&gt;应用信息ChannelId: 应用的渠道标识。默认为 @”App Store” 头文件：&quot;UMMobClick/MobClick.h&quot;- (BOOL])application:(UIApplication] *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; UMConfigInstance.appKey = @&quot;xxxxxxxxxxxxxx...&quot;; UMConfigInstance.ChannelId = @&quot;App Store&quot;; //仅适用于游戏场景，应用统计不用设置 UMConfigInstance.eSType = E_UM_GAME; //配置以上参数后调用此方法初始化SDK！ [MobClick startWithConfigure:UMConfigInstance];&#125; 页面的统计 runtime写交换方法不太好基础类可增加 - (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [MobClick beginLogPageView:@&quot;PageOne&quot;];//(&quot;PageOne&quot;为页面名称，可自定义) &#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [MobClick endLogPageView:@&quot;PageOne&quot;]; &#125; 自定义事件的统计 计数事件+计算事件 计数事件统计发生次数 某个事件发生的次数 [MobClick event:(NSString *)eventId]; 统计点击行为各属性被触发的次数[MobClick event:(NSString *)eventId attributes:(NSDictionary *)attributes];NSDictionary *dict = @&#123;@&quot;type&quot; : @&quot;book&quot;, @&quot;quantity&quot; : @&quot;3&quot;&#125;;[MobClick event:@&quot;purchase&quot; attributes:dict]; 计算事件 使用计算事件需要在后台添加事件时选择“计算事件” 统计数值型变量的值的分布 统计一个数值类型的连续变量（该变量必须为整数），用户每次触发的数值的分布情况，如事件持续时间、每次付款金额等，可以调用如下方法: +[MobClick event:(NSString *)eventId attributes:(NSDictionary *)attributes counter:(int)number]; 示例：购买《Swift Fundamentals》这本书，花了110元 [MobClick event:@&quot;pay&quot; attributes:@&#123;@&quot;book&quot; : @&quot;Swift Fundamentals&quot;&#125; counter:110]; 如果您使用的是V3.1.2以下版本的SDK，请使用下面的方法： -(void)umengEvent:(NSString *)eventId attributes:(NSDictionary *)attributes number:(NSNumber *)number&#123; NSString *numberKey = @&quot;__ct__&quot;; NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:attributes]; [mutableDictionary setObject:[number stringValue] forKey:numberKey]; [MobClick event:eventId attributes:mutableDictionary]; &#125; 示例：购买《Swift Fundamentals》这本书，花了110元 [self umengEvent:@&quot;pay&quot; attributes:@&#123;@&quot;book&quot; : @&quot;Swift Fundamentals&quot;&#125; number:@(110)];]]></content>
      <categories>
        <category>iOS</category>
        <category>UM</category>
        <category>UMAnalytics</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UI_JSBadgeView数字角标]]></title>
<url>../../../../../../../../2017/11/14/iOS-UIView-JSBadgeView数字角标/</url>
    <content type="text"><![CDATA[使用方法//在父控件上显示，//显示的位置TopRight self.badgeView = [[JSBadgeView alloc]initWithParentView:parentView alignment:JSBadgeViewAlignmentTopRight]; //位置 self.badgeView.badgePositionAdjustment = CGPointMake(-15, 10);//设置tag要辨别 self.badgeView.tag = 10086;//背景色self.badgeView.badgeBackgroundColor = [UIColor redColor]; //没有反光面self.badgeView.badgeOverlayColor = [UIColor clearColor]; //外圈的颜色，默认是白色 self.badgeView.badgeStrokeColor = [UIColor redColor]; 设置数字//1、用字符self.badgeView.badgeText = @&quot;1&quot;; //2、如果不显示就设置为空self.badgeView.badgeText = nil; //当更新数字时，最好刷新，不然由于frame固定的，数字为2位时，红圈变形 [self.badgeView setNeedsLayout];]]></content>
      <categories>
        <category>iOS</category>
        <category>UI</category>
        <category>UIView</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>iOS</tag>
        <tag>JSBadge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UILaebl_Shadow文字阴影]]></title>
<url>../../../../../../../../2017/11/14/iOS-UILabel-Shadow文字阴影/</url>
    <content type="text"><![CDATA[#方法1 设置UILabel中的shadowColor和shadowOffset属性 问题:阴影没有模糊效果，并且无法设置阴影的宽度等等，比较具有局限性 #方法2 NSShadow *shadow = [[NSShadow alloc]init]; shadow.shadowBlurRadius = 1; shadow.shadowOffset = CGSizeMake(0,1); shadow.shadowColor = [UIColor colorWithWhite:0 alpha:0.6]; NSAttributedString *attText = [[NSAttributedString alloc]initWithString:[NSString stringWithFormat:@&quot;%@浏览过&quot;,!model.read_num?@&quot;0&quot;:model.read_num] attributes:@&#123;NSShadowAttributeName:shadow&#125;]; cell.skimLab.attributedText = attText;]]></content>
      <categories>
        <category>iOS</category>
        <category>UI</category>
        <category>UILabel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-Runtime实践:占位图]]></title>
<url>../../../../../../../../2017/11/13/iOS-RunTime-占位图/</url>
    <content type="text"><![CDATA[eqweqweqw23123123]]></content>
      <categories>
        <category>iOS</category>
        <category>RumTime</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS]]></title>
<url>../../../../../../../../2016/11/23/iOS/</url>
    <content type="text"><![CDATA[iOS多线程的锁]]></content>
      <categories>
        <category>iOS</category>
        <category>Refer</category>
      </categories>
  </entry>
</search>
